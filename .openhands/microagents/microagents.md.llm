# OpenHands Microagents Documentation

This file contains the concatenated contents of all files in the .openhands/microagents directory.

---

# knowledge/code_exploration_findings.md

---
name:  mac_client_code_exploration_findings
type:  knowledge
agent:  CodeActAgent
version: 1.0.1
triggers:
- exploration
---

# OpenHands Mac Client Code Exploration Findings

This document provides detailed findings from an exploration of the codebase relevant to the Mac client application. It serves as a technical reference that outlines the functions, event structures, and system integrations discovered during the investigation.

## Overview

Our exploration focused on the integration between the UI components and backend actions through SocketIO. In particular, we reviewed the following aspects:

- **Event Communication:** Implementation details of the `oh_event` and `oh_action` event types.
- **Backend Actions:** Detailed payloads and behavior for actions such as `run` (command execution), `change_agent_state`, and `message`.
- **UI Function Calls:** How UI components trigger backend events using functions available in the code, including terminal command execution and file management.

## Key Functions and Event Structures

### oh_event

- **Purpose:** Receive asynchronous messages from the backend server.
- **Payload Structure:**
  - `timestamp`: ISO timestamp string.
  - `source`: Event source enumeration (e.g., AGENT).
  - `message`: A textual message, e.g., "Executing command: ls -l".
  - `observation`: A nested payload including details like command output and additional metadata.

**Example Payload:**

```json
{
  "timestamp": "2025-01-31T17:00:00.000Z",
  "source": "AGENT",
  "message": "Executing command: ls -l /workspace",
  "observation": { "observation": "CmdOutputObservation" },
  "content": "total 4\ndrwxr-xr-x 1 openhands openhands 4096 Jan 31 16:00 workspace",
  "extras": { "command": "ls -l /workspace", "cwd": "/workspace", "exit_code": 0 },
  "success": true
}
```

### oh_action

- **Purpose:** Send actions from the frontend UI to the backend.
- **Common Actions:**
  - **Run Command (`run`)**: Executes a bash command on the backend.
  - **Change Agent State (`change_agent_state`)**: Updates the state of the agent (e.g., PAUSED, RUNNING).
  - **Send Message (`message`)**: Sends text messages; typically used in the chat interface.

**Run Command Action Example:**

```json
{
  "action": "CmdRunAction",
  "args": { "command": "ls -l /workspace", "hidden": false }
}
```

### File Actions

The codebase also defines actions for file operations, such as:

- **READ:** Retrieve file contents from the workspace.
- **WRITE:** Create or modify file content.

Parameters typically include the file path and optional start/end line numbers.

## UI and Backend Integration

The UI components communicate with backend services using SocketIO. Key integration points include:

- **Terminal Integration:** Commands (e.g., `ls -l`) are executed, and their output is captured via `oh_event` callbacks.
- **Agent State Management:** UI control buttons trigger `change_agent_state` actions that modify the agent's behavior.
- **File Browsing:** The file explorer component retrieves file content via READ actions and can trigger WRITE actions for file modifications.

## Additional Technical Insights

- The backend leverages Python modules (such as `openhands/server/shared.py` and `openhands/server/listen_socket.py`) to manage SocketIO communications.
- Payloads are serialized in JSON, facilitating debugging and extendability.
- Asynchronous event handling ensures a responsive UI during long-running operations.

# Details from Code Exploration Findings

## 1. Frontend Code Findings (React)

The web frontend is built using React and provides valuable UI components and logic that can be used as a reference for the Mac client development.

### 1.1. UI Components (frontend/src/components/features/)

* **Chat Feature (chat/):**
    * `chat/chat-input.tsx`: User input area component using `TextareaAutosize`. Handles text input, submission, image pasting/drag-and-drop. Key prop: `onSubmit(message: string)`.
    * `chat/interactive-chat-box.tsx`: Wraps `ChatInput` and adds image upload/display functionality. Prop: `onSubmit(message: string, images: File[])`.
    * `chat/messages.tsx`: Renders a list of chat messages.
    * `chat/chat-message.tsx`: Displays individual chat messages (agent outputs).
    * **File Explorer Feature (file-explorer/):**
    * `file-explorer/file-explorer.tsx`: Main file explorer component, uses `useListFiles` hook to fetch file list and renders `ExplorerTree`.
    * `file-explorer/explorer-tree.tsx`: Renders the file tree structure recursively using `TreeNode` components.
    * `file-explorer/tree-node.tsx`: Renders individual file/folder nodes, uses `useListFiles` (for folders) and `useListFile` (for file content/metadata).
    * **Controls Feature (controls/):**
    * `controls/agent-control-bar.tsx`: Contains Pause/Resume button using `ActionButton`. Sends `CHANGE_AGENT_STATE` actions.
    * `controls/agent-status-bar.tsx`: Displays agent status using `AGENT_STATUS_MAP` and Redux state.
    * **Terminal Feature (terminal/):**
    * `terminal/terminal.tsx`: Renders a terminal UI using `xterm.js` and `useTerminal` hook.
    * `hooks/use-terminal.ts`: Custom hook for integrating `xterm.js`, handling input, output, and commands.

### 1.2. Shared Components (frontend/src/components/shared/)

* `buttons/action-button.tsx`: Reusable button component for triggering agent actions, with tooltip and styling.
* `modals/settings/settings-modal.tsx`: Modal for displaying and editing application settings, uses `SettingsForm`.
* `modals/settings/settings-form.tsx`: Form component within `SettingsModal`, contains various input fields for settings.

### 1.3. Hooks (frontend/src/hooks/query/)

* `hooks/query/use-list-files.ts`: Fetches file list from backend API endpoint `/api/conversations/{conversation_id}/list-files`.
* `hooks/query/use-list-file.ts`: (Misnamed, should be `useFileContent`) Fetches file content from backend API endpoint `/api/conversations/{conversation_id}/select-file`.
* `hooks/use-terminal.ts`: Integrates `xterm.js` terminal emulator, handles input, output, and commands.

### 1.4. Contexts (frontend/src/context/)

* `context/ws-client-provider.tsx`: Provides WebSocket context (`WsClientContext`, `useWsClient`) for SocketIO communication. Manages connection and `send` function.
* `context/conversation-context.tsx`: Provides conversation ID context (`ConversationContext`, `useConversation`) from route parameters.
* `context/files.tsx`: Provides file-related state management context (`FilesContext`, `useFiles`) for file explorer.
* `context/settings-context.tsx`: Provides settings management context.

### 1.5. API Client (frontend/src/api/)

* `api/open-hands.ts`: Defines `OpenHands` API client class with methods for interacting with backend REST API endpoints (e.g., `getFiles`, `getFile`, `saveFile`, `getSettings`, `saveSettings`, `createConversation`, `getModels`, `getAgents`).
* `api/open-hands-axios.ts`: Configures Axios instance for API requests, handles authorization headers.

### 1.6. Types and Enums (frontend/src/types/)

* `types/action-type.tsx`: Defines `ActionType` enum listing all possible action types sent to the backend (e.g., `MESSAGE`, `RUN`, `READ`, `WRITE`, `CHANGE_AGENT_STATE`).
* `types/agent-state.tsx`: Defines `AgentState` enum listing all possible agent states (e.g., `RUNNING`, `AWAITING_USER_INPUT`, `STOPPED`).
* `components/agent-status-map.constant.ts`: Defines `AGENT_STATUS_MAP` constant, mapping `AgentState` to status messages and indicator styles.

## 2. Backend Code Findings (Python FastAPI)

The backend is built using FastAPI and provides REST API endpoints and a SocketIO server for communication.

### 2.1. SocketIO Server (openhands/server/listen_socket.py)

* Sets up SocketIO server using `socketio.AsyncServer`.
* Handles `connect`, `oh_action`, and `disconnect` events.
* Implements authentication and authorization for Saas mode using JWT cookies.
* Manages conversations and agent sessions using `conversation_manager`.
* Streams agent events to clients via `oh_event` events.

### 2.2. API Endpoints (openhands/server/routes/)

* **File Management (files.py):**
    * `GET /api/conversations/{conversation_id}/list-files`: Lists files in workspace.
    * `GET /api/conversations/{conversation_id}/select-file`: Retrieves file content.
    * `POST /api/conversations/{conversation_id}/save-file`: Saves file content.
    * `POST /api/conversations/{conversation_id}/upload-files`: Uploads files to workspace.
    * `GET /api/conversations/{conversation_id}/zip-directory`: Downloads workspace as zip.
    * **Conversation Management (manage_conversations.py):**
    * `POST /api/conversations`: Creates a new conversation.
    * `GET /api/conversations`: Lists/searches conversations.
    * `GET /api/conversations/{conversation_id}`: Retrieves conversation details.
    * `PATCH /api/conversations/{conversation_id}`: Updates conversation (e.g., title).
    * `DELETE /api/conversations/{conversation_id}`: Deletes conversation.
    * **Settings (settings.py):**
    * `GET /api/settings`: Loads application settings.
    * `POST /api/settings`: Stores application settings.
    * **Options (public.py):**
    * `GET /api/options/models`: Gets available AI models.
    * `GET /api/options/agents`: Gets available agents.
    * `GET /api/options/security-analyzers`: Gets available security analyzers.
    * `GET /api/options/config`: Gets server configuration.

### 2.3. Shared Resources (openhands/server/shared.py)

* Initializes and provides shared instances of `sio` (SocketIO server), `conversation_manager`, `config`, `server_config`, `file_store`, `SettingsStoreImpl`, `ConversationStoreImpl`.

### 2.4. Core Agent Logic (openhands/core/)

* `core/main.py`: CLI entry point, contains `run_controller` function for agent execution loop.
* `core/loop.py`: Defines `run_agent_until_done` function, the agent's main execution loop (simple polling loop).
* `core/config/`: Contains configuration loading logic.
* `core/exceptions.py`: Defines core exceptions.


## 3.  Backend Communication

The Mac client UI will communicate with the Python backend using **SocketIO**.

### 3.1. SocketIO Interface

The Mac client will interact with the backend server using SocketIO events. The key events are `oh_event` (for receiving events from the backend) and `oh_action` (for sending actions to the backend).

#### 3.1.1. Receiving Events (`oh_event`)

The backend server sends events to the Mac client using the `oh_event` event. Events are serialized as dictionaries in JSON format.

**`oh_event` Data Structure:**

```json
{
    "timestamp": "ISO timestamp string",
    "source": "event source enum value (string)",
    "message": "event message (string)",
    // ... other top-level keys ...

    // Action Event:
    "action": {
        // Action-specific data
    },
    "args": {
        // Action arguments
    },
    "timeout": (optional) timeout value (number)

    // Observation Event:
    "observation": {
        // Observation-specific data
    },
    "content": "observation content (string)",
    "extras": {
        // Extra observation details (dictionary)
    },
    "success": (optional) boolean indicating command success
}
```

**Example `oh_event`:**

```json
{
  "timestamp": "2025-01-31T17:00:00.000Z",
  "source": "AGENT",
  "message": "Executing command: ls -l /workspace",
  "observation": {
    "observation": "CmdOutputObservation"
  },
  "content": "total 4\\ndrwxr-xr-x 1 openhands openhands 4096 Jan 31 16:00 workspace\\n",
  "extras": {
    "command": "ls -l /workspace",
    "cwd": "/workspace",
    "exit_code": 0
  },
  "success": true
}
```

#### 3.1.2. Sending Actions (`oh_action`)

### 3.2. Examples of `oh_action` subtypes (from Web UI)

Here are some examples of `oh_action` subtypes that are currently sent by the web UI, based on our code exploration:

#### 3.2.1. Run Command (`"run"`)

*   **Action Type String:** `"run"`
*   **Backend Action Class:** `CmdRunAction`
*   **Example `oh_action` Payload (JSON):**
    ```json
    {
      "action": "run",
      "args": {
        "command": "ls -l /workspace",
        "hidden": false
      }
    }
    ```
*   **Source (Frontend):** `/workspace/playground/frontend/src/hooks/use-terminal.ts` (`getTerminalCommand` function)
*   **Description:** This action is sent when a user executes a command in the terminal within the web UI. It instructs the backend to run a bash command.

#### 3.2.2. Change Agent State (`"change_agent_state"`)

*   **Action Type String:** `"change_agent_state"`
*   **Backend Action Class:** `ChangeAgentStateAction`
*   **Example `oh_action` Payload (JSON):**
    ```json
    {
      "action": "change_agent_state",
      "args": {
        "agent_state": "PAUSED"
      }
    }
    ```
*   **Source (Frontend):** `/workspace/playground/frontend/src/components/features/controls/agent-control-bar.tsx` and other files using `generateAgentStateChangeEvent` function.
*   **Description:** This action is sent when the user interacts with UI controls to change the agent's state, such as pausing, resuming, or stopping the agent's execution.

#### 3.2.3. Send Message (`"message"`)

*   **Action Type String:** `"message"`
*   **Backend Action Class:** `MessageAction`
*   **Example `oh_action` Payload (JSON):**
    ```json
    {
      "action": "message",
      "args": {
        "content": "Hello, agent!",
        "image_urls": [],
        "timestamp": "2025-01-31T21:00:00.000Z"
      }
    }
    ```
*   **Source (Frontend):** `/workspace/playground/frontend/src/components/features/chat/chat-interface.tsx` (`createChatMessage` function)
*   **Description:** This action is sent when the user sends a message in the chat interface. It delivers the user's message content, image URLs (if any), and timestamp to the backend agent.

*   **Action Type String:** `"change_agent_state"`
*   **Backend Action Class:** `ChangeAgentStateAction`
*   **Example `oh_action` Payload (JSON):**
    ```json
    {
      "action": "change_agent_state",
      "args": {
        "agent_state": "PAUSED"
      }
    }
    ```
*   **Source (Frontend):** `/workspace/playground/frontend/src/components/features/controls/agent-control-bar.tsx` and other files using `generateAgentStateChangeEvent` function.
*   **Description:** This action is sent when the user interacts with UI controls to change the agent's state, such as pausing, resuming, or stopping the agent's execution.

The Mac client will need to be able to send similar `oh_action` events to interact with the OpenHands backend.

The Mac client sends actions to the backend server using the `oh_action` event. These actions are triggered by **user interactions within the Mac client**, and in the backend processing, they are associated with `EventSource.USER`. Actions are also sent as dictionaries in JSON format.

**`oh_action` Data Structure:**

```json
{
    "action": "action_type_string",  // e.g., "CmdRunAction", "BrowseURLAction", "FileEditAction"
    "args": {
        // Action-specific arguments (key-value pairs)
    },
    "timeout": (optional) timeout value in seconds (number)
}
```

**Example `oh_action` (Run Bash Command):**

To run the command `ls -l /workspace`, send the following `oh_action` message:

```json
{
  "action": "CmdRunAction",
  "args": {
    "command": "ls -l /workspace"
  }
}
```

### 3.3. Internal API Naming Convention

For clarity within the Mac client codebase, we'll use more descriptive internal terminology while maintaining compatibility with backend events:

| API Event Name | Internal Term    | Description                               |
|----------------|------------------|-------------------------------------------|
| `oh_action`    | `userAction`     | User-initiated commands sent to backend   |
| `oh_event`     | `oh_event`       | All events received from backend          |

Implementation example:
```swift
// Public methods with clear naming
func sendUserAction(type: String, args: [String: Any])

// Internally mapped to compatible API event
socketManager.emit("oh_action", payload)
```

This maintains API compatibility while providing more intuitive naming in the codebase.


**Available Actions:**

Here is a list of available actions that can be sent to the backend via the `oh_action` event, along with their action type strings and arguments:

*   **Agent Actions:** (Defined in `agent.py`)
    *   `CHANGE_AGENT_STATE` (`"change_agent_state"`):
        *   `agent_state` (str, required): The new agent state.
        *   `thought` (str, optional): Agent's thought about the state change.
    *   `SUMMARIZE` (`"summarize"`):
        *   `summary` (str, required): The summary text.
    *   `FINISH` (`"finish"`):
        *   `outputs` (dict, optional): Agent outputs (e.g., `{"content": "final result"}`).
        *   `thought` (str, optional): Agent's final thought/explanation.
    *   `REJECT` (`"reject"`):


        *   `outputs` (dict, optional): Rejection details (e.g., `{"reason": "cannot fulfill request"}`).
        *   `thought` (str, optional): Agent's thought about rejection.
    *   `DELEGATE` (`"delegate"`):
        *   `agent` (str, required): Name of the agent to delegate to.
        *   `inputs` (dict, required): Inputs for the delegated agent.
        *   `thought` (str, optional): Agent's thought about delegation.

*   **Browse Actions:** (Defined in `browse.py`)
    *   `BROWSE` (`"browse"`):
        *   `url` (str, required): The URL to browse.
        *   `thought` (str, optional): Agent's thought about browsing.
    *   `BROWSE_INTERACTIVE` (`"browse_interactive"`):
        *   `browser_actions` (str, required): String containing browser actions (Python code).
        *   `thought` (str, optional): Agent's thought about interactive browsing.
        *   `browsergym_send_msg_to_user` (str, optional): Internal field (ignore).

*   **Command Actions:** (Defined in `commands.py`)
    *   `RUN` (`"run"`):
        *   `command` (str, required): The bash command to run.
        *   `is_input` (bool, optional, default: `False`): Input to running process.
        *   `thought` (str, optional): Agent's thought about command.
        *   `blocking` (bool, optional, default: `False`): Blocking command.
        *   `hidden` (bool, optional, default: `False`): Hide command output.
        *   `confirmation_state` (optional): Ignore for basic use.
        *   `security_risk` (optional): Ignore for basic use.
    *   `RUN_IPYTHON` (`"run_ipython"`):
        *   `code` (str, required): Python code to run in IPython.
        *   `thought` (str, optional): Agent's thought about code.
        *   `include_extra` (bool, optional, default: `True`): Include extra output info.
        *   `confirmation_state` (optional): Ignore for basic use.
        *   `security_risk` (optional): Ignore for basic use.
        *   `kernel_init_code` (optional): Internal field (ignore).

*   **File Actions:** (Defined in `files.py`)
    *   `READ` (`"read"`):
        *   `path` (str, required): Path to file to read.
        *   `start` (int, optional, default: `0`): Start line (0-indexed).
        *   `end` (int, optional, default: `-1`): End line (-1 for EOF).
        *   `thought` (str, optional): Agent's thought about reading.
        *   `impl_source` (optional): Internal field (ignore).
        *   `translated_ipython_code` (optional): Internal field (ignore).
    *   `WRITE` (`"write"`):
        *   `path` (str, required): Path to file to write.
        *   `content` (str, required): Content to write.
        *   `start` (int, optional, default: `0`): Start line (ignore).
        *   `end` (int, optional, default: `-1`): End line (ignore).
        *   `thought` (str, optional): Agent's thought about writing.
    *   `EDIT` (`"edit"`):
        *   `path` (str, required): Path to file to edit.
        *   `content` (str, required): Content to edit/replace.
        *   `start` (int, optional, default: `1`): Start line (1-indexed, inclusive).
        *   `end` (int, optional, default: `-1`): End line (1-indexed, inclusive, -1 for EOF).
        *   `thought` (str, optional): Agent's thought about editing.
        *   `impl_source` (optional): Internal field (ignore).
        *   `translated_ipython_code` (optional): Internal field (ignore).

*   **Empty Action:** (Defined in `empty.py`)
    *   `NULL` (`"null"`):
        *   No arguments. No-operation action.

*   **Message Action:** (Defined in `message.py`)
    *   `MESSAGE` (`"message"`):
        *   `content` (str, required): Message content to display.
        *   `image_urls` (list[str] | None, optional): Image URLs in message.
        *   `wait_for_response` (bool, optional): Wait for user response (ignore for basic use).
        *   `security_risk` (optional): Ignore for basic use.

The backend server is already configured to use SocketIO for real-time communication with the web UI.  The SocketIO server is initialized in `openhands/server/shared.py` and event handlers are defined in `openhands/server/listen_socket.py`.

The existing SocketIO setup is configured to allow Cross-Origin Requests from any origin (`cors_allowed_origins='*'`), which will allow the Mac client to connect to the backend server.

The Mac client will need to implement a SocketIO client to connect to the backend server and communicate using the same event names (`oh_action`, `oh_event`, etc.) as the web UI.

---

## 4. Data Models

The Mac client requires Swift models that correspond to the backend data structures. Based on the API specifications, these models fall into these categories:

### 5.1. Communication Models
- **Event Models** (`oh_event`)
  - `AgentEvent`: Base structure for all backend events
  - `CommandObservation`: Terminal command outputs
  - `FileObservation`: File operation results
  - `MessageEvent`: User or agent messages

- **User Action Models** (`oh_action`)
  - `CommandAction`: Terminal commands (`run`)
  - `FileAction`: File operations (`read`, `write`)
  - `AgentControlAction`: State changes (`change_agent_state`)
  - `MessageAction`: User messages

### 5.2. Agent State Model
- `AgentState` enum: Represents possible agent execution states (RUNNING, PAUSED, etc.)
- `AgentStatus`: Current agent status information

### 5.3. File System Models
- `FileNode`: Representation of workspace files and directories
- `FileContent`: Content of specific files
- `FileOperation`: Results of file operations

### 5.4. Settings Models
- `BackendSettings`: Backend connection configuration
- `UISettings`: App interface preferences

All models should implement Swift's `Codable` protocol for JSON serialization/deserialization with minimal manual mapping required.

---

# Key Takeaways for Mac Client Development (Swift/Cocoa)

This approach reuses the existing communication infrastructure and avoids the need to design a new communication protocol.

* **Technology Stack:** Swift/Cocoa is chosen for native Mac client development.
* **MVP Feature Prioritization:** Confirmed focus on MVP features: Task Input Area, Agent Output Display, Basic File Explorer, Start/Stop Control Buttons, Backend Connection Settings.
* **Backend Communication:** Mac client needs to implement:
    * **SocketIO Client:** To connect to backend, send `oh_action` events, and receive `oh_event` events. Use `WsClientProvider` and `useWsClient` in frontend code as reference.
    * **REST API Client:** To call backend REST API endpoints for file management, settings, and conversation creation. Use `OpenHands` API client in frontend code as reference.
* **UI Components:** Consider adapting or reimplementing relevant React components in Swift/Cocoa:
    * Chat input area (similar to `ChatInput`).
    * Agent output display (similar to `Messages` / `chat-message.tsx`, potentially using `xterm.js` or native terminal view for command output).
    * File explorer (similar to `FileExplorer`, `ExplorerTree`, `TreeNode`, using file management APIs).
    * Control buttons (Start/Stop/Pause/Resume, similar to `ActionButton`).
    * Settings panel (similar to `SettingsModal` / `SettingsForm`, using settings APIs).
    * **State Management:** Implement state management in the Mac client, potentially inspired by Redux or React Context patterns used in the frontend. Consider managing agent state, conversation state, file explorer state, and settings state.
    * **Authentication (if needed for Saas mode):** Implement JWT cookie-based authentication similar to the backend and web frontend if targeting Saas mode. For OSS mode, authentication might be skipped.
    * **Configuration:** Allow users to configure backend connection settings (host, TLS) in the Mac client's settings panel, similar to `VITE_BACKEND_HOST` and `VITE_USE_TLS` environment variables in the frontend.
    * **Conversation Management:** Implement conversation creation using the `POST /api/conversations` endpoint.
    121 
    122 This documentation provides a technical foundation for starting the Swift/Cocoa Mac client development, focusing on precise details and actionable information derived from the existing codebase.
    123 
    124 ## 4. Glossary of Technical Details
    125 
    126 ### 4.1. REST API Endpoints
    127 
    128 | Endpoint                                                 | Method   | Description                                                                 | Request Parameters                                                                                                | Response Format                                  |
    129 | :------------------------------------------------------- | :------- | :-------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------- |
    130 | `/api/conversations/{conversation_id}/list-files`        | GET      | Lists files in the specified path within the agent's workspace.             | `conversation_id` (path), `path` (query, optional)                                                               | JSON list of file paths                        |
    131 | `/api/conversations/{conversation_id}/select-file`      | GET      | Retrieves the content of a specified file.                               | `conversation_id` (path), `file` (query, required - absolute path in runtime)                                     | JSON: `{'code': file_content}`                   |
    132 | `/api/conversations/{conversation_id}/save-file`        | POST     | Saves (writes/updates) the content of a file in the agent's workspace.      | `conversation_id` (path), Request Body (JSON): `{'filePath': relative_path, 'content': file_content}`             | JSON: `{'message': 'File saved successfully'}`   |
    133 | `/api/conversations/{conversation_id}/upload-files`      | POST     | Uploads one or more files to the agent's workspace.                         | `conversation_id` (path), Request Body (multipart/form-data): `files` (list of files)                             | JSON: `{'message': ..., 'uploaded_files': [], 'skipped_files': []}` |\n| `/api/conversations/{conversation_id}/zip-directory`    | GET      | Downloads the entire workspace as a zip file.                               | `conversation_id` (path)                                                                                           | File response (workspace.zip)                    |\n| `/api/conversations`                                    | POST     | Creates a new conversation.                                               | Request Body (JSON): `InitSessionRequest` (`selected_repository`, `initial_user_msg`, `image_urls`)               | JSON: `{'conversation_id': conversation_id}`      |\n| `/api/conversations`                                    | GET      | Searches and retrieves a list of conversations (paginated).                | `page_id` (query, optional), `limit` (query, optional)                                                            | `ConversationInfoResultSet` JSON                 |\n| `/api/conversations/{conversation_id}`                  | GET      | Retrieves details of a specific conversation.                              | `conversation_id` (path)                                                                                           | `ConversationInfo` JSON or `null`               |\n| `/api/conversations/{conversation_id}`                  | PATCH    | Updates a conversation (currently only title).                             | `conversation_id` (path), Request Body (body parameter): `title`                                                | `True` or `False` JSON                             |\n| `/api/conversations/{conversation_id}`                  | DELETE   | Deletes a conversation.                                                     | `conversation_id` (path)                                                                                           | `True` or `False` JSON                             |\n| `/api/settings`                                          | GET      | Loads application settings.                                                 | None                                                                                                               | `SettingsWithTokenMeta` JSON or `null`           |\n| `/api/settings`                                          | POST     | Stores (saves/updates) application settings.                                | Request Body (JSON): `SettingsWithTokenMeta`                                                                       | JSON: `{'message': 'Settings stored'}`           |\n| `/api/options/models`                                     | GET      | Gets available AI models.                                                    | None                                                                                                               | JSON list of model names                         |\n| `/api/options/agents`                                     | GET      | Gets available agents.                                                       | None                                                                                                               | JSON list of agent names                         |\n| `/api/options/security-analyzers`                         | GET      | Gets available security analyzers.                                           | None                                                                                                               | JSON list of security analyzer names             |\n| `/api/options/config`                                      | GET      | Gets server configuration.                                                    | None                                                                                                               | Server configuration JSON                        |\n| `/api/conversations/{conversation_id}/config`            | GET      | Retrieves runtime configuration (runtime_id, session_id).                  | `conversation_id` (path)                                                                                           | JSON: `{'runtime_id': runtime_id, 'session_id': session_id}` |\n| `/api/conversations/{conversation_id}/vscode-url`        | GET      | Retrieves VS Code URL for the conversation's workspace.                     | `conversation_id` (path)                                                                                           | JSON: `{'vscode_url': vscode_url}`               |\n| `/api/conversations/{conversation_id}/web-hosts`        | GET      | Retrieves web hosts used by the runtime.                                     | `conversation_id` (path)                                                                                           | JSON: `{'hosts': list_of_hosts}`                  |\n\n### 4.2. `ActionType` Enum Values\n\n*   `INIT`: Agent initialization. Only sent by client.\n*   `MESSAGE`: Sending a chat message.\n*   `READ`: Reading a file.\n*   `WRITE`: Writing to a file.\n*   `RUN`: Running a bash command.\n*   `RUN_IPYTHON`: Running IPython code.\n*   `BROWSE`: Browsing a web page.\n*   `BROWSE_INTERACTIVE`: Interactive browser interaction.\n*   `DELEGATE`: Delegating a task to another agent.\n*   `FINISH`: Finishing the task.\n*   `REJECT`: Rejecting a request.\n*   `CHANGE_AGENT_STATE`: Changes the state of the agent, e.g. to paused or running\n\n### 4.3. `AgentState` Enum Values\n\n*   `LOADING`: Agent is loading/initializing.\n*   `INIT`: Agent is initialized.\n*   `RUNNING`: Agent is currently running/executing tasks.\n*   `AWAITING_USER_INPUT`: Agent is waiting for user input/message.\n*   `PAUSED`: Agent execution is paused.\n*   `STOPPED`: Agent execution is stopped.\n*   `FINISHED`: Agent has finished the task successfully.\n*   `REJECTED`: Agent rejected the task or request.\n*   `ERROR`: Agent encountered an error during execution.\n*   `RATE_LIMITED`: Agent is rate-limited by an external service (e.g., LLM API).\n*   `AWAITING_USER_CONFIRMATION`: Agent is waiting for user confirmation before proceeding with an action.\n*   `USER_CONFIRMED`: User has confirmed agent's action.\n*   `USER_REJECTED`: User has rejected agent's action.\n\n---\n


---

# knowledge/events.md

---
name: types
type: knowledge
agent: CodeActAgent
version: 1.0.0
triggers:
- openhands-events
---

# OpenHands Events JSON Specification

This document defines the complete JSON specification for all events that the OpenHands backend supports and emits to frontends. This specification will serve as a reference for implementing Swift counterparts in the Mac client.


## Table of Contents

- [Event Architecture Overview](#event-architecture-overview)
- [Base Event Structure](#base-event-structure)
- [Action Events](#action-events)
  - [Agent Actions](#agent-actions)
  - [Command Actions](#command-actions)
  - [File Actions](#file-actions)
  - [Browse Actions](#browse-actions)
  - [Message Actions](#message-actions)
  - [System Actions](#system-actions)
- [Observation Events](#observation-events)
  - [Command Observations](#command-observations)
  - [File Observations](#file-observations)
  - [Browser Observations](#browser-observations)
  - [Agent Observations](#agent-observations)
  - [Status Observations](#status-observations)
- [Enumerations](#enumerations)
  - [AgentState](#agentstate)
  - [EventSource](#eventsource)
  - [ActionConfirmationStatus](#actionconfirmationstatus)
  - [ActionSecurityRisk](#actionsecurityrisk)
  - [RecallType](#recalltype)
  - [FileEditSource](#fileEditsource)
  - [FileReadSource](#fileReadsource)
  - [ActionType](#actiontype)
  - [ObservationType](#observationtype)

## Event Architecture Overview

The OpenHands event system follows a hierarchical structure:

- **Event** (base class): Common properties for all events
  - **Action**: Events representing commands/operations to perform
  - **Observation**: Events representing results or responses

Events flow between the backend and frontend:
- **Backend → Frontend**: ALL events (both actions and observations) are streamed via `oh_event` socket event. The Mac Client needs to read and display every one.
- **Frontend → Backend**: User actions on the user interface are sent via `oh_action` socket event. The Mac Client needs to implement methods to generate these action payloads based on UI interactions.

## Base Event Structure

All events share a common structure with these basic properties:

```json
{
  "id": 123,                              // Optional: Unique identifier
  "timestamp": "2023-01-01T12:00:00Z",    // ISO timestamp
  "source": "AGENT",                      // Event source (AGENT, USER, ENVIRONMENT)
  "message": "Human-readable description", // Optional: User-friendly message to be displayed in the frontend
  "cause": 456                            // Optional: ID of the event that caused this event
}
```

When serialized, events are formatted differently based on their type:

- **Actions** have this structure:
```json
{
  // Base event properties
  "action": "action_type_string",         // The type of action
  "args": {                               // Action-specific properties
    // Properties specific to this action type
  },
  "timeout": 60                           // Optional: Timeout in seconds
}
```

- **Observations** have this structure:
```json
{
  // Base event properties
  "observation": "observation_type_string", // The type of observation
  "content": "Observation content text",    // Primary content of the observation
  "extras": {                               // Observation-specific properties
    // Properties specific to this observation type
  },
  "success": true                           // Optional: For some observation types
}
```

## Action Events

### Agent Actions

#### ChangeAgentStateAction

Changes the state of the agent (e.g., paused, running).

```json
{
  "action": "change_agent_state",
  "args": {
    "agent_state": "PAUSED",    // New agent state
    "thought": "Optional explanation for the state change"
  }
}
```

#### AgentSummarizeAction

Provides a summary of results.

```json
{
  "action": "summarize",
  "args": {
    "summary": "Summary text of the agent's work or findings"
  }
}
```

#### AgentFinishAction

Indicates the agent has completed a task.

```json
{
  "action": "finish",
  "args": {
    "final_thought": "The agent's final thought about the completed task",
    "task_completed": "true",  // "true", "partial", "false"
    "outputs": {
      "content": "Final result content",
      // Other key-value outputs
    },
    "thought": "Agent's reasoning about completing the task"
  }
}
```

#### AgentThinkAction

Logs an agent's thought process.

```json
{
  "action": "think",
  "args": {
    "thought": "The agent's detailed thought process"
  }
}
```

#### AgentRejectAction

Indicates the agent is rejecting a task.

```json
{
  "action": "reject",
  "args": {
    "outputs": {
      "reason": "Reason for the rejection"
      // Other key-value outputs
    },
    "thought": "Agent's reasoning for the rejection"
  }
}
```

#### AgentDelegateAction

Delegates a task to another agent.

```json
{
  "action": "delegate",
  "args": {
    "agent": "target_agent_name",
    "inputs": {
      // Key-value inputs for the delegated agent
      "task": "Specific task for the delegated agent"
    },
    "thought": "Reasoning for delegating this task"
  }
}
```

#### AgentRecallAction

Retrieves data from memory or knowledge base.

```json
{
  "action": "recall",
  "args": {
    "query": "The search query to retrieve data",
    "thought": "Reasoning for recalling this information"
  }
}
```

### Command Actions

#### CmdRunAction

Executes a shell command.

```json
{
  "action": "run",
  "args": {
    "command": "ls -la",                  // Command to execute
    "is_input": false,                    // Whether this is input to a running process
    "thought": "Optional explanation",    // Agent's thought about this command
    "blocking": false,                    // Whether to block until completion
    "hidden": false,                      // Whether to hide command output from user
    "confirmation_state": "confirmed",    // confirmation status
    "security_risk": null                 // Optional security risk assessment
  }
}
```

#### IPythonRunCellAction

Executes Python code in an IPython environment.

```json
{
  "action": "run_ipython",
  "args": {
    "code": "import pandas as pd\ndf = pd.DataFrame()",  // Python code to execute
    "thought": "Optional explanation",                   // Agent's thought about this code
    "include_extra": true,                               // Whether to include extra info in output
    "confirmation_state": "confirmed",                   // confirmation status
    "security_risk": null,                               // Optional security risk assessment
    "kernel_init_code": ""                               // Code to run if kernel is restarted
  }
}
```

### File Actions

#### FileReadAction

Reads content from a file.

```json
{
  "action": "read",
  "args": {
    "path": "/path/to/file.txt",          // Path to the file
    "start": 0,                           // Starting line (0-indexed)
    "end": -1,                            // Ending line (-1 for EOF)
    "thought": "Optional explanation",    // Agent's thought about reading this file
    "impl_source": "default",             // Implementation source
    "view_range": null                    // Optional view range (used in OH_ACI mode)
  }
}
```

#### FileWriteAction

Writes content to a file.

```json
{
  "action": "write",
  "args": {
    "path": "/path/to/file.txt",          // Path to the file
    "content": "File content to write",   // Content to write
    "start": 0,                           // Starting line (0-indexed)
    "end": -1,                            // Ending line (-1 for EOF)
    "thought": "Optional explanation",    // Agent's thought about writing this file
    "security_risk": null                 // Optional security risk assessment
  }
}
```

#### FileEditAction

Performs more complex file edits.

```json
{
  "action": "edit",
  "args": {
    "path": "/path/to/file.txt",          // Path to the file
    
    // For OH_ACI mode
    "command": "str_replace",             // Edit command (view, create, str_replace, insert, undo_edit, write)
    "file_text": null,                    // File content for 'create' command
    "old_str": "text to replace",         // String to replace for 'str_replace' command
    "new_str": "replacement text",        // Replacement string for 'str_replace' or 'insert' commands
    "insert_line": null,                  // Line number for 'insert' command
    
    // For LLM-based editing
    "content": "",                        // Content to write or edit
    "start": 1,                           // Starting line (1-indexed, inclusive)
    "end": -1,                            // Ending line (1-indexed, inclusive, -1 for EOF)
    
    "thought": "Optional explanation",    // Agent's thought about editing this file
    "security_risk": null,                // Optional security risk assessment
    "impl_source": "oh_aci"               // Implementation source (oh_aci or llm_based_edit)
  }
}
```

### Browse Actions

#### BrowseURLAction

Browses a URL.

```json
{
  "action": "browse",
  "args": {
    "url": "https://example.com",         // URL to browse
    "thought": "Optional explanation",    // Agent's thought about browsing this URL
    "security_risk": null                 // Optional security risk assessment
  }
}
```

#### BrowseInteractiveAction

Performs interactive browser actions.

```json
{
  "action": "browse_interactive",
  "args": {
    "browser_actions": "browser.click('#button')",   // Browser action code 
    "thought": "Optional explanation",               // Agent's thought about these actions
    "browsergym_send_msg_to_user": "",               // Message to send to user
    "security_risk": null                            // Optional security risk assessment
  }
}
```

### Message Actions

#### MessageAction

Sends a message between agent and user.

```json
{
  "action": "message",
  "args": {
    "content": "Message content",         // Content of the message
    "image_urls": [                       // Optional list of image URLs
      "https://example.com/image.jpg"
    ],
    "wait_for_response": false,           // Whether to wait for response
    "security_risk": null                 // Optional security risk assessment
  }
}
```

### System Actions

#### NullAction

A placeholder action that does nothing.

```json
{
  "action": "null"
}
```

## Observation Events

### Command Observations

#### CmdOutputObservation

Represents the output of a command execution.

```json
{
  "observation": "run",
  "content": "Command output text",
  "extras": {
    "command": "ls -la",                  // The command that was executed
    "metadata": {                         // Metadata about the command
      "exit_code": 0,                     // Exit code of the command
      "pid": 12345,                       // Process ID
      "username": "user",                 // Username
      "hostname": "host",                 // Hostname
      "working_dir": "/current/dir",      // Working directory
      "py_interpreter_path": "/path/to/python", // Python interpreter path
      "prefix": "",                       // Prefix to add to command output
      "suffix": ""                        // Suffix to add to command output
    },
    "hidden": false                       // Whether command output is hidden from user
  },
  "success": true                         // Whether command executed successfully
}
```

#### IPythonRunCellObservation

Represents the output of a Python code execution in IPython.

```json
{
  "observation": "run_ipython",
  "content": "Python code execution output",
  "extras": {
    "code": "import pandas as pd\ndf = pd.DataFrame()"  // The code that was executed
  }
}
```

### File Observations

#### FileReadObservation

Represents the content read from a file.

```json
{
  "observation": "read",
  "content": "File content read from the file",
  "extras": {
    "path": "/path/to/file.txt",          // Path to the file that was read
    "impl_source": "default"              // Implementation source
  }
}
```

#### FileWriteObservation

Represents the result of writing to a file.

```json
{
  "observation": "write",
  "content": "Success message or details about write operation",
  "extras": {
    "path": "/path/to/file.txt"           // Path to the file that was written
  }
}
```

#### FileEditObservation

Represents the result of editing a file.

```json
{
  "observation": "edit",
  "content": "Edit results, often a diff or success message",
  "extras": {
    "path": "/path/to/file.txt",          // Path to the file that was edited
    "prev_exist": true,                   // Whether the file existed before the edit
    "old_content": "Previous content",    // File content before the edit
    "new_content": "New content",         // File content after the edit
    "impl_source": "llm_based_edit",      // Implementation source
    "diff": null                          // Raw diff between old and new content (OH_ACI mode)
  }
}
```

### Browser Observations

#### BrowserOutputObservation

Represents the output of a browser operation.

```json
{
  "observation": "browse",
  "content": "Browser content or operation result",
  "extras": {
    "url": "https://example.com",          // URL that was browsed
    "trigger_by_action": "browse",         // Action that triggered this observation
    "screenshot": "",                      // Base64-encoded screenshot (often empty in JSON)
    "set_of_marks": "",                    // Browser marks information
    "error": false,                        // Whether there was an error
    "goal_image_urls": [],                 // URLs of goal images
    "open_pages_urls": [                   // URLs of open browser pages
      "https://example.com"
    ],
    "active_page_index": 0,                // Index of the active page
    "last_browser_action": "",             // Last browser action performed
    "last_browser_action_error": "",       // Error message from last browser action
    "focused_element_bid": ""              // ID of the focused element
  }
}
```

### Agent Observations

#### AgentStateChangedObservation

Represents a change in the agent's state.

```json
{
  "observation": "agent_state_changed",
  "content": "",
  "extras": {
    "agent_state": "RUNNING"               // New agent state
  }
}
```

#### AgentCondensationObservation

Represents the result of memory condensation.

```json
{
  "observation": "condense",
  "content": "Condensed memory content"
}
```

#### AgentThinkObservation

Represents the agent's thought process.

```json
{
  "observation": "think",
  "content": "Agent's thought content"
}
```

#### RecallObservation

Represents data retrieved from memory or knowledge.

```json
{
  "observation": "recall",
  "content": "Recalled information",
  "extras": {
    "recall_type": "environment_info",     // Type of recall
    "repo_name": "openhands",              // Repository name
    "repo_directory": "/path/to/repo",     // Repository directory
    "repo_instructions": "Task instructions", // Repository instructions
    "runtime_hosts": {},                   // Runtime hosts information
    "additional_agent_instructions": "",   // Additional instructions
    "microagent_knowledge": [              // Knowledge from microagents
      {
        "agent_name": "python_best_practices",
        "trigger_word": "python",
        "content": "Use virtual environments"
      }
    ]
  }
}
```

#### AgentDelegateObservation

Represents the result of delegating to another agent.

```json
{
  "observation": "delegate",
  "content": "Delegation result content",
  "extras": {
    "outputs": {                           // Outputs from the delegated agent
      // Key-value outputs
    }
  }
}
```

### Status Observations

#### ErrorObservation

Represents an error encountered by the agent.

```json
{
  "observation": "error",
  "content": "Error message or details",
  "extras": {
    "error_id": "error_identifier"          // Optional error identifier
  }
}
```

#### SuccessObservation

Represents a successful operation.

```json
{
  "observation": "success",
  "content": "Success message or details"
}
```

#### UserRejectObservation

Represents a user rejection.

```json
{
  "observation": "user_rejected",
  "content": "User rejection message or details"
}
```

#### NullObservation

A placeholder observation that contains no meaningful information.

```json
{
  "observation": "null",
  "content": ""
}
```

## Enumerations

### AgentState

Represents the current state of the agent.

```json
// One of these string values:
"LOADING"                    // Agent is loading/initializing
"INIT"                       // Agent is initialized
"RUNNING"                    // Agent is currently running/executing tasks
"AWAITING_USER_INPUT"        // Agent is waiting for user input/message
"PAUSED"                     // Agent execution is paused
"STOPPED"                    // Agent execution is stopped
"FINISHED"                   // Agent has finished the task successfully
"REJECTED"                   // Agent rejected the task or request
"ERROR"                      // Agent encountered an error during execution
"RATE_LIMITED"               // Agent is rate-limited by an external service
"AWAITING_USER_CONFIRMATION" // Agent is waiting for user confirmation
"USER_CONFIRMED"             // User has confirmed agent's action
"USER_REJECTED"              // User has rejected agent's action
```

### EventSource

Indicates the source of an event.

```json
// One of these string values:
"agent"       // Event originated from the agent
"user"        // Event originated from the user
"environment" // Event originated from the environment
```

### ActionConfirmationStatus

Indicates the confirmation status of an action.

```json
// One of these string values:
"confirmed"            // Action is confirmed
"rejected"             // Action is rejected
"awaiting_confirmation" // Action is awaiting confirmation
```

### ActionSecurityRisk

Indicates the security risk level of an action.

```json
// One of these integer values:
-1  // UNKNOWN
0   // LOW
1   // MEDIUM
2   // HIGH
```

### RecallType

Indicates the type of information recalled.

```json
// One of these string values:
"environment_info"      // Environment information (repo instructions, runtime, etc.)
"knowledge_microagent"  // Knowledge from a microagent
"default"               // Default or other type of recall
```

### FileEditSource

Indicates the source of a file edit implementation.

```json
// One of these string values:
"llm_based_edit"  // LLM-based editing
"oh_aci"          // OpenHands ACI
```

### FileReadSource

Indicates the source of a file read implementation.

```json
// One of these string values:
"oh_aci"    // OpenHands ACI
"default"   // Default implementation
```

### ActionType

Defines the supported action types.

```json
// One of these string values:
"null"                // Empty action that does nothing
"run"                 // Run shell command
"run_ipython"         // Run Python code in IPython
"browse"              // Browse a URL
"browse_interactive"  // Interact with a browser
"read"                // Read file
"write"               // Write to file
"edit"                // Edit file
"message"             // Send message
"think"               // Log agent thought
"delegate"            // Delegate to another agent
"finish"              // Finish task
"reject"              // Reject task
"summarize"           // Summarize results
"recall"              // Recall information from memory
"change_agent_state"  // Change agent state
```

### ObservationType

Defines the supported observation types.

```json
// One of these string values:
"null"               // Empty observation
"run"                // Command output
"run_ipython"        // IPython execution result
"browse"             // Browser output
"read"               // File read result
"write"              // File write result
"edit"               // File edit result
"error"              // Error
"success"            // Success
"user_rejected"      // User rejection
"agent_state_changed" // Agent state changed
"delegate"           // Delegation result
"think"              // Agent thought result
"condense"           // Memory condensation result
"recall"             // Memory recall result
```



---

# knowledge/mac-types.md

---
 name: mac-types
 type: knowledge
 agent: CodeActAgent
 version: 1.0.0
 triggers:
 - mac-types
---

# Types for the Mac Client functionality

This document catalogs the data types needed for implementing the OpenHands Mac client specific functionality.

For types representing openhands' events, which are set in stone since they are implemented on backend/server side, see: events.md

IMPORTANT: unlike the specs dependent on backend definitions, this document is open to change while we are writing the spec!

### FileNode

Represents a file or directory in the workspace.

```json
{
  "path": "/workspace/dir",
  "name": "dir",
  "type": "directory",
  "children": [
    {
      "path": "/workspace/dir/file.txt",
      "name": "file.txt",
      "type": "file",
      "size": 1024
    }
  ]
}
```

### FileContent

Represents the content of a file.

```json
{
  "code": "File content as string"
}
```

# BackendSettings

Configuration for connecting to the backend.

```json
{
  "backend_host": "localhost",
  "backend_port": 8000,
  "use_tls": false
}
```


---

# tasks/impl_backend_connection.md

# Backend Connection Management for Mac Client

This document outlines the implementation details for managing backend connections in the Mac client, including connection persistence, status indicators, and retry mechanisms.

## 1. Connection Persistence Across App Launches

### 1.1 Connection Configuration Storage

```swift
struct ConnectionConfiguration: Codable {
    let serverURL: URL
    let conversationId: String
    let lastEventId: String?
    let authToken: String?
    let connectionParams: [String: String]
    
    // Default configuration
    static let `default` = ConnectionConfiguration(
        serverURL: URL(string: "https://api.openhands.dev")!,
        conversationId: "",
        lastEventId: nil,
        authToken: nil,
        connectionParams: [:]
    )
}

class ConnectionConfigurationStore {
    private let userDefaults = UserDefaults.standard
    private let configKey = "connection_configuration"
    
    func saveConfiguration(_ config: ConnectionConfiguration) {
        do {
            let encoder = JSONEncoder()
            let data = try encoder.encode(config)
            userDefaults.set(data, forKey: configKey)
        } catch {
            print("Failed to save connection configuration: \(error)")
        }
    }
    
    func loadConfiguration() -> ConnectionConfiguration {
        guard let data = userDefaults.data(forKey: configKey) else {
            return .default
        }
        
        do {
            let decoder = JSONDecoder()
            return try decoder.decode(ConnectionConfiguration.self, from: data)
        } catch {
            print("Failed to load connection configuration: \(error)")
            return .default
        }
    }
    
    func updateLastEventId(_ eventId: String) {
        var config = loadConfiguration()
        config.lastEventId = eventId
        saveConfiguration(config)
    }
    
    func clearConfiguration() {
        userDefaults.removeObject(forKey: configKey)
    }
}
```

### 1.2 Connection Manager with Persistence

```swift
class ConnectionManager: ObservableObject {
    @Published private(set) var status: ConnectionStatus = .disconnected
    @Published private(set) var currentConversationId: String?
    
    private let configStore = ConnectionConfigurationStore()
    private var socketManager: SocketManager?
    
    init() {
        // Restore previous connection on app launch if available
        let savedConfig = configStore.loadConfiguration()
        if !savedConfig.conversationId.isEmpty {
            currentConversationId = savedConfig.conversationId
            
            // Don't automatically connect, but prepare the connection
            prepareConnection(with: savedConfig)
        }
    }
    
    func connect(to conversationId: String, serverURL: URL? = nil) {
        // Update current conversation ID
        currentConversationId = conversationId
        
        // Create or update configuration
        var config = configStore.loadConfiguration()
        config.conversationId = conversationId
        if let serverURL = serverURL {
            config.serverURL = serverURL
        }
        
        // Save the configuration
        configStore.saveConfiguration(config)
        
        // Prepare and establish connection
        prepareConnection(with: config)
        socketManager?.connect()
    }
    
    func disconnect() {
        socketManager?.disconnect()
        status = .disconnected
    }
    
    private func prepareConnection(with config: ConnectionConfiguration) {
        // Create socket manager with the saved configuration
        socketManager = SocketManager(
            serverURL: config.serverURL,
            conversationId: config.conversationId,
            lastEventId: config.lastEventId,
            authToken: config.authToken,
            additionalParams: config.connectionParams
        )
        
        // Set up status change handler
        socketManager?.onStatusChange = { [weak self] newStatus in
            DispatchQueue.main.async {
                self?.status = newStatus
            }
        }
        
        // Set up event ID tracking for persistence
        socketManager?.onEventReceived = { [weak self] eventId in
            if let eventId = eventId {
                self?.configStore.updateLastEventId(eventId)
            }
        }
    }
    
    func updateServerURL(_ url: URL) {
        var config = configStore.loadConfiguration()
        config.serverURL = url
        configStore.saveConfiguration(config)
        
        // Reconnect with new URL if currently connected
        if status == .connected, let conversationId = currentConversationId {
            disconnect()
            connect(to: conversationId, serverURL: url)
        }
    }
}
```

### 1.3 App Delegate Integration

```swift
class AppDelegate: NSObject, NSApplicationDelegate {
    let connectionManager = ConnectionManager()
    
    func applicationDidFinishLaunching(_ notification: Notification) {
        // Restore connection if needed
        if let conversationId = connectionManager.currentConversationId {
            // Optionally auto-connect or just prepare the connection
            // connectionManager.connect(to: conversationId)
        }
    }
    
    func applicationWillTerminate(_ notification: Notification) {
        // Gracefully disconnect
        connectionManager.disconnect()
    }
}
```

## 2. Connection Status Indicators

### 2.1 Connection Status Enum

```swift
enum ConnectionStatus: Equatable {
    case disconnected
    case connecting
    case connected
    case reconnecting(attempt: Int, maxAttempts: Int)
    case error(message: String)
    
    var description: String {
        switch self {
        case .disconnected:
            return "Disconnected"
        case .connecting:
            return "Connecting..."
        case .connected:
            return "Connected"
        case .reconnecting(let attempt, let maxAttempts):
            return "Reconnecting (\(attempt)/\(maxAttempts))..."
        case .error(let message):
            return "Error: \(message)"
        }
    }
    
    var isConnected: Bool {
        if case .connected = self {
            return true
        }
        return false
    }
    
    var isConnecting: Bool {
        if case .connecting = self {
            return true
        }
        if case .reconnecting = self {
            return true
        }
        return false
    }
}
```

### 2.2 Status Indicator View

```swift
struct ConnectionStatusIndicatorView: View {
    @ObservedObject var connectionManager: ConnectionManager
    
    var body: some View {
        HStack(spacing: 8) {
            // Status icon
            Circle()
                .fill(statusColor)
                .frame(width: 8, height: 8)
            
            // Status text
            Text(connectionManager.status.description)
                .font(.caption)
                .foregroundColor(textColor)
            
            // Reconnect button if needed
            if case .error = connectionManager.status, 
               let conversationId = connectionManager.currentConversationId {
                Button(action: {
                    connectionManager.connect(to: conversationId)
                }) {
                    Image(systemName: "arrow.clockwise")
                        .font(.caption)
                }
                .buttonStyle(BorderlessButtonStyle())
            }
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 6)
        .background(backgroundColor)
        .cornerRadius(12)
    }
    
    private var statusColor: Color {
        switch connectionManager.status {
        case .connected:
            return .green
        case .connecting, .reconnecting:
            return .yellow
        case .disconnected:
            return .gray
        case .error:
            return .red
        }
    }
    
    private var textColor: Color {
        switch connectionManager.status {
        case .error:
            return .red
        default:
            return .primary
        }
    }
    
    private var backgroundColor: Color {
        switch connectionManager.status {
        case .error:
            return Color.red.opacity(0.1)
        case .connecting, .reconnecting:
            return Color.yellow.opacity(0.1)
        case .connected:
            return Color.green.opacity(0.1)
        default:
            return Color.gray.opacity(0.1)
        }
    }
}
```

### 2.3 Menu Bar Status Indicator

```swift
class StatusBarController {
    private var statusItem: NSStatusItem
    private var connectionManager: ConnectionManager
    
    init(connectionManager: ConnectionManager) {
        self.connectionManager = connectionManager
        
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
        
        if let button = statusItem.button {
            button.image = NSImage(systemSymbolName: "circle.fill", accessibilityDescription: "Connection Status")
            updateStatusItemAppearance()
        }
        
        // Observe connection status changes
        connectionManager.$status.sink { [weak self] newStatus in
            self?.updateStatusItemAppearance()
        }
        .store(in: &cancellables)
    }
    
    private func updateStatusItemAppearance() {
        guard let button = statusItem.button else { return }
        
        // Update icon based on connection status
        switch connectionManager.status {
        case .connected:
            button.image = NSImage(systemSymbolName: "circle.fill", accessibilityDescription: "Connected")
            button.contentTintColor = .systemGreen
            
        case .connecting:
            button.image = NSImage(systemSymbolName: "circle.fill", accessibilityDescription: "Connecting")
            button.contentTintColor = .systemYellow
            
        case .reconnecting:
            button.image = NSImage(systemSymbolName: "arrow.clockwise", accessibilityDescription: "Reconnecting")
            button.contentTintColor = .systemYellow
            
        case .disconnected:
            button.image = NSImage(systemSymbolName: "circle.fill", accessibilityDescription: "Disconnected")
            button.contentTintColor = .systemGray
            
        case .error:
            button.image = NSImage(systemSymbolName: "exclamationmark.circle.fill", accessibilityDescription: "Connection Error")
            button.contentTintColor = .systemRed
        }
        
        // Update tooltip
        button.toolTip = "OpenHands: \(connectionManager.status.description)"
    }
}
```

## 3. Retry Mechanism

### 3.1 Advanced Retry Configuration

```swift
struct RetryConfiguration: Codable {
    let initialDelay: TimeInterval
    let maxDelay: TimeInterval
    let maxAttempts: Int
    let jitter: Bool
    let backoffFactor: Double
    
    // Default configuration
    static let `default` = RetryConfiguration(
        initialDelay: 1.0,
        maxDelay: 30.0,
        maxAttempts: 10,
        jitter: true,
        backoffFactor: 1.5
    )
}
```

### 3.2 Retry Manager Implementation

```swift
class RetryManager {
    private let configuration: RetryConfiguration
    private var currentAttempt = 0
    private var timer: Timer?
    private var onRetry: (() -> Void)?
    
    init(configuration: RetryConfiguration = .default) {
        self.configuration = configuration
    }
    
    func startRetrying(onRetry: @escaping () -> Void) {
        self.onRetry = onRetry
        currentAttempt = 0
        scheduleNextRetry()
    }
    
    func stop() {
        timer?.invalidate()
        timer = nil
        currentAttempt = 0
    }
    
    func retry() {
        timer?.invalidate()
        timer = nil
        
        if currentAttempt < configuration.maxAttempts {
            onRetry?()
            currentAttempt += 1
        }
    }
    
    private func scheduleNextRetry() {
        guard currentAttempt < configuration.maxAttempts else {
            // Max attempts reached
            return
        }
        
        // Calculate delay with exponential backoff
        let baseDelay = configuration.initialDelay * pow(configuration.backoffFactor, Double(currentAttempt))
        let delay = min(baseDelay, configuration.maxDelay)
        
        // Add jitter if configured
        let actualDelay = configuration.jitter ? addJitter(to: delay) : delay
        
        timer = Timer.scheduledTimer(withTimeInterval: actualDelay, repeats: false) { [weak self] _ in
            self?.retry()
        }
    }
    
    private func addJitter(to delay: TimeInterval) -> TimeInterval {
        // Add random jitter of ±30%
        let jitterFactor = 0.7 + (Double.random(in: 0...0.6))
        return delay * jitterFactor
    }
    
    var currentStatus: ConnectionStatus {
        if currentAttempt > 0 {
            return .reconnecting(attempt: currentAttempt, maxAttempts: configuration.maxAttempts)
        } else {
            return .disconnected
        }
    }
}
```

### 3.3 Integration with Socket Manager

```swift
class SocketManager {
    // ... other properties ...
    
    private let retryManager: RetryManager
    private var isManuallyDisconnected = false
    
    init(serverURL: URL, conversationId: String, lastEventId: String? = nil, 
         authToken: String? = nil, additionalParams: [String: String] = [:],
         retryConfiguration: RetryConfiguration = .default) {
        
        self.retryManager = RetryManager(configuration: retryConfiguration)
        
        // ... other initialization ...
        
        setupSocketHandlers()
    }
    
    private func setupSocketHandlers() {
        // ... other handlers ...
        
        socket.on(clientEvent: .disconnect) { [weak self] data, _ in
            guard let self = self else { return }
            
            // Update status
            self.updateStatus(.disconnected)
            
            // Start retry process if not manually disconnected
            if !self.isManuallyDisconnected {
                self.retryManager.startRetrying { [weak self] in
                    self?.updateStatus(self?.retryManager.currentStatus ?? .reconnecting(attempt: 0, maxAttempts: 0))
                    self?.connect()
                }
            }
        }
    }
    
    func connect() {
        isManuallyDisconnected = false
        retryManager.stop()
        updateStatus(.connecting)
        socket.connect()
    }
    
    func disconnect() {
        isManuallyDisconnected = true
        retryManager.stop()
        socket.disconnect()
        updateStatus(.disconnected)
    }
    
    private func updateStatus(_ newStatus: ConnectionStatus) {
        DispatchQueue.main.async {
            self.status = newStatus
            self.onStatusChange?(newStatus)
        }
    }
}
```

## 4. Connection Health Monitoring

### 4.1 Heartbeat Mechanism

```swift
class HeartbeatMonitor {
    private let heartbeatInterval: TimeInterval
    private let timeoutInterval: TimeInterval
    private var timer: Timer?
    private var lastHeartbeatResponse: Date?
    private var onTimeout: (() -> Void)?
    
    init(heartbeatInterval: TimeInterval = 30.0, timeoutInterval: TimeInterval = 10.0) {
        self.heartbeatInterval = heartbeatInterval
        self.timeoutInterval = timeoutInterval
    }
    
    func start(onTimeout: @escaping () -> Void) {
        self.onTimeout = onTimeout
        lastHeartbeatResponse = Date()
        
        timer = Timer.scheduledTimer(withTimeInterval: heartbeatInterval, repeats: true) { [weak self] _ in
            self?.sendHeartbeat()
        }
    }
    
    func stop() {
        timer?.invalidate()
        timer = nil
    }
    
    func receivedHeartbeat() {
        lastHeartbeatResponse = Date()
    }
    
    private func sendHeartbeat() {
        // Send heartbeat to server
        // This would typically emit a socket event
        
        // Check if previous heartbeat timed out
        if let lastResponse = lastHeartbeatResponse,
           Date().timeIntervalSince(lastResponse) > heartbeatInterval + timeoutInterval {
            // Connection is considered dead
            onTimeout?()
        }
    }
}
```

### 4.2 Integration with Socket Manager

```swift
class SocketManager {
    // ... other properties ...
    
    private let heartbeatMonitor: HeartbeatMonitor
    
    init(/* ... */) {
        // ... other initialization ...
        
        self.heartbeatMonitor = HeartbeatMonitor()
        
        setupSocketHandlers()
    }
    
    private func setupSocketHandlers() {
        // ... other handlers ...
        
        socket.on(clientEvent: .connect) { [weak self] _, _ in
            guard let self = self else { return }
            
            self.updateStatus(.connected)
            
            // Start heartbeat monitoring
            self.heartbeatMonitor.start { [weak self] in
                // Connection timed out
                self?.socket.disconnect()
                self?.updateStatus(.error(message: "Connection timed out"))
            }
        }
        
        socket.on(clientEvent: .disconnect) { [weak self] _, _ in
            // Stop heartbeat monitoring
            self?.heartbeatMonitor.stop()
            
            // ... other disconnect handling ...
        }
        
        // Listen for heartbeat responses
        socket.on("pong") { [weak self] _, _ in
            self?.heartbeatMonitor.receivedHeartbeat()
        }
    }
    
    // Send periodic ping to keep connection alive
    private func startPingTimer() {
        pingTimer = Timer.scheduledTimer(withTimeInterval: 30, repeats: true) { [weak self] _ in
            self?.socket.emit("ping")
        }
    }
}
```

## 5. Connection Diagnostics

### 5.1 Connection Quality Monitoring

```swift
class ConnectionQualityMonitor {
    enum ConnectionQuality {
        case excellent
        case good
        case fair
        case poor
        case unusable
        
        var description: String {
            switch self {
            case .excellent: return "Excellent"
            case .good: return "Good"
            case .fair: return "Fair"
            case .poor: return "Poor"
            case .unusable: return "Unusable"
            }
        }
    }
    
    private var latencyMeasurements: [TimeInterval] = []
    private var pingTimer: Timer?
    private var onQualityChange: ((ConnectionQuality) -> Void)?
    
    func start(socket: SocketIOClient, onQualityChange: @escaping (ConnectionQuality) -> Void) {
        self.onQualityChange = onQualityChange
        
        // Set up ping-pong for latency measurement
        socket.on("pong") { [weak self] data, _ in
            guard let self = self,
                  let pingData = data.first as? [String: Any],
                  let sentTime = pingData["sent"] as? TimeInterval else {
                return
            }
            
            let latency = Date().timeIntervalSince1970 - sentTime
            self.recordLatency(latency)
        }
        
        // Send pings every 5 seconds
        pingTimer = Timer.scheduledTimer(withTimeInterval: 5, repeats: true) { [weak self, weak socket] _ in
            let pingData: [String: Any] = ["sent": Date().timeIntervalSince1970]
            socket?.emit("ping", pingData)
        }
    }
    
    func stop() {
        pingTimer?.invalidate()
        pingTimer = nil
        latencyMeasurements.removeAll()
    }
    
    private func recordLatency(_ latency: TimeInterval) {
        // Keep last 10 measurements
        latencyMeasurements.append(latency)
        if latencyMeasurements.count > 10 {
            latencyMeasurements.removeFirst()
        }
        
        // Calculate average latency
        let averageLatency = latencyMeasurements.reduce(0, +) / Double(latencyMeasurements.count)
        
        // Determine connection quality
        let quality = determineQuality(from: averageLatency)
        onQualityChange?(quality)
    }
    
    private func determineQuality(from latency: TimeInterval) -> ConnectionQuality {
        switch latency {
        case 0..<0.1:
            return .excellent
        case 0.1..<0.3:
            return .good
        case 0.3..<0.5:
            return .fair
        case 0.5..<1.0:
            return .poor
        default:
            return .unusable
        }
    }
}
```

### 5.2 Diagnostic Tools

```swift
class ConnectionDiagnostics {
    private let socketManager: SocketManager
    
    init(socketManager: SocketManager) {
        self.socketManager = socketManager
    }
    
    func runDiagnostics(completion: @escaping (DiagnosticResult) -> Void) {
        var results = DiagnosticResult()
        
        // Check internet connectivity
        checkInternetConnectivity { isConnected in
            results.internetConnected = isConnected
            
            // Check server reachability
            self.checkServerReachability { isReachable in
                results.serverReachable = isReachable
                
                // Check WebSocket connectivity
                self.checkWebSocketConnectivity { canConnect in
                    results.webSocketConnectable = canConnect
                    
                    // Check authentication
                    self.checkAuthentication { isAuthenticated in
                        results.authenticated = isAuthenticated
                        
                        // Return complete results
                        completion(results)
                    }
                }
            }
        }
    }
    
    private func checkInternetConnectivity(completion: @escaping (Bool) -> Void) {
        // Simple check by trying to reach a reliable host
        let url = URL(string: "https://www.apple.com")!
        let task = URLSession.shared.dataTask(with: url) { _, response, error in
            let isConnected = error == nil && (response as? HTTPURLResponse)?.statusCode == 200
            completion(isConnected)
        }
        task.resume()
    }
    
    private func checkServerReachability(completion: @escaping (Bool) -> Void) {
        // Try to reach the server's health endpoint
        guard let serverURL = socketManager.serverURL else {
            completion(false)
            return
        }
        
        var healthURL = serverURL
        healthURL.appendPathComponent("health")
        
        let task = URLSession.shared.dataTask(with: healthURL) { _, response, error in
            let isReachable = error == nil && (response as? HTTPURLResponse)?.statusCode == 200
            completion(isReachable)
        }
        task.resume()
    }
    
    private func checkWebSocketConnectivity(completion: @escaping (Bool) -> Void) {
        // Try to establish a temporary WebSocket connection
        let tempSocket = socketManager.createTemporarySocket()
        
        var didComplete = false
        
        tempSocket.on(clientEvent: .connect) { _, _ in
            if !didComplete {
                didComplete = true
                tempSocket.disconnect()
                completion(true)
            }
        }
        
        tempSocket.on(clientEvent: .error) { _, _ in
            if !didComplete {
                didComplete = true
                tempSocket.disconnect()
                completion(false)
            }
        }
        
        // Set timeout
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
            if !didComplete {
                didComplete = true
                tempSocket.disconnect()
                completion(false)
            }
        }
        
        tempSocket.connect()
    }
    
    private func checkAuthentication(completion: @escaping (Bool) -> Void) {
        // Try to access an authenticated endpoint
        socketManager.checkAuthentication(completion: completion)
    }
    
    struct DiagnosticResult {
        var internetConnected = false
        var serverReachable = false
        var webSocketConnectable = false
        var authenticated = false
        
        var summary: String {
            var issues: [String] = []
            
            if !internetConnected {
                issues.append("No internet connection")
            }
            
            if internetConnected && !serverReachable {
                issues.append("Server is unreachable")
            }
            
            if serverReachable && !webSocketConnectable {
                issues.append("WebSocket connection failed")
            }
            
            if webSocketConnectable && !authenticated {
                issues.append("Authentication failed")
            }
            
            if issues.isEmpty {
                return "All systems operational"
            } else {
                return "Issues detected: " + issues.joined(separator: ", ")
            }
        }
    }
}
```

### 5.3 Diagnostic UI

```swift
struct ConnectionDiagnosticsView: View {
    @StateObject private var viewModel = ConnectionDiagnosticsViewModel()
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Connection Diagnostics")
                .font(.headline)
            
            if viewModel.isRunningDiagnostics {
                ProgressView("Running diagnostics...")
            } else {
                VStack(alignment: .leading, spacing: 8) {
                    DiagnosticItemView(
                        title: "Internet Connection",
                        status: viewModel.result?.internetConnected ?? false
                    )
                    
                    DiagnosticItemView(
                        title: "Server Reachable",
                        status: viewModel.result?.serverReachable ?? false
                    )
                    
                    DiagnosticItemView(
                        title: "WebSocket Connection",
                        status: viewModel.result?.webSocketConnectable ?? false
                    )
                    
                    DiagnosticItemView(
                        title: "Authentication",
                        status: viewModel.result?.authenticated ?? false
                    )
                }
                
                if let result = viewModel.result {
                    Text(result.summary)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .padding(.top, 8)
                }
            }
            
            Button(action: {
                viewModel.runDiagnostics()
            }) {
                Text("Run Diagnostics")
                    .frame(maxWidth: .infinity)
            }
            .buttonStyle(.bordered)
            .disabled(viewModel.isRunningDiagnostics)
        }
        .padding()
        .frame(width: 300)
    }
}

struct DiagnosticItemView: View {
    let title: String
    let status: Bool
    
    var body: some View {
        HStack {
            Text(title)
                .font(.subheadline)
            
            Spacer()
            
            Image(systemName: status ? "checkmark.circle.fill" : "xmark.circle.fill")
                .foregroundColor(status ? .green : .red)
        }
    }
}

class ConnectionDiagnosticsViewModel: ObservableObject {
    @Published private(set) var isRunningDiagnostics = false
    @Published private(set) var result: ConnectionDiagnostics.DiagnosticResult?
    
    private let diagnostics: ConnectionDiagnostics
    
    init() {
        // Get socket manager from app delegate or dependency injection
        let appDelegate = NSApplication.shared.delegate as! AppDelegate
        self.diagnostics = ConnectionDiagnostics(socketManager: appDelegate.connectionManager.socketManager)
    }
    
    func runDiagnostics() {
        isRunningDiagnostics = true
        result = nil
        
        diagnostics.runDiagnostics { [weak self] result in
            DispatchQueue.main.async {
                self?.result = result
                self?.isRunningDiagnostics = false
            }
        }
    }
}
```

This implementation guide provides a comprehensive approach to backend connection management in the Mac client, covering connection persistence, status indicators, retry mechanisms, and connection diagnostics.

---

# tasks/impl_chat_box.md

# Chat Box Implementation Guide for Mac Client

This document outlines the implementation details for the chat box in the Mac client, which displays both agent outputs and user messages, including handling different message types, formatting, styling, and scrolling management.

## 1. Message Types and Handling

### 1.1 Message Model

```swift
enum MessageType {
    case user
    case agent
}

struct ChatMessage: Identifiable {
    let id: UUID
    let type: MessageType
    let content: MessageContent
    let timestamp: Date
    let metadata: [String: Any]?
    
    // Convenience initializer for user messages
    static func userMessage(_ text: String) -> ChatMessage {
        return ChatMessage(
            id: UUID(),
            type: .user,
            content: .userMessage(text),
            timestamp: Date(),
            metadata: nil
        )
    }
    
    // Convenience initializer for agent outputs
    static func agentOutput(_ outputType: AgentOutputType, metadata: [String: Any]? = nil) -> ChatMessage {
        return ChatMessage(
            id: UUID(),
            type: .agent,
            content: .agentOutput(outputType),
            timestamp: Date(),
            metadata: metadata
        )
    }
}

enum MessageContent {
    case userMessage(String)
    case agentOutput(AgentOutputType)
}
```

## 2. Agent Output Types and Handling

### 2.1 Output Type Definitions

```swift
enum AgentOutputType {
    case text(String)
    case markdown(String)
    case code(String, language: String?)
    case image(URL)
    case terminal(String)
    case error(String, details: String?)
    case fileTree([FileItem])
    case custom(data: [String: Any])
}

struct AgentOutput {
    let id: UUID
    let type: AgentOutputType
    let timestamp: Date
    let isComplete: Bool
    let metadata: [String: Any]?
}
```

### 2.2 Output Type Detection

```swift
class OutputParser {
    static func parseOutput(from event: OpenHandsEvent) -> AgentOutput {
        let id = UUID()
        let timestamp = event.timestamp
        let isComplete = event.isComplete ?? true
        
        // Extract message content
        guard let message = event.message else {
            return AgentOutput(
                id: id,
                type: .error("Invalid message format", details: nil),
                timestamp: timestamp,
                isComplete: isComplete,
                metadata: nil
            )
        }
        
        // Detect output type based on message content and metadata
        if let outputType = event.metadata?["output_type"] as? String {
            switch outputType {
            case "markdown":
                return AgentOutput(
                    id: id,
                    type: .markdown(message),
                    timestamp: timestamp,
                    isComplete: isComplete,
                    metadata: event.metadata
                )
                
            case "code":
                let language = event.metadata?["language"] as? String
                return AgentOutput(
                    id: id,
                    type: .code(message, language: language),
                    timestamp: timestamp,
                    isComplete: isComplete,
                    metadata: event.metadata
                )
                
            case "terminal":
                return AgentOutput(
                    id: id,
                    type: .terminal(message),
                    timestamp: timestamp,
                    isComplete: isComplete,
                    metadata: event.metadata
                )
                
            case "image":
                if let urlString = event.metadata?["url"] as? String,
                   let url = URL(string: urlString) {
                    return AgentOutput(
                        id: id,
                        type: .image(url),
                        timestamp: timestamp,
                        isComplete: isComplete,
                        metadata: event.metadata
                    )
                }
                
            case "file_tree":
                if let fileItems = parseFileTree(from: message) {
                    return AgentOutput(
                        id: id,
                        type: .fileTree(fileItems),
                        timestamp: timestamp,
                        isComplete: isComplete,
                        metadata: event.metadata
                    )
                }
                
            case "custom":
                if let data = event.metadata?["data"] as? [String: Any] {
                    return AgentOutput(
                        id: id,
                        type: .custom(data: data),
                        timestamp: timestamp,
                        isComplete: isComplete,
                        metadata: event.metadata
                    )
                }
                
            default:
                break
            }
        }
        
        // Default to markdown if no specific type is detected
        return AgentOutput(
            id: id,
            type: .markdown(message),
            timestamp: timestamp,
            isComplete: isComplete,
            metadata: event.metadata
        )
    }
    
    private static func parseFileTree(from message: String) -> [FileItem]? {
        // Parse file tree JSON structure
        guard let data = message.data(using: .utf8) else { return nil }
        
        do {
            return try JSONDecoder().decode([FileItem].self, from: data)
        } catch {
            print("Error parsing file tree: \(error)")
            return nil
        }
    }
}
```

## 3. Output Formatting and Styling

### 3.1 Text and Markdown Rendering

```swift
struct MarkdownOutputView: View {
    let content: String
    
    var body: some View {
        ScrollView {
            MarkdownUI.Markdown(content)
                .markdownTheme(.gitHub)
                .padding()
        }
    }
}
```

### 3.2 User Message View

```swift
struct UserMessageView: View {
    let message: String
    
    var body: some View {
        HStack {
            Spacer()
            
            Text(message)
                .padding()
                .background(Color.blue.opacity(0.1))
                .foregroundColor(.primary)
                .cornerRadius(12)
                .contextMenu {
                    Button(action: {
                        UIPasteboard.general.string = message
                    }) {
                        Label("Copy", systemImage: "doc.on.doc")
                    }
                }
        }
        .padding(.horizontal)
        .padding(.vertical, 4)
    }
}

### 3.4 Code Block Rendering

```swift
struct CodeBlockView: View {
    let code: String
    let language: String?
    
    @State private var isCopied = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header with language and copy button
            HStack {
                Text(language ?? "Code")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.leading, 8)
                
                Spacer()
                
                Button(action: {
                    UIPasteboard.general.string = code
                    isCopied = true
                    
                    // Reset copied state after delay
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                        isCopied = false
                    }
                }) {
                    Label(isCopied ? "Copied" : "Copy", systemImage: isCopied ? "checkmark" : "doc.on.doc")
                        .font(.caption)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Color.secondary.opacity(0.1))
                        .cornerRadius(4)
                }
                .buttonStyle(PlainButtonStyle())
                .padding(.trailing, 8)
            }
            .padding(.vertical, 6)
            .background(Color.secondary.opacity(0.05))
            
            // Code content with syntax highlighting
            CodeEditor(source: code, language: language ?? "swift", theme: .xcode)
                .frame(minHeight: 100)
                .padding(8)
        }
        .background(Color.secondary.opacity(0.05))
        .cornerRadius(8)
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(Color.secondary.opacity(0.2), lineWidth: 1)
        )
        .padding(.vertical, 8)
    }
}
```

### 3.3 Terminal Output Rendering

```swift
struct TerminalOutputView: View {
    let output: String
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading) {
                Text(output)
                    .font(.system(.body, design: .monospaced))
                    .foregroundColor(.white)
                    .padding()
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .background(Color.black)
        .cornerRadius(8)
    }
}
```

### 3.4 Image Rendering

```swift
struct AgentImageView: View {
    let imageURL: URL
    
    @State private var image: UIImage?
    @State private var isLoading = true
    @State private var error: Error?
    
    var body: some View {
        Group {
            if let image = image {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFit()
                    .cornerRadius(8)
            } else if isLoading {
                ProgressView()
                    .frame(height: 200)
            } else if error != nil {
                VStack {
                    Image(systemName: "exclamationmark.triangle")
                        .font(.largeTitle)
                        .foregroundColor(.red)
                    Text("Failed to load image")
                        .foregroundColor(.secondary)
                }
                .frame(height: 200)
            }
        }
        .onAppear {
            loadImage()
        }
    }
    
    private func loadImage() {
        isLoading = true
        
        URLSession.shared.dataTask(with: imageURL) { data, response, error in
            DispatchQueue.main.async {
                isLoading = false
                
                if let error = error {
                    self.error = error
                    return
                }
                
                guard let data = data, let loadedImage = UIImage(data: data) else {
                    self.error = NSError(domain: "ImageLoadingError", code: 0, userInfo: nil)
                    return
                }
                
                self.image = loadedImage
            }
        }.resume()
    }
}
```

### 3.5 User Message Rendering

```swift
struct UserMessageView: View {
    let message: String
    
    var body: some View {
        Text(message)
            .padding()
            .background(Color.blue.opacity(0.1))
            .cornerRadius(12)
            .frame(maxWidth: .infinity, alignment: .trailing)
    }
}
```

### 3.6 Output Container View

```swift
struct AgentOutputContainerView: View {
    let output: AgentOutput
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Timestamp header
            HStack {
                Text(output.timestamp, style: .time)
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                if !output.isComplete {
                    ProgressView()
                        .scaleEffect(0.5)
                }
                
                Spacer()
            }
            .padding(.horizontal, 8)
            
            // Output content based on type
            Group {
                switch output.type {
                case .text(let content):
                    Text(content)
                        .padding(8)
                
                case .markdown(let content):
                    MarkdownOutputView(content: content)
                
                case .code(let code, let language):
                    CodeBlockView(code: code, language: language)
                
                case .terminal(let output):
                    TerminalOutputView(output: output)
                
                case .image(let url):
                    AgentImageView(imageURL: url)
                
                case .error(let message, let details):
                    ErrorView(message: message, details: details)
                
                case .fileTree(let items):
                    FileTreeView(items: items)
                
                case .custom(let data):
                    CustomOutputView(data: data)
                }
            }
            .padding(.horizontal, 8)
        }
        .padding(.vertical, 8)
        .background(Color.white)
        .cornerRadius(12)
        .shadow(color: Color.black.opacity(0.05), radius: 5, x: 0, y: 2)
    }
}
```

## 4. Scrolling and History Management

### 4.1 Conversation History View

```swift
struct ConversationHistoryView: View {
    @ObservedObject var viewModel: ConversationViewModel
    
    // Scroll position tracking
    @State private var scrollProxy: ScrollViewProxy?
    @State private var lastMessageId: UUID?
    
    var body: some View {
        ScrollViewReader { proxy in
            ScrollView {
                LazyVStack(alignment: .leading, spacing: 16) {
                    ForEach(viewModel.messages) { message in
                        Group {
                            switch message.type {
                            case .user:
                                if case .userMessage(let content) = message.content {
                                    UserMessageView(message: content)
                                }
                            case .agent:
                                if case .agentOutput(let outputType) = message.content {
                                    AgentOutputContainerView(output: AgentOutput(
                                        id: message.id,
                                        type: outputType,
                                        timestamp: message.timestamp,
                                        isComplete: true,
                                        metadata: message.metadata
                                    ))
                                }
                            }
                        }
                        .id(message.id)
                    }
                    
                    // Spacer at the bottom to allow scrolling past the last item
                    Color.clear
                        .frame(height: 20)
                        .id("bottom")
                }
                .padding()
            }
            .onAppear {
                scrollProxy = proxy
                scrollToBottom(animated: false)
            }
            .onChange(of: viewModel.messages) { newMessages in
                // If a new message was added, scroll to it
                if let lastMessage = newMessages.last, lastMessage.id != lastMessageId {
                    lastMessageId = lastMessage.id
                    scrollToBottom()
                }
            }
        }
    }
    
    private func scrollToBottom(animated: Bool = true) {
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            withAnimation(animated ? .easeOut : nil) {
                scrollProxy?.scrollTo("bottom", anchor: .bottom)
            }
        }
    }
}
```

### 4.2 Lazy Loading for Large Conversations

```swift
class ConversationViewModel: ObservableObject {
    @Published private(set) var messages: [ChatMessage] = []
    @Published private(set) var isLoadingHistory = false
    
    private var conversationId: String
    private var socketManager: SocketManager
    private var historyManager: ConversationHistoryManager
    
    private var currentPage = 1
    private var hasMoreHistory = true
    
    init(conversationId: String) {
        self.conversationId = conversationId
        self.socketManager = SocketManager(conversationId: conversationId)
        self.historyManager = ConversationHistoryManager()
        
        // Load initial history
        loadInitialHistory()
        
        // Subscribe to new messages
        setupSocketSubscription()
    }
    
    func loadInitialHistory() {
        isLoadingHistory = true
        
        historyManager.fetchHistory(conversationId: conversationId, page: 1) { [weak self] result in
            guard let self = self else { return }
            
            DispatchQueue.main.async {
                self.isLoadingHistory = false
                
                switch result {
                case .success(let messages):
                    self.messages = messages
                    self.currentPage = 1
                    self.hasMoreHistory = messages.count >= 20 // Assuming page size of 20
                    
                case .failure(let error):
                    print("Failed to load history: \(error)")
                    // Handle error
                }
            }
        }
    }
    
    // Send a new user message
    func sendMessage(_ message: String) {
        // Create and add user message to the conversation
        let userMessage = ChatMessage.userMessage(message)
        messages.append(userMessage)
        
        // Send message to backend
        socketManager.emit("oh_action", [
            "type": "user_message",
            "content": message,
            "conversation_id": conversationId
        ])
    }
    
    func loadMoreHistory() {
        guard hasMoreHistory && !isLoadingHistory else { return }
        
        isLoadingHistory = true
        let nextPage = currentPage + 1
        
        historyManager.fetchHistory(conversationId: conversationId, page: nextPage) { [weak self] result in
            guard let self = self else { return }
            
            DispatchQueue.main.async {
                self.isLoadingHistory = false
                
                switch result {
                case .success(let messages):
                    if messages.isEmpty {
                        self.hasMoreHistory = false
                    } else {
                        self.messages.insert(contentsOf: messages, at: 0)
                        self.currentPage = nextPage
                        self.hasMoreHistory = messages.count >= 20
                    }
                    
                case .failure(let error):
                    print("Failed to load more history: \(error)")
                    // Handle error
                }
            }
        }
    }
    
    // Send a user message
    func sendUserMessage(_ text: String) {
        let userMessage = ChatMessage(
            id: UUID(),
            type: .user,
            content: .userMessage(text),
            timestamp: Date(),
            metadata: nil
        )
        
        // Add to local messages
        messages.append(userMessage)
        
        // Send to backend
        socketManager.sendUserMessage(text)
    }
    
    private func setupSocketSubscription() {
        socketManager.connect()
        
        // Subscribe to new agent outputs
        NotificationCenter.default.addObserver(
            forName: .newAgentOutput,
            object: nil,
            queue: .main
        ) { [weak self] notification in
            guard let self = self,
                  let event = notification.object as? OpenHandsEvent else {
                return
            }
            
            let output = OutputParser.parseOutput(from: event)
            
            // Create agent message
            let agentMessage = ChatMessage(
                id: UUID(),
                type: .agent,
                content: .agentOutput(output.type),
                timestamp: output.timestamp,
                metadata: output.metadata
            )
            
            // Update existing message if it's a continuation or add new message
            if let existingIndex = self.findIncompleteAgentMessageIndex() {
                self.messages[existingIndex] = agentMessage
            } else {
                self.messages.append(agentMessage)
            }
        }
    }
    
    // Find the index of the last incomplete agent message
    private func findIncompleteAgentMessageIndex() -> Int? {
        for (index, message) in messages.enumerated().reversed() {
            if message.type == .agent, 
               case .agentOutput(let outputType) = message.content,
               let metadata = message.metadata,
               let isComplete = metadata["isComplete"] as? Bool,
               !isComplete {
                return index
            }
        }
        return nil
    }
}
```

### 4.4 Pull to Refresh for History

```swift
struct ConversationView: View {
    @StateObject var viewModel: ConversationViewModel
    
    var body: some View {
        VStack {
            // History view with pull-to-refresh
            RefreshableScrollView(
                onRefresh: { done in
                    viewModel.loadMoreHistory()
                    // Simulate network delay
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                        done()
                    }
                }
            ) {
                ConversationHistoryView(viewModel: viewModel)
            }
            
            // Input field at the bottom
            MessageInputView(onSend: { message in
                viewModel.sendMessage(message)
            })
        }
    }
}

// Custom refreshable scroll view implementation
struct RefreshableScrollView<Content: View>: View {
    @State private var isRefreshing = false
    let onRefresh: (@escaping () -> Void) -> Void
    let content: Content
    
    init(onRefresh: @escaping (@escaping () -> Void) -> Void, @ViewBuilder content: () -> Content) {
        self.onRefresh = onRefresh
        self.content = content()
    }
    
    var body: some View {
        ScrollView {
            ZStack(alignment: .top) {
                // Pull to refresh indicator
                if isRefreshing {
                    ProgressView()
                        .scaleEffect(1.5)
                        .padding(.top, 20)
                }
                
                // Main content
                VStack {
                    content
                }
                .offset(y: isRefreshing ? 50 : 0)
            }
            .gesture(
                DragGesture()
                    .onEnded { value in
                        if value.translation.height > 50 && !isRefreshing {
                            isRefreshing = true
                            onRefresh {
                                isRefreshing = false
                            }
                        }
                    }
            )
        }
    }
}
```

## 4. Handling Streaming Outputs

### 4.1 Streaming Text Updates

```swift
class StreamingOutputManager {
    private var incompleteOutputs: [String: String] = [:]
    
    func handleStreamingUpdate(event: OpenHandsEvent) -> AgentOutput {
        guard let id = event.id else {
            return OutputParser.parseOutput(from: event)
        }
        
        // Check if this is a continuation of an existing output
        if var existingContent = incompleteOutputs[id] {
            // Append new content
            if let newContent = event.message {
                existingContent += newContent
                incompleteOutputs[id] = existingContent
            }
            
            // Create a modified event with the complete content so far
            var updatedEvent = event
            updatedEvent.message = existingContent
            
            // If this is the final chunk, remove from incomplete outputs
            if event.isComplete == true {
                incompleteOutputs.removeValue(forKey: id)
            }
            
            return OutputParser.parseOutput(from: updatedEvent)
        } else {
            // This is a new streaming output
            if event.isComplete == false, let content = event.message {
                incompleteOutputs[id] = content
            }
            
            return OutputParser.parseOutput(from: event)
        }
    }
}
```

### 4.2 Message Input View

```swift
struct MessageInputView: View {
    @State private var messageText = ""
    let onSend: (String) -> Void
    
    var body: some View {
        HStack {
            // Text input field
            TextField("Type a message...", text: $messageText)
                .padding(10)
                .background(Color(.systemGray6))
                .cornerRadius(20)
                .submitLabel(.send)
                .onSubmit {
                    sendMessage()
                }
            
            // Send button
            Button(action: sendMessage) {
                Image(systemName: "arrow.up.circle.fill")
                    .font(.system(size: 30))
                    .foregroundColor(.blue)
            }
            .disabled(messageText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
        }
        .padding(.horizontal)
        .padding(.vertical, 8)
        .background(Color(.systemBackground))
        .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: -5)
    }
    
    private func sendMessage() {
        let trimmedMessage = messageText.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedMessage.isEmpty else { return }
        
        onSend(trimmedMessage)
        messageText = ""
    }
}

### 4.3 Animated Typing Effect

```swift
struct TypingTextView: View {
    let text: String
    let isComplete: Bool
    
    @State private var displayedText: String = ""
    @State private var lastUpdatedText: String = ""
    
    var body: some View {
        Text(displayedText)
            .onChange(of: text) { newText in
                updateDisplayedText(newText)
            }
            .onAppear {
                updateDisplayedText(text)
            }
    }
    
    private func updateDisplayedText(_ newText: String) {
        // If this is a completely new message, reset the displayed text
        if !newText.hasPrefix(lastUpdatedText) {
            displayedText = ""
            lastUpdatedText = ""
        }
        
        // Calculate the new portion to animate
        let newPortion = String(newText.dropFirst(lastUpdatedText.count))
        lastUpdatedText = newText
        
        // Animate the new portion character by character
        var currentIndex = 0
        let characters = Array(newPortion)
        
        // Cancel any existing timers
        Timer.scheduledTimer(withTimeInterval: 0.01, repeats: true) { timer in
            if currentIndex < characters.count {
                displayedText += String(characters[currentIndex])
                currentIndex += 1
            } else {
                timer.invalidate()
            }
        }
    }
}
```

## 5. Accessibility Considerations

### 5.1 VoiceOver Support

```swift
extension AgentOutputContainerView {
    var accessibilityLabel: String {
        switch output.type {
        case .text(let content), .markdown(let content):
            return "Agent message: \(content)"
            
        case .code(let code, let language):
            return "Code block in \(language ?? "unknown language"): \(code)"
            
        case .terminal(let output):
            return "Terminal output: \(output)"
            
        case .image:
            return "Image from agent"
            
        case .error(let message, _):
            return "Error: \(message)"
            
        case .fileTree:
            return "File tree display"
            
        case .custom:
            return "Custom agent output"
        }
    }
    
    var accessibilityHint: String {
        switch output.type {
        case .code:
            return "Double tap to copy code to clipboard"
            
        case .image:
            return "Double tap to view image in full screen"
            
        default:
            return ""
        }
    }
}
```

### 5.2 Dynamic Type Support

```swift
struct MarkdownOutputView: View {
    let content: String
    
    @Environment(\.sizeCategory) var sizeCategory
    
    var body: some View {
        ScrollView {
            MarkdownUI.Markdown(content)
                .markdownTheme(.gitHub)
                .environment(\.sizeCategory, sizeCategory)
                .padding()
        }
    }
}
```

This implementation guide provides a comprehensive approach to displaying agent outputs in the Mac client, covering different output types, formatting, styling, and scrolling management with accessibility considerations.

---

# tasks/impl_error_handling.md

# Error States and Recovery for Mac Client

This document outlines the implementation details for handling error states and recovery procedures in the Mac client, including error definitions, user feedback mechanisms, and recovery strategies.

## 1. Error State Definitions

### 1.1 Error Type Hierarchy

```swift
// Base error protocol for app-wide error handling
protocol AppError: Error {
    var title: String { get }
    var message: String { get }
    var code: Int { get }
    var recoveryOptions: [ErrorRecoveryOption] { get }
    var severity: ErrorSeverity { get }
    var isUserVisible: Bool { get }
}

// Error severity levels
enum ErrorSeverity {
    case info      // Informational, doesn't affect functionality
    case warning   // Potential issue, limited functionality impact
    case error     // Significant issue, major functionality affected
    case critical  // Fatal error, application cannot function
}

// Recovery options for errors
struct ErrorRecoveryOption {
    let title: String
    let action: () -> Void
    let isDestructive: Bool
}

// Network-related errors
struct NetworkError: AppError {
    let title: String
    let message: String
    let code: Int
    let recoveryOptions: [ErrorRecoveryOption]
    let severity: ErrorSeverity
    let isUserVisible: Bool
    let underlyingError: Error?
    
    // Common network errors
    static func connectionFailed(error: Error? = nil) -> NetworkError {
        NetworkError(
            title: "Connection Failed",
            message: "Unable to connect to the server. Please check your internet connection and try again.",
            code: 1001,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Retry Connection",
                    action: { NotificationCenter.default.post(name: .retryConnection, object: nil) },
                    isDestructive: false
                ),
                ErrorRecoveryOption(
                    title: "Work Offline",
                    action: { NotificationCenter.default.post(name: .enableOfflineMode, object: nil) },
                    isDestructive: false
                )
            ],
            severity: .error,
            isUserVisible: true,
            underlyingError: error
        )
    }
    
    static func requestTimeout() -> NetworkError {
        NetworkError(
            title: "Request Timeout",
            message: "The server took too long to respond. Please try again later.",
            code: 1002,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Retry",
                    action: { NotificationCenter.default.post(name: .retryLastRequest, object: nil) },
                    isDestructive: false
                )
            ],
            severity: .warning,
            isUserVisible: true,
            underlyingError: nil
        )
    }
    
    static func serverError(statusCode: Int, message: String? = nil) -> NetworkError {
        NetworkError(
            title: "Server Error",
            message: message ?? "The server encountered an error (Status \(statusCode)). Please try again later.",
            code: 1003,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Retry",
                    action: { NotificationCenter.default.post(name: .retryLastRequest, object: nil) },
                    isDestructive: false
                )
            ],
            severity: .error,
            isUserVisible: true,
            underlyingError: nil
        )
    }
}

// File system errors
struct FileSystemError: AppError {
    let title: String
    let message: String
    let code: Int
    let recoveryOptions: [ErrorRecoveryOption]
    let severity: ErrorSeverity
    let isUserVisible: Bool
    let filePath: String?
    
    static func accessDenied(path: String) -> FileSystemError {
        FileSystemError(
            title: "Access Denied",
            message: "You don't have permission to access this file or directory: \(path)",
            code: 2001,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Request Permission",
                    action: { NotificationCenter.default.post(name: .requestFilePermission, object: path) },
                    isDestructive: false
                )
            ],
            severity: .error,
            isUserVisible: true,
            filePath: path
        )
    }
    
    static func fileNotFound(path: String) -> FileSystemError {
        FileSystemError(
            title: "File Not Found",
            message: "The file or directory could not be found: \(path)",
            code: 2002,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Refresh",
                    action: { NotificationCenter.default.post(name: .refreshFileExplorer, object: nil) },
                    isDestructive: false
                )
            ],
            severity: .warning,
            isUserVisible: true,
            filePath: path
        )
    }
    
    static func fileSaveError(path: String, error: Error? = nil) -> FileSystemError {
        FileSystemError(
            title: "Save Failed",
            message: "Failed to save file: \(path)",
            code: 2003,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Retry Save",
                    action: { NotificationCenter.default.post(name: .retrySaveFile, object: path) },
                    isDestructive: false
                ),
                ErrorRecoveryOption(
                    title: "Save As...",
                    action: { NotificationCenter.default.post(name: .showSaveAsDialog, object: path) },
                    isDestructive: false
                )
            ],
            severity: .error,
            isUserVisible: true,
            filePath: path
        )
    }
}

// State management errors
struct StateError: AppError {
    let title: String
    let message: String
    let code: Int
    let recoveryOptions: [ErrorRecoveryOption]
    let severity: ErrorSeverity
    let isUserVisible: Bool
    
    static func syncFailed() -> StateError {
        StateError(
            title: "Sync Failed",
            message: "Failed to synchronize with the server. Some changes may not be saved.",
            code: 3001,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Retry Sync",
                    action: { NotificationCenter.default.post(name: .retryStateSync, object: nil) },
                    isDestructive: false
                ),
                ErrorRecoveryOption(
                    title: "Work Offline",
                    action: { NotificationCenter.default.post(name: .enableOfflineMode, object: nil) },
                    isDestructive: false
                )
            ],
            severity: .warning,
            isUserVisible: true
        )
    }
    
    static func stateCorrupted() -> StateError {
        StateError(
            title: "State Corrupted",
            message: "The application state is corrupted. The application needs to be reset.",
            code: 3002,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Reset Application",
                    action: { NotificationCenter.default.post(name: .resetApplicationState, object: nil) },
                    isDestructive: true
                )
            ],
            severity: .critical,
            isUserVisible: true
        )
    }
    
    static func conflictDetected() -> StateError {
        StateError(
            title: "Sync Conflict",
            message: "There is a conflict between your local changes and the server. Please choose how to resolve it.",
            code: 3003,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Use Server Version",
                    action: { NotificationCenter.default.post(name: .resolveConflictWithServer, object: nil) },
                    isDestructive: false
                ),
                ErrorRecoveryOption(
                    title: "Keep My Changes",
                    action: { NotificationCenter.default.post(name: .resolveConflictWithLocal, object: nil) },
                    isDestructive: false
                ),
                ErrorRecoveryOption(
                    title: "Merge Changes",
                    action: { NotificationCenter.default.post(name: .resolveConflictWithMerge, object: nil) },
                    isDestructive: false
                )
            ],
            severity: .warning,
            isUserVisible: true
        )
    }
}

// Authentication errors
struct AuthError: AppError {
    let title: String
    let message: String
    let code: Int
    let recoveryOptions: [ErrorRecoveryOption]
    let severity: ErrorSeverity
    let isUserVisible: Bool
    
    static func unauthorized() -> AuthError {
        AuthError(
            title: "Authentication Required",
            message: "Your session has expired. Please sign in again.",
            code: 4001,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Sign In",
                    action: { NotificationCenter.default.post(name: .showSignInPrompt, object: nil) },
                    isDestructive: false
                )
            ],
            severity: .error,
            isUserVisible: true
        )
    }
    
    static func tokenExpired() -> AuthError {
        AuthError(
            title: "Session Expired",
            message: "Your session has expired. Please sign in again to continue.",
            code: 4002,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Sign In",
                    action: { NotificationCenter.default.post(name: .showSignInPrompt, object: nil) },
                    isDestructive: false
                )
            ],
            severity: .warning,
            isUserVisible: true
        )
    }
}

// Application errors
struct ApplicationError: AppError {
    let title: String
    let message: String
    let code: Int
    let recoveryOptions: [ErrorRecoveryOption]
    let severity: ErrorSeverity
    let isUserVisible: Bool
    
    static func unexpectedError(error: Error? = nil) -> ApplicationError {
        ApplicationError(
            title: "Unexpected Error",
            message: "An unexpected error occurred. Please try again or restart the application.",
            code: 5001,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Restart Application",
                    action: { NotificationCenter.default.post(name: .restartApplication, object: nil) },
                    isDestructive: false
                )
            ],
            severity: .error,
            isUserVisible: true
        )
    }
    
    static func outOfMemory() -> ApplicationError {
        ApplicationError(
            title: "Out of Memory",
            message: "The application is running low on memory. Please save your work and restart the application.",
            code: 5002,
            recoveryOptions: [
                ErrorRecoveryOption(
                    title: "Save and Restart",
                    action: { NotificationCenter.default.post(name: .saveAndRestart, object: nil) },
                    isDestructive: false
                )
            ],
            severity: .critical,
            isUserVisible: true
        )
    }
}
```

### 1.2 Error Manager

```swift
class ErrorManager {
    static let shared = ErrorManager()
    
    private init() {}
    
    // Current active errors
    private var activeErrors: [UUID: AppError] = [:]
    
    // Error handlers by type
    private var errorHandlers: [String: (AppError) -> Void] = [:]
    
    // Report an error
    @discardableResult
    func reportError(_ error: AppError) -> UUID {
        let errorId = UUID()
        activeErrors[errorId] = error
        
        // Log the error
        logError(error)
        
        // Handle based on error type
        let errorType = String(describing: type(of: error))
        if let handler = errorHandlers[errorType] {
            handler(error)
        }
        
        // Show user-visible errors
        if error.isUserVisible {
            showErrorToUser(error, id: errorId)
        }
        
        return errorId
    }
    
    // Resolve an error
    func resolveError(id: UUID) {
        activeErrors.removeValue(forKey: id)
        
        // Dismiss error UI if needed
        NotificationCenter.default.post(name: .dismissError, object: id)
    }
    
    // Register error handler
    func registerHandler(for errorType: AppError.Type, handler: @escaping (AppError) -> Void) {
        let typeName = String(describing: errorType)
        errorHandlers[typeName] = handler
    }
    
    // Log error
    private func logError(_ error: AppError) {
        // Log to system log
        os_log(
            "Error [%{public}d]: %{public}@ - %{public}@",
            log: OSLog(subsystem: "com.openhands.mac", category: "Errors"),
            type: osLogType(for: error.severity),
            error.code,
            error.title,
            error.message
        )
        
        // Additional logging for critical errors
        if error.severity == .critical {
            // Could send to crash reporting service
        }
    }
    
    // Map severity to OSLogType
    private func osLogType(for severity: ErrorSeverity) -> OSLogType {
        switch severity {
        case .info:
            return .info
        case .warning:
            return .debug
        case .error:
            return .error
        case .critical:
            return .fault
        }
    }
    
    // Show error to user
    private func showErrorToUser(_ error: AppError, id: UUID) {
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: .showError,
                object: ErrorDisplay(error: error, id: id)
            )
        }
    }
    
    // Get all active errors
    func getActiveErrors() -> [UUID: AppError] {
        return activeErrors
    }
}

// Error display model for UI
struct ErrorDisplay {
    let error: AppError
    let id: UUID
}

// Notification names
extension Notification.Name {
    static let showError = Notification.Name("com.openhands.mac.showError")
    static let dismissError = Notification.Name("com.openhands.mac.dismissError")
    static let retryConnection = Notification.Name("com.openhands.mac.retryConnection")
    static let enableOfflineMode = Notification.Name("com.openhands.mac.enableOfflineMode")
    static let retryLastRequest = Notification.Name("com.openhands.mac.retryLastRequest")
    static let requestFilePermission = Notification.Name("com.openhands.mac.requestFilePermission")
    static let refreshFileExplorer = Notification.Name("com.openhands.mac.refreshFileExplorer")
    static let retrySaveFile = Notification.Name("com.openhands.mac.retrySaveFile")
    static let showSaveAsDialog = Notification.Name("com.openhands.mac.showSaveAsDialog")
    static let retryStateSync = Notification.Name("com.openhands.mac.retryStateSync")
    static let resetApplicationState = Notification.Name("com.openhands.mac.resetApplicationState")
    static let resolveConflictWithServer = Notification.Name("com.openhands.mac.resolveConflictWithServer")
    static let resolveConflictWithLocal = Notification.Name("com.openhands.mac.resolveConflictWithLocal")
    static let resolveConflictWithMerge = Notification.Name("com.openhands.mac.resolveConflictWithMerge")
    static let showSignInPrompt = Notification.Name("com.openhands.mac.showSignInPrompt")
    static let restartApplication = Notification.Name("com.openhands.mac.restartApplication")
    static let saveAndRestart = Notification.Name("com.openhands.mac.saveAndRestart")
}
```

## 2. User Feedback Mechanisms

### 2.1 Error Alert View

```swift
struct ErrorAlertView: View {
    let errorDisplay: ErrorDisplay
    let onDismiss: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Header
            HStack {
                Image(systemName: severityIcon)
                    .foregroundColor(severityColor)
                    .font(.title)
                
                Text(errorDisplay.error.title)
                    .font(.headline)
                
                Spacer()
                
                Button(action: onDismiss) {
                    Image(systemName: "xmark")
                        .font(.body)
                        .foregroundColor(.secondary)
                }
                .buttonStyle(PlainButtonStyle())
            }
            
            // Message
            Text(errorDisplay.error.message)
                .font(.body)
                .foregroundColor(.secondary)
            
            // Recovery options
            if !errorDisplay.error.recoveryOptions.isEmpty {
                HStack {
                    ForEach(errorDisplay.error.recoveryOptions, id: \.title) { option in
                        Button(action: {
                            option.action()
                            onDismiss()
                        }) {
                            Text(option.title)
                                .foregroundColor(option.isDestructive ? .red : .accentColor)
                        }
                        .buttonStyle(.bordered)
                        
                        if option != errorDisplay.error.recoveryOptions.last {
                            Spacer()
                        }
                    }
                }
            }
        }
        .padding()
        .background(Color(NSColor.windowBackgroundColor))
        .cornerRadius(12)
        .shadow(color: Color.black.opacity(0.2), radius: 10, x: 0, y: 5)
    }
    
    private var severityIcon: String {
        switch errorDisplay.error.severity {
        case .info:
            return "info.circle"
        case .warning:
            return "exclamationmark.triangle"
        case .error, .critical:
            return "exclamationmark.circle"
        }
    }
    
    private var severityColor: Color {
        switch errorDisplay.error.severity {
        case .info:
            return .blue
        case .warning:
            return .yellow
        case .error:
            return .orange
        case .critical:
            return .red
        }
    }
}
```

### 2.2 Error Toast View

```swift
struct ErrorToastView: View {
    let errorDisplay: ErrorDisplay
    let onDismiss: () -> Void
    
    @State private var isShowing = false
    
    var body: some View {
        HStack(spacing: 12) {
            // Icon
            Image(systemName: severityIcon)
                .foregroundColor(severityColor)
                .font(.title3)
            
            // Content
            VStack(alignment: .leading, spacing: 4) {
                Text(errorDisplay.error.title)
                    .font(.headline)
                
                Text(errorDisplay.error.message)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(2)
            }
            
            Spacer()
            
            // Dismiss button
            Button(action: onDismiss) {
                Image(systemName: "xmark")
                    .font(.body)
                    .foregroundColor(.secondary)
            }
            .buttonStyle(PlainButtonStyle())
        }
        .padding()
        .background(Color(NSColor.windowBackgroundColor))
        .cornerRadius(8)
        .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
        .opacity(isShowing ? 1 : 0)
        .offset(y: isShowing ? 0 : -20)
        .onAppear {
            withAnimation(.spring()) {
                isShowing = true
            }
            
            // Auto-dismiss non-critical errors after a delay
            if errorDisplay.error.severity != .critical {
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    withAnimation(.spring()) {
                        isShowing = false
                    }
                    
                    // Dismiss after animation completes
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                        onDismiss()
                    }
                }
            }
        }
    }
    
    private var severityIcon: String {
        switch errorDisplay.error.severity {
        case .info:
            return "info.circle"
        case .warning:
            return "exclamationmark.triangle"
        case .error, .critical:
            return "exclamationmark.circle"
        }
    }
    
    private var severityColor: Color {
        switch errorDisplay.error.severity {
        case .info:
            return .blue
        case .warning:
            return .yellow
        case .error:
            return .orange
        case .critical:
            return .red
        }
    }
}
```

### 2.3 Error Manager View

```swift
struct ErrorManagerView: View {
    @StateObject private var viewModel = ErrorManagerViewModel()
    
    var body: some View {
        ZStack {
            // Main content
            Color.clear
            
            // Error toasts
            VStack {
                ForEach(viewModel.toastErrors, id: \.id) { errorDisplay in
                    ErrorToastView(errorDisplay: errorDisplay) {
                        viewModel.dismissError(id: errorDisplay.id)
                    }
                    .transition(.move(edge: .top).combined(with: .opacity))
                    .zIndex(1)
                }
                
                Spacer()
            }
            .padding(.top, 20)
            .padding(.horizontal)
            
            // Modal error alerts
            if let modalError = viewModel.modalError {
                Color.black.opacity(0.3)
                    .edgesIgnoringSafeArea(.all)
                    .onTapGesture {
                        // Don't dismiss critical errors on outside tap
                        if modalError.error.severity != .critical {
                            viewModel.dismissModalError()
                        }
                    }
                
                ErrorAlertView(errorDisplay: modalError) {
                    viewModel.dismissModalError()
                }
                .frame(width: 400)
                .transition(.scale.combined(with: .opacity))
                .zIndex(2)
            }
        }
        .animation(.spring(), value: viewModel.toastErrors.count)
        .animation(.spring(), value: viewModel.modalError != nil)
    }
}

class ErrorManagerViewModel: ObservableObject {
    @Published private(set) var toastErrors: [ErrorDisplay] = []
    @Published private(set) var modalError: ErrorDisplay?
    
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        // Subscribe to error notifications
        NotificationCenter.default.publisher(for: .showError)
            .compactMap { $0.object as? ErrorDisplay }
            .receive(on: RunLoop.main)
            .sink { [weak self] errorDisplay in
                self?.handleNewError(errorDisplay)
            }
            .store(in: &cancellables)
        
        // Subscribe to dismiss notifications
        NotificationCenter.default.publisher(for: .dismissError)
            .compactMap { $0.object as? UUID }
            .receive(on: RunLoop.main)
            .sink { [weak self] errorId in
                self?.dismissError(id: errorId)
            }
            .store(in: &cancellables)
    }
    
    private func handleNewError(_ errorDisplay: ErrorDisplay) {
        // Critical and error severity errors show as modal alerts
        if errorDisplay.error.severity == .critical || errorDisplay.error.severity == .error {
            modalError = errorDisplay
        } else {
            // Info and warning severity errors show as toasts
            toastErrors.append(errorDisplay)
            
            // Limit number of toast errors
            if toastErrors.count > 3 {
                toastErrors.removeFirst()
            }
        }
    }
    
    func dismissError(id: UUID) {
        // Remove from toast errors
        toastErrors.removeAll { $0.id == id }
        
        // Clear modal error if it matches
        if modalError?.id == id {
            modalError = nil
        }
        
        // Resolve in error manager
        ErrorManager.shared.resolveError(id: id)
    }
    
    func dismissModalError() {
        if let id = modalError?.id {
            dismissError(id: id)
        }
    }
}
```

### 2.4 Status Bar Error Indicator

```swift
struct StatusBarErrorIndicator: View {
    @ObservedObject private var viewModel = StatusBarErrorViewModel()
    
    var body: some View {
        HStack(spacing: 4) {
            if viewModel.hasActiveErrors {
                Image(systemName: "exclamationmark.triangle.fill")
                    .foregroundColor(viewModel.severityColor)
                    .font(.caption)
                
                Text("\(viewModel.errorCount)")
                    .font(.caption)
                    .foregroundColor(viewModel.severityColor)
            }
        }
        .padding(.horizontal, 6)
        .padding(.vertical, 2)
        .background(viewModel.hasActiveErrors ? viewModel.severityColor.opacity(0.1) : Color.clear)
        .cornerRadius(4)
        .onTapGesture {
            viewModel.showErrorList()
        }
    }
}

class StatusBarErrorViewModel: ObservableObject {
    @Published private(set) var hasActiveErrors = false
    @Published private(set) var errorCount = 0
    @Published private(set) var highestSeverity: ErrorSeverity = .info
    
    private var timer: Timer?
    
    init() {
        // Start periodic check for errors
        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.updateErrorStatus()
        }
    }
    
    deinit {
        timer?.invalidate()
    }
    
    private func updateErrorStatus() {
        let activeErrors = ErrorManager.shared.getActiveErrors()
        
        DispatchQueue.main.async {
            self.errorCount = activeErrors.count
            self.hasActiveErrors = self.errorCount > 0
            
            // Determine highest severity
            if self.hasActiveErrors {
                self.highestSeverity = activeErrors.values.map { $0.severity }.max(by: { a, b in
                    self.severityRank(a) < self.severityRank(b)
                }) ?? .info
            }
        }
    }
    
    private func severityRank(_ severity: ErrorSeverity) -> Int {
        switch severity {
        case .info: return 0
        case .warning: return 1
        case .error: return 2
        case .critical: return 3
        }
    }
    
    var severityColor: Color {
        switch highestSeverity {
        case .info: return .blue
        case .warning: return .yellow
        case .error: return .orange
        case .critical: return .red
        }
    }
    
    func showErrorList() {
        NotificationCenter.default.post(name: .showErrorList, object: nil)
    }
}

extension Notification.Name {
    static let showErrorList = Notification.Name("com.openhands.mac.showErrorList")
}
```

### 2.5 Error List View

```swift
struct ErrorListView: View {
    @ObservedObject private var viewModel = ErrorListViewModel()
    @Environment(\.presentationMode) var presentationMode
    
    var body: some View {
        VStack {
            // Header
            HStack {
                Text("Error Log")
                    .font(.headline)
                
                Spacer()
                
                Button(action: {
                    presentationMode.wrappedValue.dismiss()
                }) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.secondary)
                }
                .buttonStyle(PlainButtonStyle())
            }
            .padding()
            
            // Error list
            if viewModel.errors.isEmpty {
                VStack {
                    Spacer()
                    
                    Image(systemName: "checkmark.circle")
                        .font(.largeTitle)
                        .foregroundColor(.green)
                    
                    Text("No Active Errors")
                        .font(.headline)
                        .padding(.top)
                    
                    Spacer()
                }
            } else {
                List {
                    ForEach(viewModel.errors, id: \.id) { errorItem in
                        ErrorListItemView(errorItem: errorItem) {
                            viewModel.dismissError(id: errorItem.id)
                        }
                    }
                }
            }
            
            // Footer
            HStack {
                Button(action: {
                    viewModel.clearAllErrors()
                }) {
                    Text("Clear All")
                }
                .disabled(viewModel.errors.isEmpty)
                
                Spacer()
                
                Button(action: {
                    viewModel.exportErrorLog()
                }) {
                    Text("Export Log")
                }
                .disabled(viewModel.errors.isEmpty)
            }
            .padding()
        }
        .frame(width: 500, height: 400)
    }
}

struct ErrorListItemView: View {
    let errorItem: ErrorListItem
    let onDismiss: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: severityIcon)
                    .foregroundColor(severityColor)
                
                Text(errorItem.error.title)
                    .font(.headline)
                
                Spacer()
                
                Text(errorItem.timestamp, style: .time)
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Button(action: onDismiss) {
                    Image(systemName: "xmark")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .buttonStyle(PlainButtonStyle())
            }
            
            Text(errorItem.error.message)
                .font(.body)
                .foregroundColor(.secondary)
            
            if !errorItem.error.recoveryOptions.isEmpty {
                HStack {
                    ForEach(errorItem.error.recoveryOptions, id: \.title) { option in
                        Button(action: {
                            option.action()
                            onDismiss()
                        }) {
                            Text(option.title)
                                .font(.caption)
                        }
                        .buttonStyle(.bordered)
                        
                        if option != errorItem.error.recoveryOptions.last {
                            Spacer()
                        }
                    }
                }
                .padding(.top, 4)
            }
        }
        .padding(.vertical, 8)
    }
    
    private var severityIcon: String {
        switch errorItem.error.severity {
        case .info:
            return "info.circle"
        case .warning:
            return "exclamationmark.triangle"
        case .error:
            return "exclamationmark.circle"
        case .critical:
            return "exclamationmark.octagon"
        }
    }
    
    private var severityColor: Color {
        switch errorItem.error.severity {
        case .info:
            return .blue
        case .warning:
            return .yellow
        case .error:
            return .orange
        case .critical:
            return .red
        }
    }
}

struct ErrorListItem {
    let id: UUID
    let error: AppError
    let timestamp: Date
}

class ErrorListViewModel: ObservableObject {
    @Published private(set) var errors: [ErrorListItem] = []
    
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        // Load initial errors
        loadActiveErrors()
        
        // Subscribe to error notifications
        NotificationCenter.default.publisher(for: .showError)
            .compactMap { $0.object as? ErrorDisplay }
            .receive(on: RunLoop.main)
            .sink { [weak self] errorDisplay in
                self?.addError(errorDisplay)
            }
            .store(in: &cancellables)
        
        // Subscribe to dismiss notifications
        NotificationCenter.default.publisher(for: .dismissError)
            .compactMap { $0.object as? UUID }
            .receive(on: RunLoop.main)
            .sink { [weak self] errorId in
                self?.dismissError(id: errorId)
            }
            .store(in: &cancellables)
    }
    
    private func loadActiveErrors() {
        let activeErrors = ErrorManager.shared.getActiveErrors()
        
        errors = activeErrors.map { (id, error) in
            ErrorListItem(id: id, error: error, timestamp: Date())
        }
    }
    
    private func addError(_ errorDisplay: ErrorDisplay) {
        let errorItem = ErrorListItem(
            id: errorDisplay.id,
            error: errorDisplay.error,
            timestamp: Date()
        )
        
        errors.append(errorItem)
        
        // Sort by severity and timestamp
        errors.sort { first, second in
            if first.error.severity != second.error.severity {
                return severityRank(first.error.severity) > severityRank(second.error.severity)
            }
            return first.timestamp > second.timestamp
        }
    }
    
    func dismissError(id: UUID) {
        errors.removeAll { $0.id == id }
        ErrorManager.shared.resolveError(id: id)
    }
    
    func clearAllErrors() {
        let errorIds = errors.map { $0.id }
        for id in errorIds {
            ErrorManager.shared.resolveError(id: id)
        }
        errors.removeAll()
    }
    
    func exportErrorLog() {
        // Create error log content
        var logContent = "OpenHands Mac Client Error Log\n"
        logContent += "Generated: \(Date())\n\n"
        
        for errorItem in errors {
            logContent += "[\(errorItem.timestamp)] [\(errorItem.error.severity)] \(errorItem.error.title)\n"
            logContent += "Message: \(errorItem.error.message)\n"
            logContent += "Code: \(errorItem.error.code)\n"
            logContent += "Recovery Options: \(errorItem.error.recoveryOptions.map { $0.title }.joined(separator: ", "))\n"
            logContent += "\n"
        }
        
        // Show save panel
        let savePanel = NSSavePanel()
        savePanel.allowedContentTypes = [.plainText]
        savePanel.nameFieldStringValue = "OpenHandsErrorLog_\(Date().timeIntervalSince1970).txt"
        
        savePanel.begin { result in
            if result == .OK, let url = savePanel.url {
                do {
                    try logContent.write(to: url, atomically: true, encoding: .utf8)
                } catch {
                    // Ironically, report an error about failing to save the error log
                    ErrorManager.shared.reportError(
                        FileSystemError.fileSaveError(path: url.path, error: error)
                    )
                }
            }
        }
    }
    
    private func severityRank(_ severity: ErrorSeverity) -> Int {
        switch severity {
        case .info: return 0
        case .warning: return 1
        case .error: return 2
        case .critical: return 3
        }
    }
}
```

## 3. Recovery Procedures

### 3.1 Network Recovery

```swift
class NetworkRecoveryManager {
    private let socketManager: SocketManager
    private let retryManager: RetryManager
    
    init(socketManager: SocketManager) {
        self.socketManager = socketManager
        self.retryManager = RetryManager()
        
        setupNotificationHandlers()
    }
    
    private func setupNotificationHandlers() {
        // Handle retry connection requests
        NotificationCenter.default.addObserver(
            forName: .retryConnection,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.retryConnection()
        }
        
        // Handle retry last request
        NotificationCenter.default.addObserver(
            forName: .retryLastRequest,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.retryLastRequest()
        }
        
        // Handle enable offline mode
        NotificationCenter.default.addObserver(
            forName: .enableOfflineMode,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.enableOfflineMode()
        }
    }
    
    // Retry connection with exponential backoff
    func retryConnection() {
        retryManager.startRetrying { [weak self] in
            self?.socketManager.connect()
        }
    }
    
    // Retry last request
    func retryLastRequest() {
        socketManager.retryLastRequest()
    }
    
    // Enable offline mode
    func enableOfflineMode() {
        NotificationCenter.default.post(name: .offlineModeEnabled, object: nil)
    }
    
    // Run network diagnostics
    func runDiagnostics(completion: @escaping (NetworkDiagnosticResult) -> Void) {
        let diagnostics = NetworkDiagnostics(socketManager: socketManager)
        diagnostics.runDiagnostics(completion: completion)
    }
}

// Network diagnostics
class NetworkDiagnostics {
    private let socketManager: SocketManager
    
    init(socketManager: SocketManager) {
        self.socketManager = socketManager
    }
    
    func runDiagnostics(completion: @escaping (NetworkDiagnosticResult) -> Void) {
        var result = NetworkDiagnosticResult()
        
        // Check internet connectivity
        checkInternetConnectivity { isConnected in
            result.internetConnected = isConnected
            
            // If no internet, return early
            guard isConnected else {
                completion(result)
                return
            }
            
            // Check server reachability
            self.checkServerReachability { isReachable in
                result.serverReachable = isReachable
                
                // If server not reachable, return early
                guard isReachable else {
                    completion(result)
                    return
                }
                
                // Check WebSocket connectivity
                self.checkWebSocketConnectivity { canConnect in
                    result.webSocketConnectable = canConnect
                    
                    // If WebSocket can't connect, return early
                    guard canConnect else {
                        completion(result)
                        return
                    }
                    
                    // Check authentication
                    self.checkAuthentication { isAuthenticated in
                        result.authenticated = isAuthenticated
                        completion(result)
                    }
                }
            }
        }
    }
    
    private func checkInternetConnectivity(completion: @escaping (Bool) -> Void) {
        // Simple check by trying to reach a reliable host
        let url = URL(string: "https://www.apple.com")!
        let task = URLSession.shared.dataTask(with: url) { _, response, error in
            let isConnected = error == nil && (response as? HTTPURLResponse)?.statusCode == 200
            completion(isConnected)
        }
        task.resume()
    }
    
    private func checkServerReachability(completion: @escaping (Bool) -> Void) {
        // Try to reach the server's health endpoint
        guard let serverURL = socketManager.serverURL else {
            completion(false)
            return
        }
        
        var healthURL = serverURL
        healthURL.appendPathComponent("health")
        
        let task = URLSession.shared.dataTask(with: healthURL) { _, response, error in
            let isReachable = error == nil && (response as? HTTPURLResponse)?.statusCode == 200
            completion(isReachable)
        }
        task.resume()
    }
    
    private func checkWebSocketConnectivity(completion: @escaping (Bool) -> Void) {
        // Try to establish a temporary WebSocket connection
        let tempSocket = socketManager.createTemporarySocket()
        
        var didComplete = false
        
        tempSocket.on(clientEvent: .connect) { _, _ in
            if !didComplete {
                didComplete = true
                tempSocket.disconnect()
                completion(true)
            }
        }
        
        tempSocket.on(clientEvent: .error) { _, _ in
            if !didComplete {
                didComplete = true
                tempSocket.disconnect()
                completion(false)
            }
        }
        
        // Set timeout
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
            if !didComplete {
                didComplete = true
                tempSocket.disconnect()
                completion(false)
            }
        }
        
        tempSocket.connect()
    }
    
    private func checkAuthentication(completion: @escaping (Bool) -> Void) {
        // Try to access an authenticated endpoint
        socketManager.checkAuthentication(completion: completion)
    }
}

struct NetworkDiagnosticResult {
    var internetConnected = false
    var serverReachable = false
    var webSocketConnectable = false
    var authenticated = false
    
    var summary: String {
        var issues: [String] = []
        
        if !internetConnected {
            issues.append("No internet connection")
        }
        
        if internetConnected && !serverReachable {
            issues.append("Server is unreachable")
        }
        
        if serverReachable && !webSocketConnectable {
            issues.append("WebSocket connection failed")
        }
        
        if webSocketConnectable && !authenticated {
            issues.append("Authentication failed")
        }
        
        if issues.isEmpty {
            return "All systems operational"
        } else {
            return "Issues detected: " + issues.joined(separator: ", ")
        }
    }
}

extension Notification.Name {
    static let offlineModeEnabled = Notification.Name("com.openhands.mac.offlineModeEnabled")
}
```

### 3.2 File System Recovery

```swift
class FileSystemRecoveryManager {
    private let fileManager = FileManager.default
    
    init() {
        setupNotificationHandlers()
    }
    
    private func setupNotificationHandlers() {
        // Handle request file permission
        NotificationCenter.default.addObserver(
            forName: .requestFilePermission,
            object: nil,
            queue: .main
        ) { [weak self] notification in
            if let path = notification.object as? String {
                self?.requestFilePermission(path: path)
            }
        }
        
        // Handle refresh file explorer
        NotificationCenter.default.addObserver(
            forName: .refreshFileExplorer,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.refreshFileExplorer()
        }
        
        // Handle retry save file
        NotificationCenter.default.addObserver(
            forName: .retrySaveFile,
            object: nil,
            queue: .main
        ) { [weak self] notification in
            if let path = notification.object as? String {
                self?.retrySaveFile(path: path)
            }
        }
        
        // Handle show save as dialog
        NotificationCenter.default.addObserver(
            forName: .showSaveAsDialog,
            object: nil,
            queue: .main
        ) { [weak self] notification in
            if let path = notification.object as? String {
                self?.showSaveAsDialog(path: path)
            }
        }
    }
    
    // Request file permission
    func requestFilePermission(path: String) {
        // For macOS, we need to use the open panel to get permission
        let openPanel = NSOpenPanel()
        openPanel.message = "Please grant access to this file or directory"
        openPanel.prompt = "Grant Access"
        
        // Try to set the initial directory to the parent folder
        let url = URL(fileURLWithPath: path)
        openPanel.directoryURL = url.deletingLastPathComponent()
        
        openPanel.begin { result in
            if result == .OK {
                // Permission granted, notify file explorer to refresh
                NotificationCenter.default.post(name: .refreshFileExplorer, object: nil)
            }
        }
    }
    
    // Refresh file explorer
    func refreshFileExplorer() {
        NotificationCenter.default.post(name: .fileExplorerRefresh, object: nil)
    }
    
    // Retry save file
    func retrySaveFile(path: String) {
        NotificationCenter.default.post(name: .retrySaveFileContent, object: path)
    }
    
    // Show save as dialog
    func showSaveAsDialog(path: String) {
        let savePanel = NSSavePanel()
        
        // Set initial directory and filename
        let url = URL(fileURLWithPath: path)
        savePanel.directoryURL = url.deletingLastPathComponent()
        savePanel.nameFieldStringValue = url.lastPathComponent
        
        savePanel.begin { result in
            if result == .OK, let newURL = savePanel.url {
                // Notify with new path
                NotificationCenter.default.post(
                    name: .saveFileAs,
                    object: [
                        "originalPath": path,
                        "newPath": newURL.path
                    ]
                )
            }
        }
    }
    
    // Check if file exists
    func fileExists(at path: String) -> Bool {
        return fileManager.fileExists(atPath: path)
    }
    
    // Create backup of file
    func createBackup(of path: String) -> String? {
        let url = URL(fileURLWithPath: path)
        let backupURL = url.deletingLastPathComponent()
            .appendingPathComponent(".\(url.lastPathComponent).backup")
        
        do {
            if fileManager.fileExists(atPath: backupURL.path) {
                try fileManager.removeItem(at: backupURL)
            }
            
            try fileManager.copyItem(at: url, to: backupURL)
            return backupURL.path
        } catch {
            print("Failed to create backup: \(error)")
            return nil
        }
    }
    
    // Restore from backup
    func restoreFromBackup(path: String) -> Bool {
        let url = URL(fileURLWithPath: path)
        let backupURL = url.deletingLastPathComponent()
            .appendingPathComponent(".\(url.lastPathComponent).backup")
        
        guard fileManager.fileExists(atPath: backupURL.path) else {
            return false
        }
        
        do {
            if fileManager.fileExists(atPath: path) {
                try fileManager.removeItem(at: url)
            }
            
            try fileManager.copyItem(at: backupURL, to: url)
            return true
        } catch {
            print("Failed to restore from backup: \(error)")
            return false
        }
    }
}

extension Notification.Name {
    static let fileExplorerRefresh = Notification.Name("com.openhands.mac.fileExplorerRefresh")
    static let retrySaveFileContent = Notification.Name("com.openhands.mac.retrySaveFileContent")
    static let saveFileAs = Notification.Name("com.openhands.mac.saveFileAs")
}
```

### 3.3 State Recovery

```swift
class StateRecoveryManager {
    private let stateStore: StateStore
    private let statePersistenceManager: StatePersistenceManager
    
    init(stateStore: StateStore, statePersistenceManager: StatePersistenceManager) {
        self.stateStore = stateStore
        self.statePersistenceManager = statePersistenceManager
        
        setupNotificationHandlers()
    }
    
    private func setupNotificationHandlers() {
        // Handle retry state sync
        NotificationCenter.default.addObserver(
            forName: .retryStateSync,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.retryStateSync()
        }
        
        // Handle reset application state
        NotificationCenter.default.addObserver(
            forName: .resetApplicationState,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.resetApplicationState()
        }
        
        // Handle conflict resolution
        NotificationCenter.default.addObserver(
            forName: .resolveConflictWithServer,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.resolveConflict(strategy: .serverWins)
        }
        
        NotificationCenter.default.addObserver(
            forName: .resolveConflictWithLocal,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.resolveConflict(strategy: .clientWins)
        }
        
        NotificationCenter.default.addObserver(
            forName: .resolveConflictWithMerge,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.resolveConflict(strategy: .merge)
        }
    }
    
    // Retry state sync
    func retryStateSync() {
        NotificationCenter.default.post(name: .forceSyncState, object: nil)
    }
    
    // Reset application state
    func resetApplicationState() {
        // Show confirmation dialog
        let alert = NSAlert()
        alert.messageText = "Reset Application State"
        alert.informativeText = "This will reset the application to its default state. All unsaved data will be lost. Are you sure you want to continue?"
        alert.alertStyle = .critical
        alert.addButton(withTitle: "Reset")
        alert.addButton(withTitle: "Cancel")
        
        let response = alert.runModal()
        
        if response == .alertFirstButtonReturn {
            // Create backup before resetting
            createStateBackup()
            
            // Clear state
            statePersistenceManager.clearState()
            
            // Restart application
            restartApplication()
        }
    }
    
    // Create backup of current state
    func createStateBackup() {
        guard let state = statePersistenceManager.loadState() else {
            return
        }
        
        // Save backup with timestamp
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyyMMdd_HHmmss"
        let timestamp = dateFormatter.string(from: Date())
        
        statePersistenceManager.saveStateBackup(state, name: "backup_\(timestamp)")
    }
    
    // Restore from backup
    func restoreFromBackup(name: String) {
        guard let backupState = statePersistenceManager.loadStateBackup(name: name) else {
            return
        }
        
        // Apply backup state
        stateStore.updateState { _ in
            return backupState
        }
        
        // Save restored state
        statePersistenceManager.saveState(backupState)
    }
    
    // Resolve conflict
    func resolveConflict(strategy: ConflictResolutionStrategy) {
        NotificationCenter.default.post(name: .resolveStateConflict, object: strategy)
    }
    
    // Restart application
    private func restartApplication() {
        let task = Process()
        task.launchPath = "/usr/bin/open"
        task.arguments = ["-n", Bundle.main.bundlePath]
        
        do {
            try task.run()
            NSApp.terminate(nil)
        } catch {
            print("Failed to restart application: \(error)")
        }
    }
}

extension Notification.Name {
    static let forceSyncState = Notification.Name("com.openhands.mac.forceSyncState")
    static let resolveStateConflict = Notification.Name("com.openhands.mac.resolveStateConflict")
}

// Extended StatePersistenceManager for backups
extension StatePersistenceManager {
    func saveStateBackup(_ state: AppState, name: String) {
        guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return
        }
        
        let backupsDirectory = documentsDirectory.appendingPathComponent("backups")
        
        // Create backups directory if it doesn't exist
        if !FileManager.default.fileExists(atPath: backupsDirectory.path) {
            do {
                try FileManager.default.createDirectory(at: backupsDirectory, withIntermediateDirectories: true)
            } catch {
                print("Failed to create backups directory: \(error)")
                return
            }
        }
        
        let backupURL = backupsDirectory.appendingPathComponent("\(name).json")
        
        do {
            let encoder = JSONEncoder()
            encoder.outputFormatting = .prettyPrinted
            let data = try encoder.encode(state)
            try data.write(to: backupURL)
        } catch {
            print("Error saving state backup: \(error)")
        }
    }
    
    func loadStateBackup(name: String) -> AppState? {
        guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return nil
        }
        
        let backupURL = documentsDirectory
            .appendingPathComponent("backups")
            .appendingPathComponent("\(name).json")
        
        guard FileManager.default.fileExists(atPath: backupURL.path) else {
            return nil
        }
        
        do {
            let data = try Data(contentsOf: backupURL)
            let decoder = JSONDecoder()
            return try decoder.decode(AppState.self, from: data)
        } catch {
            print("Error loading state backup: \(error)")
            return nil
        }
    }
    
    func listStateBackups() -> [String] {
        guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return []
        }
        
        let backupsDirectory = documentsDirectory.appendingPathComponent("backups")
        
        guard FileManager.default.fileExists(atPath: backupsDirectory.path) else {
            return []
        }
        
        do {
            let fileURLs = try FileManager.default.contentsOfDirectory(at: backupsDirectory, includingPropertiesForKeys: nil)
            return fileURLs
                .filter { $0.pathExtension == "json" }
                .map { $0.deletingPathExtension().lastPathComponent }
        } catch {
            print("Error listing state backups: \(error)")
            return []
        }
    }
}
```

### 3.4 Authentication Recovery

```swift
class AuthRecoveryManager {
    private let authManager: AuthManager
    
    init(authManager: AuthManager) {
        self.authManager = authManager
        
        setupNotificationHandlers()
    }
    
    private func setupNotificationHandlers() {
        // Handle show sign in prompt
        NotificationCenter.default.addObserver(
            forName: .showSignInPrompt,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.showSignInPrompt()
        }
    }
    
    // Show sign in prompt
    func showSignInPrompt() {
        // Create sign in view controller
        let signInViewController = SignInViewController(authManager: authManager)
        
        // Present as sheet
        if let window = NSApp.keyWindow {
            window.contentViewController?.presentAsSheet(signInViewController)
        }
    }
    
    // Refresh authentication token
    func refreshAuthToken(completion: @escaping (Bool) -> Void) {
        authManager.refreshToken { result in
            switch result {
            case .success:
                completion(true)
            case .failure:
                // Token refresh failed, show sign in prompt
                self.showSignInPrompt()
                completion(false)
            }
        }
    }
}

// Sign In View Controller
class SignInViewController: NSViewController {
    private let authManager: AuthManager
    
    private let emailTextField = NSTextField()
    private let passwordTextField = NSSecureTextField()
    private let signInButton = NSButton(title: "Sign In", target: nil, action: nil)
    private let cancelButton = NSButton(title: "Cancel", target: nil, action: nil)
    private let errorLabel = NSTextField(labelWithString: "")
    
    init(authManager: AuthManager) {
        self.authManager = authManager
        super.init(nibName: nil, bundle: nil)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func loadView() {
        view = NSView()
        view.frame = NSRect(x: 0, y: 0, width: 300, height: 200)
        
        setupUI()
    }
    
    private func setupUI() {
        // Email field
        emailTextField.placeholderString = "Email"
        emailTextField.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(emailTextField)
        
        // Password field
        passwordTextField.placeholderString = "Password"
        passwordTextField.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(passwordTextField)
        
        // Error label
        errorLabel.textColor = .systemRed
        errorLabel.isHidden = true
        errorLabel.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(errorLabel)
        
        // Sign in button
        signInButton.bezelStyle = .rounded
        signInButton.keyEquivalent = "\r"
        signInButton.target = self
        signInButton.action = #selector(signInTapped)
        signInButton.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(signInButton)
        
        // Cancel button
        cancelButton.bezelStyle = .rounded
        cancelButton.target = self
        cancelButton.action = #selector(cancelTapped)
        cancelButton.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(cancelButton)
        
        // Layout constraints
        NSLayoutConstraint.activate([
            emailTextField.topAnchor.constraint(equalTo: view.topAnchor, constant: 20),
            emailTextField.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),
            emailTextField.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),
            
            passwordTextField.topAnchor.constraint(equalTo: emailTextField.bottomAnchor, constant: 10),
            passwordTextField.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),
            passwordTextField.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),
            
            errorLabel.topAnchor.constraint(equalTo: passwordTextField.bottomAnchor, constant: 10),
            errorLabel.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),
            errorLabel.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),
            
            cancelButton.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -20),
            cancelButton.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),
            cancelButton.widthAnchor.constraint(equalToConstant: 100),
            
            signInButton.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -20),
            signInButton.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),
            signInButton.widthAnchor.constraint(equalToConstant: 100)
        ])
    }
    
    @objc private func signInTapped() {
        guard let email = emailTextField.stringValue.nilIfEmpty,
              let password = passwordTextField.stringValue.nilIfEmpty else {
            showError("Please enter email and password")
            return
        }
        
        // Disable UI during sign in
        setUIEnabled(false)
        
        // Attempt sign in
        authManager.signIn(email: email, password: password) { [weak self] result in
            DispatchQueue.main.async {
                self?.setUIEnabled(true)
                
                switch result {
                case .success:
                    // Sign in successful, dismiss
                    self?.dismiss(nil)
                    
                    // Notify that authentication is restored
                    NotificationCenter.default.post(name: .authenticationRestored, object: nil)
                    
                case .failure(let error):
                    // Show error
                    self?.showError(error.localizedDescription)
                }
            }
        }
    }
    
    @objc private func cancelTapped() {
        dismiss(nil)
    }
    
    private func showError(_ message: String) {
        errorLabel.stringValue = message
        errorLabel.isHidden = false
    }
    
    private func setUIEnabled(_ enabled: Bool) {
        emailTextField.isEnabled = enabled
        passwordTextField.isEnabled = enabled
        signInButton.isEnabled = enabled
        cancelButton.isEnabled = enabled
    }
}

extension String {
    var nilIfEmpty: String? {
        return self.isEmpty ? nil : self
    }
}

extension Notification.Name {
    static let authenticationRestored = Notification.Name("com.openhands.mac.authenticationRestored")
}
```

### 3.5 Application Recovery

```swift
class ApplicationRecoveryManager {
    init() {
        setupNotificationHandlers()
    }
    
    private func setupNotificationHandlers() {
        // Handle restart application
        NotificationCenter.default.addObserver(
            forName: .restartApplication,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.restartApplication()
        }
        
        // Handle save and restart
        NotificationCenter.default.addObserver(
            forName: .saveAndRestart,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.saveAndRestart()
        }
    }
    
    // Restart application
    func restartApplication() {
        let task = Process()
        task.launchPath = "/usr/bin/open"
        task.arguments = ["-n", Bundle.main.bundlePath]
        
        do {
            try task.run()
            NSApp.terminate(nil)
        } catch {
            print("Failed to restart application: \(error)")
        }
    }
    
    // Save and restart
    func saveAndRestart() {
        // Notify all components to save their state
        NotificationCenter.default.post(name: .saveAllState, object: nil)
        
        // Wait a moment for saves to complete
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { [weak self] in
            self?.restartApplication()
        }
    }
    
    // Check for application updates
    func checkForUpdates(completion: @escaping (Bool) -> Void) {
        // Implementation would depend on update mechanism
        // For example, using Sparkle framework
        
        // Placeholder implementation
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            completion(false)
        }
    }
    
    // Install update
    func installUpdate() {
        // Implementation would depend on update mechanism
    }
    
    // Check system requirements
    func checkSystemRequirements() -> Bool {
        // Check macOS version
        let osVersion = ProcessInfo.processInfo.operatingSystemVersion
        let isSupported = osVersion.majorVersion >= 11
        
        // Check available disk space
        let availableDiskSpace = getAvailableDiskSpace()
        let hasEnoughSpace = availableDiskSpace > 100_000_000 // 100 MB
        
        return isSupported && hasEnoughSpace
    }
    
    // Get available disk space
    private func getAvailableDiskSpace() -> Int64 {
        do {
            let fileURL = URL(fileURLWithPath: NSHomeDirectory())
            let values = try fileURL.resourceValues(forKeys: [.volumeAvailableCapacityKey])
            if let capacity = values.volumeAvailableCapacity {
                return Int64(capacity)
            }
        } catch {
            print("Error getting disk space: \(error)")
        }
        return 0
    }
}

extension Notification.Name {
    static let saveAllState = Notification.Name("com.openhands.mac.saveAllState")
}
```

This implementation guide provides a comprehensive approach to error handling and recovery in the Mac client, covering error definitions, user feedback mechanisms, and recovery procedures for various failure scenarios.

---

# tasks/impl_event_handling.md

# Event Handling Architecture for Mac Client

This document outlines the implementation details for event handling in the Mac client, including processing and routing events from the backend, event prioritization, and queueing mechanisms.

## 1. Event System Architecture

### 1.1 Event Types and Definitions

```swift
// MARK: - Event Types

// Base protocol for all events
protocol Event {
    var id: String { get }
    var timestamp: Date { get }
    var type: EventType { get }
}

// Event types enum
enum EventType: String, Codable {
    // System events
    case connectionEstablished = "connection_established"
    case connectionLost = "connection_lost"
    case connectionError = "connection_error"
    case authRequired = "auth_required"
    case authSuccess = "auth_success"
    case authFailure = "auth_failure"
    
    // Agent events
    case agentThinking = "agent_thinking"
    case agentResponse = "agent_response"
    case agentError = "agent_error"
    case agentComplete = "agent_complete"
    
    // Conversation events
    case conversationCreated = "conversation_created"
    case conversationUpdated = "conversation_updated"
    case conversationDeleted = "conversation_deleted"
    case messageReceived = "message_received"
    case messageUpdated = "message_updated"
    
    // File system events
    case fileCreated = "file_created"
    case fileUpdated = "file_updated"
    case fileDeleted = "file_deleted"
    case fileContentChanged = "file_content_changed"
    
    // User events
    case userJoined = "user_joined"
    case userLeft = "user_left"
    case userActivity = "user_activity"
    
    // Custom events
    case custom = "custom"
}

// Base event implementation
struct BaseEvent: Event, Codable {
    let id: String
    let timestamp: Date
    let type: EventType
    let payload: [String: AnyCodable]?
    
    init(id: String = UUID().uuidString, type: EventType, payload: [String: Any]? = nil) {
        self.id = id
        self.timestamp = Date()
        self.type = type
        self.payload = payload?.mapValues { AnyCodable($0) }
    }
}

// Specialized event types
struct AgentResponseEvent: Event, Codable {
    let id: String
    let timestamp: Date
    let type: EventType = .agentResponse
    let conversationId: String
    let messageId: String
    let content: String
    let isComplete: Bool
    let metadata: [String: AnyCodable]?
    
    init(id: String = UUID().uuidString, conversationId: String, messageId: String, content: String, isComplete: Bool, metadata: [String: Any]? = nil) {
        self.id = id
        self.timestamp = Date()
        self.conversationId = conversationId
        self.messageId = messageId
        self.content = content
        self.isComplete = isComplete
        self.metadata = metadata?.mapValues { AnyCodable($0) }
    }
}

struct MessageReceivedEvent: Event, Codable {
    let id: String
    let timestamp: Date
    let type: EventType = .messageReceived
    let conversationId: String
    let message: Message
    
    init(id: String = UUID().uuidString, conversationId: String, message: Message) {
        self.id = id
        self.timestamp = Date()
        self.conversationId = conversationId
        self.message = message
    }
}

struct ConnectionEvent: Event, Codable {
    let id: String
    let timestamp: Date
    let type: EventType
    let status: ConnectionStatus
    let error: String?
    
    init(id: String = UUID().uuidString, type: EventType, status: ConnectionStatus, error: String? = nil) {
        self.id = id
        self.timestamp = Date()
        self.type = type
        self.status = status
        self.error = error
    }
}

// Connection status enum
enum ConnectionStatus: String, Codable {
    case connecting
    case connected
    case disconnected
    case reconnecting
    case error
}

// Helper for encoding/decoding Any values
struct AnyCodable: Codable {
    let value: Any
    
    init(_ value: Any) {
        self.value = value
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        
        if container.decodeNil() {
            self.value = NSNull()
        } else if let bool = try? container.decode(Bool.self) {
            self.value = bool
        } else if let int = try? container.decode(Int.self) {
            self.value = int
        } else if let double = try? container.decode(Double.self) {
            self.value = double
        } else if let string = try? container.decode(String.self) {
            self.value = string
        } else if let array = try? container.decode([AnyCodable].self) {
            self.value = array.map { $0.value }
        } else if let dictionary = try? container.decode([String: AnyCodable].self) {
            self.value = dictionary.mapValues { $0.value }
        } else {
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: "AnyCodable value cannot be decoded"
            )
        }
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        
        switch value {
        case is NSNull:
            try container.encodeNil()
        case let bool as Bool:
            try container.encode(bool)
        case let int as Int:
            try container.encode(int)
        case let double as Double:
            try container.encode(double)
        case let string as String:
            try container.encode(string)
        case let array as [Any]:
            try container.encode(array.map { AnyCodable($0) })
        case let dictionary as [String: Any]:
            try container.encode(dictionary.mapValues { AnyCodable($0) })
        default:
            let context = EncodingError.Context(
                codingPath: container.codingPath,
                debugDescription: "AnyCodable value cannot be encoded"
            )
            throw EncodingError.invalidValue(value, context)
        }
    }
}
```

### 1.2 Event Bus Implementation

```swift
// MARK: - Event Bus

class EventBus {
    // Singleton instance
    static let shared = EventBus()
    
    // Event handlers by type
    private var handlers: [EventType: [(Event) -> Void]] = [:]
    
    // Event history for debugging and recovery
    private var eventHistory: [Event] = []
    private let maxHistorySize = 100
    
    // Serial queue for thread safety
    private let queue = DispatchQueue(label: "com.openhands.mac.eventBus", qos: .userInitiated)
    
    private init() {}
    
    // Register handler for specific event type
    func register(for eventType: EventType, handler: @escaping (Event) -> Void) -> EventSubscription {
        let subscription = EventSubscription(eventBus: self, eventType: eventType, handler: handler)
        
        queue.sync {
            if handlers[eventType] == nil {
                handlers[eventType] = []
            }
            
            handlers[eventType]?.append(handler)
        }
        
        return subscription
    }
    
    // Register handler for multiple event types
    func register(for eventTypes: [EventType], handler: @escaping (Event) -> Void) -> [EventSubscription] {
        return eventTypes.map { register(for: $0, handler: handler) }
    }
    
    // Unregister handler
    func unregister(for eventType: EventType, handler: @escaping (Event) -> Void) {
        queue.sync {
            handlers[eventType]?.removeAll { $0 as AnyObject === handler as AnyObject }
        }
    }
    
    // Post event to bus
    func post(_ event: Event) {
        queue.async { [weak self] in
            guard let self = self else { return }
            
            // Add to history
            self.eventHistory.append(event)
            if self.eventHistory.count > self.maxHistorySize {
                self.eventHistory.removeFirst()
            }
            
            // Notify handlers
            let eventHandlers = self.handlers[event.type] ?? []
            
            // Dispatch to main queue for UI updates
            DispatchQueue.main.async {
                for handler in eventHandlers {
                    handler(event)
                }
            }
        }
    }
    
    // Get event history
    func getEventHistory() -> [Event] {
        return queue.sync { eventHistory }
    }
    
    // Clear event history
    func clearEventHistory() {
        queue.sync { eventHistory.removeAll() }
    }
}

// Event subscription for cleanup
class EventSubscription {
    private weak var eventBus: EventBus?
    private let eventType: EventType
    private let handler: (Event) -> Void
    
    init(eventBus: EventBus, eventType: EventType, handler: @escaping (Event) -> Void) {
        self.eventBus = eventBus
        self.eventType = eventType
        self.handler = handler
    }
    
    func cancel() {
        eventBus?.unregister(for: eventType, handler: handler)
    }
    
    deinit {
        cancel()
    }
}
```

### 1.3 Socket.IO Event Adapter

```swift
// MARK: - Socket.IO Event Adapter

class SocketEventAdapter {
    private let socketManager: SocketManager
    private let eventBus: EventBus
    private var subscriptions: [EventSubscription] = []
    
    init(socketManager: SocketManager, eventBus: EventBus = .shared) {
        self.socketManager = socketManager
        self.eventBus = eventBus
        
        setupSocketHandlers()
        setupEventBusHandlers()
    }
    
    // Set up Socket.IO event handlers
    private func setupSocketHandlers() {
        // Handle connection events
        socketManager.on(clientEvent: .connect) { [weak self] _, _ in
            guard let self = self else { return }
            
            let event = ConnectionEvent(
                type: .connectionEstablished,
                status: .connected
            )
            
            self.eventBus.post(event)
        }
        
        socketManager.on(clientEvent: .disconnect) { [weak self] _, _ in
            guard let self = self else { return }
            
            let event = ConnectionEvent(
                type: .connectionLost,
                status: .disconnected
            )
            
            self.eventBus.post(event)
        }
        
        socketManager.on(clientEvent: .error) { [weak self] _, data in
            guard let self = self else { return }
            
            let errorMessage = data.first as? String ?? "Unknown error"
            
            let event = ConnectionEvent(
                type: .connectionError,
                status: .error,
                error: errorMessage
            )
            
            self.eventBus.post(event)
        }
        
        socketManager.on(clientEvent: .reconnect) { [weak self] _, _ in
            guard let self = self else { return }
            
            let event = ConnectionEvent(
                type: .connectionEstablished,
                status: .connected
            )
            
            self.eventBus.post(event)
        }
        
        socketManager.on(clientEvent: .reconnectAttempt) { [weak self] _, _ in
            guard let self = self else { return }
            
            let event = ConnectionEvent(
                type: .connectionLost,
                status: .reconnecting
            )
            
            self.eventBus.post(event)
        }
        
        // Handle agent events
        socketManager.on("oh_event") { [weak self] data in
            guard let self = self,
                  let eventData = data.first as? [String: Any],
                  let eventType = eventData["type"] as? String else {
                return
            }
            
            // Convert Socket.IO event to app event
            if let event = self.convertSocketEventToAppEvent(eventType: eventType, data: eventData) {
                self.eventBus.post(event)
            }
        }
    }
    
    // Set up event bus handlers for outgoing events
    private func setupEventBusHandlers() {
        // Register for outgoing events that need to be sent to the server
        let outgoingEventTypes: [EventType] = [
            .messageReceived,
            .conversationCreated,
            .conversationUpdated,
            .fileCreated,
            .fileUpdated,
            .fileDeleted
        ]
        
        for eventType in outgoingEventTypes {
            let subscription = eventBus.register(for: eventType) { [weak self] event in
                guard let self = self else { return }
                
                // Convert app event to Socket.IO event
                if let socketEvent = self.convertAppEventToSocketEvent(event) {
                    self.socketManager.emit(socketEvent.name, socketEvent.data)
                }
            }
            
            subscriptions.append(subscription)
        }
    }
    
    // Convert Socket.IO event to app event
    private func convertSocketEventToAppEvent(eventType: String, data: [String: Any]) -> Event? {
        // Map Socket.IO event type to app event type
        guard let appEventType = mapSocketEventTypeToAppEventType(eventType) else {
            return nil
        }
        
        // Create appropriate event based on type
        switch appEventType {
        case .agentResponse:
            guard let conversationId = data["conversation_id"] as? String,
                  let messageId = data["message_id"] as? String,
                  let content = data["content"] as? String,
                  let isComplete = data["is_complete"] as? Bool else {
                return nil
            }
            
            return AgentResponseEvent(
                conversationId: conversationId,
                messageId: messageId,
                content: content,
                isComplete: isComplete,
                metadata: data["metadata"] as? [String: Any]
            )
            
        case .messageReceived:
            guard let conversationId = data["conversation_id"] as? String,
                  let messageData = data["message"] as? [String: Any],
                  let message = try? decodeMessage(from: messageData) else {
                return nil
            }
            
            return MessageReceivedEvent(
                conversationId: conversationId,
                message: message
            )
            
        default:
            // For other event types, create a generic BaseEvent
            return BaseEvent(
                id: data["id"] as? String ?? UUID().uuidString,
                type: appEventType,
                payload: data
            )
        }
    }
    
    // Convert app event to Socket.IO event
    private func convertAppEventToSocketEvent(event: Event) -> (name: String, data: [String: Any])? {
        // Create Socket.IO event based on app event type
        switch event.type {
        case .messageReceived:
            guard let messageEvent = event as? MessageReceivedEvent else {
                return nil
            }
            
            return ("oh_action", [
                "type": "send_message",
                "conversation_id": messageEvent.conversationId,
                "message": try? encodeToJSON(messageEvent.message)
            ])
            
        case .conversationCreated, .conversationUpdated:
            // Extract conversation data from event
            guard let payload = (event as? BaseEvent)?.payload else {
                return nil
            }
            
            return ("oh_action", [
                "type": mapAppEventTypeToSocketEventType(event.type),
                "conversation": payload.mapValues { $0.value }
            ])
            
        case .fileCreated, .fileUpdated, .fileDeleted:
            // Extract file data from event
            guard let payload = (event as? BaseEvent)?.payload else {
                return nil
            }
            
            return ("oh_action", [
                "type": mapAppEventTypeToSocketEventType(event.type),
                "file": payload.mapValues { $0.value }
            ])
            
        default:
            return nil
        }
    }
    
    // Map Socket.IO event type to app event type
    private func mapSocketEventTypeToAppEventType(_ socketEventType: String) -> EventType? {
        switch socketEventType {
        case "agent_thinking":
            return .agentThinking
        case "agent_response":
            return .agentResponse
        case "agent_error":
            return .agentError
        case "agent_complete":
            return .agentComplete
        case "conversation_created":
            return .conversationCreated
        case "conversation_updated":
            return .conversationUpdated
        case "conversation_deleted":
            return .conversationDeleted
        case "message_received":
            return .messageReceived
        case "message_updated":
            return .messageUpdated
        case "file_created":
            return .fileCreated
        case "file_updated":
            return .fileUpdated
        case "file_deleted":
            return .fileDeleted
        case "file_content_changed":
            return .fileContentChanged
        case "user_joined":
            return .userJoined
        case "user_left":
            return .userLeft
        case "user_activity":
            return .userActivity
        case "auth_required":
            return .authRequired
        case "auth_success":
            return .authSuccess
        case "auth_failure":
            return .authFailure
        default:
            if socketEventType.hasPrefix("custom_") {
                return .custom
            }
            return nil
        }
    }
    
    // Map app event type to Socket.IO event type
    private func mapAppEventTypeToSocketEventType(_ appEventType: EventType) -> String {
        switch appEventType {
        case .agentThinking:
            return "agent_thinking"
        case .agentResponse:
            return "agent_response"
        case .agentError:
            return "agent_error"
        case .agentComplete:
            return "agent_complete"
        case .conversationCreated:
            return "conversation_created"
        case .conversationUpdated:
            return "conversation_updated"
        case .conversationDeleted:
            return "conversation_deleted"
        case .messageReceived:
            return "message_received"
        case .messageUpdated:
            return "message_updated"
        case .fileCreated:
            return "file_created"
        case .fileUpdated:
            return "file_updated"
        case .fileDeleted:
            return "file_deleted"
        case .fileContentChanged:
            return "file_content_changed"
        case .userJoined:
            return "user_joined"
        case .userLeft:
            return "user_left"
        case .userActivity:
            return "user_activity"
        case .authRequired:
            return "auth_required"
        case .authSuccess:
            return "auth_success"
        case .authFailure:
            return "auth_failure"
        case .connectionEstablished:
            return "connection_established"
        case .connectionLost:
            return "connection_lost"
        case .connectionError:
            return "connection_error"
        case .custom:
            return "custom"
        }
    }
    
    // Helper to decode message from JSON
    private func decodeMessage(from data: [String: Any]) throws -> Message {
        let jsonData = try JSONSerialization.data(withJSONObject: data)
        return try JSONDecoder().decode(Message.self, from: jsonData)
    }
    
    // Helper to encode object to JSON
    private func encodeToJSON<T: Encodable>(_ object: T) throws -> [String: Any] {
        let jsonData = try JSONEncoder().encode(object)
        guard let jsonObject = try JSONSerialization.jsonObject(with: jsonData) as? [String: Any] else {
            throw EncodingError.invalidValue(object, EncodingError.Context(
                codingPath: [],
                debugDescription: "Failed to convert encoded data to JSON object"
            ))
        }
        return jsonObject
    }
}
```

## 2. Event Processing and Routing

### 2.1 Event Processor

```swift
// MARK: - Event Processor

class EventProcessor {
    private let eventBus: EventBus
    private let eventQueue: EventQueue
    private var subscriptions: [EventSubscription] = []
    
    // Event handlers by type
    private var processors: [EventType: (Event) -> Void] = [:]
    
    init(eventBus: EventBus = .shared, eventQueue: EventQueue = EventQueue()) {
        self.eventBus = eventBus
        self.eventQueue = eventQueue
        
        registerProcessors()
        subscribeToEvents()
    }
    
    // Register event processors
    private func registerProcessors() {
        // Agent response processor
        processors[.agentResponse] = { [weak self] event in
            guard let self = self,
                  let responseEvent = event as? AgentResponseEvent else {
                return
            }
            
            // Process agent response
            self.processAgentResponse(responseEvent)
        }
        
        // Message received processor
        processors[.messageReceived] = { [weak self] event in
            guard let self = self,
                  let messageEvent = event as? MessageReceivedEvent else {
                return
            }
            
            // Process message
            self.processMessage(messageEvent)
        }
        
        // Connection event processor
        processors[.connectionEstablished] = { [weak self] event in
            guard let self = self,
                  let connectionEvent = event as? ConnectionEvent else {
                return
            }
            
            // Process connection established
            self.processConnectionEstablished(connectionEvent)
        }
        
        processors[.connectionLost] = { [weak self] event in
            guard let self = self,
                  let connectionEvent = event as? ConnectionEvent else {
                return
            }
            
            // Process connection lost
            self.processConnectionLost(connectionEvent)
        }
        
        // Add more processors for other event types...
    }
    
    // Subscribe to events
    private func subscribeToEvents() {
        // Subscribe to all event types with processors
        for eventType in processors.keys {
            let subscription = eventBus.register(for: eventType) { [weak self] event in
                guard let self = self else { return }
                
                // Queue event for processing
                self.eventQueue.enqueue(event: event)
            }
            
            subscriptions.append(subscription)
        }
        
        // Start processing events from queue
        eventQueue.startProcessing { [weak self] event in
            guard let self = self else { return }
            
            // Process event
            if let processor = self.processors[event.type] {
                processor(event)
            }
        }
    }
    
    // Process agent response
    private func processAgentResponse(_ event: AgentResponseEvent) {
        // Update conversation with response
        NotificationCenter.default.post(
            name: .agentResponseReceived,
            object: event
        )
        
        // If response is complete, notify completion
        if event.isComplete {
            NotificationCenter.default.post(
                name: .agentResponseComplete,
                object: event
            )
        }
    }
    
    // Process message
    private func processMessage(_ event: MessageReceivedEvent) {
        // Update conversation with message
        NotificationCenter.default.post(
            name: .messageReceived,
            object: event
        )
    }
    
    // Process connection established
    private func processConnectionEstablished(_ event: ConnectionEvent) {
        // Update connection status
        NotificationCenter.default.post(
            name: .connectionStatusChanged,
            object: event
        )
        
        // Sync state with server
        NotificationCenter.default.post(
            name: .syncStateWithServer,
            object: nil
        )
    }
    
    // Process connection lost
    private func processConnectionLost(_ event: ConnectionEvent) {
        // Update connection status
        NotificationCenter.default.post(
            name: .connectionStatusChanged,
            object: event
        )
        
        // Enable offline mode if needed
        if event.status == .disconnected {
            NotificationCenter.default.post(
                name: .enableOfflineMode,
                object: nil
            )
        }
    }
}

// Notification names
extension Notification.Name {
    static let agentResponseReceived = Notification.Name("com.openhands.mac.agentResponseReceived")
    static let agentResponseComplete = Notification.Name("com.openhands.mac.agentResponseComplete")
    static let messageReceived = Notification.Name("com.openhands.mac.messageReceived")
    static let connectionStatusChanged = Notification.Name("com.openhands.mac.connectionStatusChanged")
    static let syncStateWithServer = Notification.Name("com.openhands.mac.syncStateWithServer")
}
```

### 2.2 Event Router

```swift
// MARK: - Event Router

class EventRouter {
    private let eventBus: EventBus
    private var subscriptions: [EventSubscription] = []
    
    // Component registrations
    private var componentRegistrations: [String: [EventType]] = [:]
    
    init(eventBus: EventBus = .shared) {
        self.eventBus = eventBus
    }
    
    // Register component for event types
    func registerComponent(_ component: AnyObject, id: String, for eventTypes: [EventType], handler: @escaping (Event) -> Void) {
        // Store registration
        componentRegistrations[id] = eventTypes
        
        // Subscribe to events
        for eventType in eventTypes {
            let subscription = eventBus.register(for: eventType) { event in
                handler(event)
            }
            
            subscriptions.append(subscription)
        }
    }
    
    // Unregister component
    func unregisterComponent(id: String) {
        guard let eventTypes = componentRegistrations[id] else {
            return
        }
        
        // Remove registrations
        componentRegistrations.removeValue(forKey: id)
        
        // Remove subscriptions for this component
        subscriptions = subscriptions.filter { subscription in
            // This is a simplification - in a real implementation,
            // we would need to track which subscription belongs to which component
            return true
        }
    }
    
    // Route event to specific component
    func routeEvent(_ event: Event, to componentId: String) {
        guard let eventTypes = componentRegistrations[componentId],
              eventTypes.contains(event.type) else {
            return
        }
        
        // Post event to bus - it will be routed to the component's handler
        eventBus.post(event)
    }
    
    // Get components registered for event type
    func getComponentsForEventType(_ eventType: EventType) -> [String] {
        return componentRegistrations.compactMap { id, types in
            types.contains(eventType) ? id : nil
        }
    }
}
```

### 2.3 Component Event Handling

```swift
// MARK: - Component Event Handling

// Protocol for components that handle events
protocol EventHandler: AnyObject {
    var componentId: String { get }
    func handleEvent(_ event: Event)
    func registerForEvents()
    func unregisterFromEvents()
}

// Base class for view models that handle events
class EventHandlingViewModel: ObservableObject, EventHandler {
    let componentId: String
    private let eventRouter: EventRouter
    private let eventTypes: [EventType]
    
    init(componentId: String, eventRouter: EventRouter, eventTypes: [EventType]) {
        self.componentId = componentId
        self.eventRouter = eventRouter
        self.eventTypes = eventTypes
        
        registerForEvents()
    }
    
    deinit {
        unregisterFromEvents()
    }
    
    func handleEvent(_ event: Event) {
        // Override in subclasses
    }
    
    func registerForEvents() {
        eventRouter.registerComponent(self, id: componentId, for: eventTypes) { [weak self] event in
            self?.handleEvent(event)
        }
    }
    
    func unregisterFromEvents() {
        eventRouter.unregisterComponent(id: componentId)
    }
}

// Example conversation view model
class ConversationViewModel: EventHandlingViewModel {
    @Published var conversation: Conversation
    @Published var messages: [Message] = []
    @Published var isAgentResponding = false
    @Published var agentResponseProgress = 0.0
    
    init(conversation: Conversation, eventRouter: EventRouter) {
        self.conversation = conversation
        
        // Register for conversation-specific events
        super.init(
            componentId: "conversation_\(conversation.id)",
            eventRouter: eventRouter,
            eventTypes: [
                .agentThinking,
                .agentResponse,
                .agentComplete,
                .messageReceived,
                .messageUpdated
            ]
        )
        
        // Initialize messages
        messages = conversation.messages
    }
    
    override func handleEvent(_ event: Event) {
        // Handle events based on type
        switch event.type {
        case .agentThinking:
            handleAgentThinking(event)
        case .agentResponse:
            handleAgentResponse(event)
        case .agentComplete:
            handleAgentComplete(event)
        case .messageReceived:
            handleMessageReceived(event)
        case .messageUpdated:
            handleMessageUpdated(event)
        default:
            break
        }
    }
    
    private func handleAgentThinking(_ event: Event) {
        DispatchQueue.main.async {
            self.isAgentResponding = true
            self.agentResponseProgress = 0.0
        }
    }
    
    private func handleAgentResponse(_ event: Event) {
        guard let responseEvent = event as? AgentResponseEvent,
              responseEvent.conversationId == conversation.id else {
            return
        }
        
        DispatchQueue.main.async {
            self.isAgentResponding = true
            
            // Find existing message or create new one
            if let index = self.messages.firstIndex(where: { $0.id == responseEvent.messageId }) {
                // Update existing message
                var updatedMessage = self.messages[index]
                updatedMessage.content = responseEvent.content
                self.messages[index] = updatedMessage
            } else {
                // Create new message
                let newMessage = Message(
                    id: responseEvent.messageId,
                    source: .agent,
                    content: responseEvent.content,
                    timestamp: responseEvent.timestamp,
                    metadata: responseEvent.metadata?.mapValues { $0.value },
                    sequence: self.messages.count,
                    isAcknowledged: true
                )
                
                self.messages.append(newMessage)
            }
            
            // Update progress
            self.agentResponseProgress = responseEvent.isComplete ? 1.0 : 0.5
        }
    }
    
    private func handleAgentComplete(_ event: Event) {
        DispatchQueue.main.async {
            self.isAgentResponding = false
            self.agentResponseProgress = 1.0
        }
    }
    
    private func handleMessageReceived(_ event: Event) {
        guard let messageEvent = event as? MessageReceivedEvent,
              messageEvent.conversationId == conversation.id else {
            return
        }
        
        DispatchQueue.main.async {
            // Add message if it doesn't exist
            if !self.messages.contains(where: { $0.id == messageEvent.message.id }) {
                self.messages.append(messageEvent.message)
                
                // Sort messages by sequence
                self.messages.sort { $0.sequence < $1.sequence }
            }
        }
    }
    
    private func handleMessageUpdated(_ event: Event) {
        guard let baseEvent = event as? BaseEvent,
              let payload = baseEvent.payload,
              let conversationId = payload["conversation_id"]?.value as? String,
              conversationId == conversation.id,
              let messageData = payload["message"]?.value as? [String: Any],
              let messageId = messageData["id"] as? String else {
            return
        }
        
        DispatchQueue.main.async {
            // Find and update message
            if let index = self.messages.firstIndex(where: { $0.id == messageId }) {
                do {
                    let jsonData = try JSONSerialization.data(withJSONObject: messageData)
                    if let updatedMessage = try? JSONDecoder().decode(Message.self, from: jsonData) {
                        self.messages[index] = updatedMessage
                    }
                } catch {
                    print("Error decoding updated message: \(error)")
                }
            }
        }
    }
    
    // Send message
    func sendMessage(_ content: String) {
        // Create message
        let message = Message(
            id: UUID().uuidString,
            source: .user,
            content: content,
            timestamp: Date(),
            metadata: nil,
            sequence: messages.count,
            isAcknowledged: false
        )
        
        // Add to local messages
        DispatchQueue.main.async {
            self.messages.append(message)
        }
        
        // Create event
        let event = MessageReceivedEvent(
            conversationId: conversation.id,
            message: message
        )
        
        // Post to event bus
        EventBus.shared.post(event)
    }
}
```

## 3. Event Prioritization and Queueing

### 3.1 Event Queue Implementation

```swift
// MARK: - Event Queue

class EventQueue {
    // Event priority
    enum EventPriority: Int, Comparable {
        case low = 0
        case normal = 1
        case high = 2
        case critical = 3
        
        static func < (lhs: EventPriority, rhs: EventPriority) -> Bool {
            return lhs.rawValue < rhs.rawValue
        }
    }
    
    // Queued event with priority
    private struct QueuedEvent {
        let event: Event
        let priority: EventPriority
        let timestamp: Date
        
        init(event: Event, priority: EventPriority) {
            self.event = event
            self.priority = priority
            self.timestamp = Date()
        }
    }
    
    // Queue of events
    private var queue: [QueuedEvent] = []
    
    // Processing state
    private var isProcessing = false
    private var processingHandler: ((Event) -> Void)?
    
    // Serial queue for thread safety
    private let serialQueue = DispatchQueue(label: "com.openhands.mac.eventQueue", qos: .userInitiated)
    
    // Enqueue event with priority
    func enqueue(event: Event, priority: EventPriority = .normal) {
        serialQueue.async { [weak self] in
            guard let self = self else { return }
            
            // Create queued event
            let queuedEvent = QueuedEvent(event: event, priority: priority)
            
            // Add to queue
            self.queue.append(queuedEvent)
            
            // Sort queue by priority and timestamp
            self.sortQueue()
            
            // Start processing if not already processing
            if !self.isProcessing {
                self.processNextEvent()
            }
        }
    }
    
    // Start processing events
    func startProcessing(handler: @escaping (Event) -> Void) {
        serialQueue.async { [weak self] in
            guard let self = self else { return }
            
            self.processingHandler = handler
            
            // Start processing if queue has events
            if !self.queue.isEmpty && !self.isProcessing {
                self.processNextEvent()
            }
        }
    }
    
    // Stop processing events
    func stopProcessing() {
        serialQueue.async { [weak self] in
            guard let self = self else { return }
            
            self.isProcessing = false
            self.processingHandler = nil
        }
    }
    
    // Process next event in queue
    private func processNextEvent() {
        serialQueue.async { [weak self] in
            guard let self = self,
                  !self.queue.isEmpty,
                  let handler = self.processingHandler else {
                self?.isProcessing = false
                return
            }
            
            self.isProcessing = true
            
            // Get next event
            let queuedEvent = self.queue.removeFirst()
            
            // Process event on main queue
            DispatchQueue.main.async {
                handler(queuedEvent.event)
                
                // Process next event
                self.serialQueue.async {
                    if !self.queue.isEmpty {
                        self.processNextEvent()
                    } else {
                        self.isProcessing = false
                    }
                }
            }
        }
    }
    
    // Sort queue by priority and timestamp
    private func sortQueue() {
        queue.sort { first, second in
            if first.priority == second.priority {
                return first.timestamp < second.timestamp
            }
            return first.priority > second.priority
        }
    }
    
    // Get event priority based on type
    static func priorityForEventType(_ eventType: EventType) -> EventPriority {
        switch eventType {
        case .connectionEstablished, .connectionLost, .connectionError, .authRequired:
            return .critical
        case .agentResponse, .agentComplete, .messageReceived:
            return .high
        case .conversationCreated, .conversationUpdated, .conversationDeleted:
            return .normal
        default:
            return .low
        }
    }
    
    // Clear queue
    func clearQueue() {
        serialQueue.async { [weak self] in
            guard let self = self else { return }
            
            self.queue.removeAll()
        }
    }
    
    // Get queue size
    func getQueueSize() -> Int {
        return serialQueue.sync { queue.count }
    }
    
    // Get queued events
    func getQueuedEvents() -> [Event] {
        return serialQueue.sync { queue.map { $0.event } }
    }
}
```

### 3.2 Priority-Based Event Processing

```swift
// MARK: - Priority-Based Event Processor

class PriorityEventProcessor {
    private let eventBus: EventBus
    private let eventQueue: EventQueue
    private var subscriptions: [EventSubscription] = []
    
    init(eventBus: EventBus = .shared, eventQueue: EventQueue = EventQueue()) {
        self.eventBus = eventBus
        self.eventQueue = eventQueue
        
        subscribeToEvents()
    }
    
    // Subscribe to all events
    private func subscribeToEvents() {
        // Get all event types
        let allEventTypes = getAllEventTypes()
        
        // Subscribe to each event type
        for eventType in allEventTypes {
            let subscription = eventBus.register(for: eventType) { [weak self] event in
                guard let self = self else { return }
                
                // Get priority for event type
                let priority = EventQueue.priorityForEventType(event.type)
                
                // Enqueue event with priority
                self.eventQueue.enqueue(event: event, priority: priority)
            }
            
            subscriptions.append(subscription)
        }
        
        // Start processing events
        eventQueue.startProcessing { [weak self] event in
            guard let self = self else { return }
            
            // Process event based on type
            self.processEvent(event)
        }
    }
    
    // Get all event types
    private func getAllEventTypes() -> [EventType] {
        return [
            .connectionEstablished,
            .connectionLost,
            .connectionError,
            .authRequired,
            .authSuccess,
            .authFailure,
            .agentThinking,
            .agentResponse,
            .agentError,
            .agentComplete,
            .conversationCreated,
            .conversationUpdated,
            .conversationDeleted,
            .messageReceived,
            .messageUpdated,
            .fileCreated,
            .fileUpdated,
            .fileDeleted,
            .fileContentChanged,
            .userJoined,
            .userLeft,
            .userActivity,
            .custom
        ]
    }
    
    // Process event based on type
    private func processEvent(_ event: Event) {
        switch event.type {
        case .connectionEstablished, .connectionLost, .connectionError:
            processConnectionEvent(event)
        case .authRequired, .authSuccess, .authFailure:
            processAuthEvent(event)
        case .agentThinking, .agentResponse, .agentError, .agentComplete:
            processAgentEvent(event)
        case .conversationCreated, .conversationUpdated, .conversationDeleted:
            processConversationEvent(event)
        case .messageReceived, .messageUpdated:
            processMessageEvent(event)
        case .fileCreated, .fileUpdated, .fileDeleted, .fileContentChanged:
            processFileEvent(event)
        case .userJoined, .userLeft, .userActivity:
            processUserEvent(event)
        case .custom:
            processCustomEvent(event)
        }
    }
    
    // Process connection event
    private func processConnectionEvent(_ event: Event) {
        // Notify connection manager
        NotificationCenter.default.post(
            name: .connectionEventReceived,
            object: event
        )
    }
    
    // Process auth event
    private func processAuthEvent(_ event: Event) {
        // Notify auth manager
        NotificationCenter.default.post(
            name: .authEventReceived,
            object: event
        )
    }
    
    // Process agent event
    private func processAgentEvent(_ event: Event) {
        // Notify agent manager
        NotificationCenter.default.post(
            name: .agentEventReceived,
            object: event
        )
    }
    
    // Process conversation event
    private func processConversationEvent(_ event: Event) {
        // Notify conversation manager
        NotificationCenter.default.post(
            name: .conversationEventReceived,
            object: event
        )
    }
    
    // Process message event
    private func processMessageEvent(_ event: Event) {
        // Notify message manager
        NotificationCenter.default.post(
            name: .messageEventReceived,
            object: event
        )
    }
    
    // Process file event
    private func processFileEvent(_ event: Event) {
        // Notify file manager
        NotificationCenter.default.post(
            name: .fileEventReceived,
            object: event
        )
    }
    
    // Process user event
    private func processUserEvent(_ event: Event) {
        // Notify user manager
        NotificationCenter.default.post(
            name: .userEventReceived,
            object: event
        )
    }
    
    // Process custom event
    private func processCustomEvent(_ event: Event) {
        // Notify custom event handler
        NotificationCenter.default.post(
            name: .customEventReceived,
            object: event
        )
    }
}

// Notification names
extension Notification.Name {
    static let connectionEventReceived = Notification.Name("com.openhands.mac.connectionEventReceived")
    static let authEventReceived = Notification.Name("com.openhands.mac.authEventReceived")
    static let agentEventReceived = Notification.Name("com.openhands.mac.agentEventReceived")
    static let conversationEventReceived = Notification.Name("com.openhands.mac.conversationEventReceived")
    static let messageEventReceived = Notification.Name("com.openhands.mac.messageEventReceived")
    static let fileEventReceived = Notification.Name("com.openhands.mac.fileEventReceived")
    static let userEventReceived = Notification.Name("com.openhands.mac.userEventReceived")
    static let customEventReceived = Notification.Name("com.openhands.mac.customEventReceived")
}
```

### 3.3 Event Batching and Throttling

```swift
// MARK: - Event Batcher

class EventBatcher {
    // Batch configuration
    private struct BatchConfig {
        let maxBatchSize: Int
        let maxWaitTime: TimeInterval
    }
    
    // Batched events by type
    private var batches: [EventType: [Event]] = [:]
    
    // Batch configurations by type
    private var batchConfigs: [EventType: BatchConfig] = [:]
    
    // Batch timers by type
    private var batchTimers: [EventType: Timer] = [:]
    
    // Serial queue for thread safety
    private let serialQueue = DispatchQueue(label: "com.openhands.mac.eventBatcher", qos: .userInitiated)
    
    // Event bus
    private let eventBus: EventBus
    
    init(eventBus: EventBus = .shared) {
        self.eventBus = eventBus
        
        // Set up default batch configurations
        setupDefaultBatchConfigs()
    }
    
    // Set up default batch configurations
    private func setupDefaultBatchConfigs() {
        // File events can be batched
        batchConfigs[.fileCreated] = BatchConfig(maxBatchSize: 10, maxWaitTime: 0.5)
        batchConfigs[.fileUpdated] = BatchConfig(maxBatchSize: 10, maxWaitTime: 0.5)
        batchConfigs[.fileDeleted] = BatchConfig(maxBatchSize: 10, maxWaitTime: 0.5)
        
        // User activity events can be batched
        batchConfigs[.userActivity] = BatchConfig(maxBatchSize: 5, maxWaitTime: 0.2)
    }
    
    // Add event to batch
    func addToBatch(_ event: Event) {
        serialQueue.async { [weak self] in
            guard let self = self else { return }
            
            // Check if event type supports batching
            guard let config = self.batchConfigs[event.type] else {
                // If not, post event directly
                self.eventBus.post(event)
                return
            }
            
            // Add to batch
            if self.batches[event.type] == nil {
                self.batches[event.type] = []
            }
            
            self.batches[event.type]?.append(event)
            
            // Check if batch is full
            if let batch = self.batches[event.type], batch.count >= config.maxBatchSize {
                self.flushBatch(eventType: event.type)
                return
            }
            
            // Start timer if not already running
            if self.batchTimers[event.type] == nil {
                let timer = Timer.scheduledTimer(
                    withTimeInterval: config.maxWaitTime,
                    repeats: false
                ) { [weak self] _ in
                    self?.serialQueue.async {
                        self?.flushBatch(eventType: event.type)
                    }
                }
                
                self.batchTimers[event.type] = timer
            }
        }
    }
    
    // Flush batch for event type
    private func flushBatch(eventType: EventType) {
        // Cancel timer
        batchTimers[eventType]?.invalidate()
        batchTimers[eventType] = nil
        
        // Get batch
        guard let batch = batches[eventType], !batch.isEmpty else {
            return
        }
        
        // Create batch event
        let batchEvent = createBatchEvent(eventType: eventType, events: batch)
        
        // Post batch event
        eventBus.post(batchEvent)
        
        // Clear batch
        batches[eventType] = []
    }
    
    // Create batch event
    private func createBatchEvent(eventType: EventType, events: [Event]) -> Event {
        // For file events, create a batch event
        if eventType == .fileCreated || eventType == .fileUpdated || eventType == .fileDeleted {
            return createFileBatchEvent(eventType: eventType, events: events)
        }
        
        // For user activity events, create a batch event
        if eventType == .userActivity {
            return createUserActivityBatchEvent(events: events)
        }
        
        // Default: return first event
        return events.first!
    }
    
    // Create file batch event
    private func createFileBatchEvent(eventType: EventType, events: [Event]) -> Event {
        // Extract file paths from events
        let filePaths = events.compactMap { event -> String? in
            guard let baseEvent = event as? BaseEvent,
                  let payload = baseEvent.payload,
                  let path = payload["path"]?.value as? String else {
                return nil
            }
            return path
        }
        
        // Create batch event
        return BaseEvent(
            type: eventType,
            payload: [
                "paths": filePaths,
                "count": filePaths.count,
                "isBatch": true
            ]
        )
    }
    
    // Create user activity batch event
    private func createUserActivityBatchEvent(events: [Event]) -> Event {
        // Extract user IDs and activities from events
        let activities = events.compactMap { event -> [String: Any]? in
            guard let baseEvent = event as? BaseEvent,
                  let payload = baseEvent.payload,
                  let userId = payload["user_id"]?.value as? String,
                  let activity = payload["activity"]?.value as? String else {
                return nil
            }
            return ["user_id": userId, "activity": activity, "timestamp": baseEvent.timestamp]
        }
        
        // Create batch event
        return BaseEvent(
            type: .userActivity,
            payload: [
                "activities": activities,
                "count": activities.count,
                "isBatch": true
            ]
        )
    }
    
    // Flush all batches
    func flushAllBatches() {
        serialQueue.async { [weak self] in
            guard let self = self else { return }
            
            // Flush each batch
            for eventType in self.batches.keys {
                self.flushBatch(eventType: eventType)
            }
        }
    }
}

// MARK: - Event Throttler

class EventThrottler {
    // Throttle configuration
    private struct ThrottleConfig {
        let interval: TimeInterval
        let dropIntermediate: Bool
    }
    
    // Last event time by type
    private var lastEventTimes: [EventType: Date] = [:]
    
    // Pending events by type
    private var pendingEvents: [EventType: Event] = [:]
    
    // Throttle configurations by type
    private var throttleConfigs: [EventType: ThrottleConfig] = [:]
    
    // Serial queue for thread safety
    private let serialQueue = DispatchQueue(label: "com.openhands.mac.eventThrottler", qos: .userInitiated)
    
    // Event bus
    private let eventBus: EventBus
    
    init(eventBus: EventBus = .shared) {
        self.eventBus = eventBus
        
        // Set up default throttle configurations
        setupDefaultThrottleConfigs()
    }
    
    // Set up default throttle configurations
    private func setupDefaultThrottleConfigs() {
        // Throttle file content changed events
        throttleConfigs[.fileContentChanged] = ThrottleConfig(interval: 0.5, dropIntermediate: true)
        
        // Throttle user activity events
        throttleConfigs[.userActivity] = ThrottleConfig(interval: 0.2, dropIntermediate: true)
    }
    
    // Throttle event
    func throttle(_ event: Event) {
        serialQueue.async { [weak self] in
            guard let self = self else { return }
            
            // Check if event type supports throttling
            guard let config = self.throttleConfigs[event.type] else {
                // If not, post event directly
                self.eventBus.post(event)
                return
            }
            
            let now = Date()
            
            // Check if we should throttle
            if let lastTime = self.lastEventTimes[event.type],
               now.timeIntervalSince(lastTime) < config.interval {
                
                // If we drop intermediate events, just update the pending event
                if config.dropIntermediate {
                    self.pendingEvents[event.type] = event
                } else {
                    // Otherwise, post event after delay
                    let delay = config.interval - now.timeIntervalSince(lastTime)
                    
                    DispatchQueue.main.asyncAfter(deadline: .now() + delay) { [weak self] in
                        self?.eventBus.post(event)
                    }
                }
                
                return
            }
            
            // Update last event time
            self.lastEventTimes[event.type] = now
            
            // Post event
            self.eventBus.post(event)
            
            // Schedule processing of pending event
            if config.dropIntermediate {
                DispatchQueue.main.asyncAfter(deadline: .now() + config.interval) { [weak self] in
                    self?.serialQueue.async {
                        if let pendingEvent = self?.pendingEvents[event.type] {
                            self?.lastEventTimes[event.type] = Date()
                            self?.eventBus.post(pendingEvent)
                            self?.pendingEvents[event.type] = nil
                        }
                    }
                }
            }
        }
    }
}
```

## 4. Integration with App Components

### 4.1 View Model Integration

```swift
// MARK: - View Model Integration

// Protocol for view models that handle events
protocol EventHandlingViewModel: ObservableObject {
    var eventSubscriptions: [EventSubscription] { get set }
    func registerForEvents()
    func unregisterFromEvents()
    func handleEvent(_ event: Event)
}

// Extension with default implementation
extension EventHandlingViewModel {
    func registerForEvents() {
        // Override in subclasses
    }
    
    func unregisterFromEvents() {
        for subscription in eventSubscriptions {
            subscription.cancel()
        }
        eventSubscriptions = []
    }
    
    func handleEvent(_ event: Event) {
        // Override in subclasses
    }
}

// Example conversation list view model
class ConversationListViewModel: ObservableObject, EventHandlingViewModel {
    @Published var conversations: [Conversation] = []
    @Published var isLoading = false
    @Published var error: Error?
    
    var eventSubscriptions: [EventSubscription] = []
    private let eventBus: EventBus
    
    init(eventBus: EventBus = .shared) {
        self.eventBus = eventBus
        
        registerForEvents()
        loadConversations()
    }
    
    deinit {
        unregisterFromEvents()
    }
    
    func registerForEvents() {
        // Register for conversation events
        let conversationEventTypes: [EventType] = [
            .conversationCreated,
            .conversationUpdated,
            .conversationDeleted
        ]
        
        for eventType in conversationEventTypes {
            let subscription = eventBus.register(for: eventType) { [weak self] event in
                self?.handleEvent(event)
            }
            
            eventSubscriptions.append(subscription)
        }
    }
    
    func handleEvent(_ event: Event) {
        DispatchQueue.main.async {
            switch event.type {
            case .conversationCreated:
                self.handleConversationCreated(event)
            case .conversationUpdated:
                self.handleConversationUpdated(event)
            case .conversationDeleted:
                self.handleConversationDeleted(event)
            default:
                break
            }
        }
    }
    
    private func handleConversationCreated(_ event: Event) {
        guard let baseEvent = event as? BaseEvent,
              let payload = baseEvent.payload,
              let conversationData = payload["conversation"]?.value as? [String: Any] else {
            return
        }
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: conversationData)
            let conversation = try JSONDecoder().decode(Conversation.self, from: jsonData)
            
            // Add conversation if it doesn't exist
            if !conversations.contains(where: { $0.id == conversation.id }) {
                conversations.append(conversation)
                
                // Sort conversations by last updated
                conversations.sort { $0.lastUpdated > $1.lastUpdated }
            }
        } catch {
            print("Error decoding conversation: \(error)")
        }
    }
    
    private func handleConversationUpdated(_ event: Event) {
        guard let baseEvent = event as? BaseEvent,
              let payload = baseEvent.payload,
              let conversationData = payload["conversation"]?.value as? [String: Any],
              let conversationId = conversationData["id"] as? String else {
            return
        }
        
        // Find conversation index
        guard let index = conversations.firstIndex(where: { $0.id == conversationId }) else {
            return
        }
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: conversationData)
            let updatedConversation = try JSONDecoder().decode(Conversation.self, from: jsonData)
            
            // Update conversation
            conversations[index] = updatedConversation
            
            // Sort conversations by last updated
            conversations.sort { $0.lastUpdated > $1.lastUpdated }
        } catch {
            print("Error decoding updated conversation: \(error)")
        }
    }
    
    private func handleConversationDeleted(_ event: Event) {
        guard let baseEvent = event as? BaseEvent,
              let payload = baseEvent.payload,
              let conversationId = payload["conversation_id"]?.value as? String else {
            return
        }
        
        // Remove conversation
        conversations.removeAll { $0.id == conversationId }
    }
    
    private func loadConversations() {
        isLoading = true
        error = nil
        
        // Simulate API call
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            self.conversations = [
                Conversation(
                    id: "1",
                    title: "First Conversation",
                    messages: [],
                    status: .active,
                    lastUpdated: Date(),
                    isArchived: false,
                    localDraft: nil,
                    unreadCount: 0,
                    version: 1
                ),
                Conversation(
                    id: "2",
                    title: "Second Conversation",
                    messages: [],
                    status: .active,
                    lastUpdated: Date().addingTimeInterval(-3600),
                    isArchived: false,
                    localDraft: nil,
                    unreadCount: 0,
                    version: 1
                )
            ]
            
            self.isLoading = false
        }
    }
    
    // Create new conversation
    func createConversation(title: String) {
        // Create conversation
        let conversation = Conversation(
            id: UUID().uuidString,
            title: title,
            messages: [],
            status: .active,
            lastUpdated: Date(),
            isArchived: false,
            localDraft: nil,
            unreadCount: 0,
            version: 1
        )
        
        // Create event
        let event = BaseEvent(
            type: .conversationCreated,
            payload: [
                "conversation": [
                    "id": conversation.id,
                    "title": conversation.title,
                    "status": conversation.status.rawValue,
                    "lastUpdated": conversation.lastUpdated,
                    "isArchived": conversation.isArchived,
                    "version": conversation.version
                ]
            ]
        )
        
        // Post to event bus
        eventBus.post(event)
    }
}
```

### 4.2 View Integration

```swift
// MARK: - View Integration

// SwiftUI view that observes events
struct EventObservingView<Content: View>: View {
    @StateObject private var viewModel: EventObservingViewModel
    private let content: (EventObservingViewModel) -> Content
    
    init(eventTypes: [EventType], @ViewBuilder content: @escaping (EventObservingViewModel) -> Content) {
        _viewModel = StateObject(wrappedValue: EventObservingViewModel(eventTypes: eventTypes))
        self.content = content
    }
    
    var body: some View {
        content(viewModel)
            .onDisappear {
                viewModel.unregisterFromEvents()
            }
    }
}

// View model for event observing view
class EventObservingViewModel: ObservableObject {
    @Published private(set) var lastEvent: Event?
    @Published private(set) var eventCount: [EventType: Int] = [:]
    
    private let eventBus: EventBus
    private var subscriptions: [EventSubscription] = []
    private let eventTypes: [EventType]
    
    init(eventTypes: [EventType], eventBus: EventBus = .shared) {
        self.eventTypes = eventTypes
        self.eventBus = eventBus
        
        registerForEvents()
    }
    
    deinit {
        unregisterFromEvents()
    }
    
    func registerForEvents() {
        for eventType in eventTypes {
            let subscription = eventBus.register(for: eventType) { [weak self] event in
                DispatchQueue.main.async {
                    self?.lastEvent = event
                    self?.eventCount[event.type, default: 0] += 1
                }
            }
            
            subscriptions.append(subscription)
        }
    }
    
    func unregisterFromEvents() {
        for subscription in subscriptions {
            subscription.cancel()
        }
        subscriptions = []
    }
    
    func resetCounts() {
        eventCount = [:]
    }
}

// Example usage in a view
struct ConnectionStatusView: View {
    var body: some View {
        EventObservingView(eventTypes: [
            .connectionEstablished,
            .connectionLost,
            .connectionError
        ]) { viewModel in
            HStack {
                // Connection status indicator
                Circle()
                    .fill(statusColor(for: viewModel.lastEvent))
                    .frame(width: 10, height: 10)
                
                // Status text
                Text(statusText(for: viewModel.lastEvent))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            .background(Color(NSColor.windowBackgroundColor))
            .cornerRadius(8)
        }
    }
    
    private func statusColor(for event: Event?) -> Color {
        guard let event = event as? ConnectionEvent else {
            return .gray
        }
        
        switch event.status {
        case .connected:
            return .green
        case .connecting, .reconnecting:
            return .yellow
        case .disconnected, .error:
            return .red
        }
    }
    
    private func statusText(for event: Event?) -> String {
        guard let event = event as? ConnectionEvent else {
            return "Unknown"
        }
        
        switch event.status {
        case .connected:
            return "Connected"
        case .connecting:
            return "Connecting..."
        case .reconnecting:
            return "Reconnecting..."
        case .disconnected:
            return "Disconnected"
        case .error:
            return "Error: \(event.error ?? "Unknown error")"
        }
    }
}
```

### 4.3 Service Integration

```swift
// MARK: - Service Integration

// Protocol for services that handle events
protocol EventHandlingService: AnyObject {
    var eventSubscriptions: [EventSubscription] { get set }
    func registerForEvents()
    func unregisterFromEvents()
    func handleEvent(_ event: Event)
}

// Extension with default implementation
extension EventHandlingService {
    func registerForEvents() {
        // Override in subclasses
    }
    
    func unregisterFromEvents() {
        for subscription in eventSubscriptions {
            subscription.cancel()
        }
        eventSubscriptions = []
    }
    
    func handleEvent(_ event: Event) {
        // Override in subclasses
    }
}

// Example file sync service
class FileSyncService: EventHandlingService {
    var eventSubscriptions: [EventSubscription] = []
    private let eventBus: EventBus
    
    init(eventBus: EventBus = .shared) {
        self.eventBus = eventBus
        
        registerForEvents()
    }
    
    deinit {
        unregisterFromEvents()
    }
    
    func registerForEvents() {
        // Register for file events
        let fileEventTypes: [EventType] = [
            .fileCreated,
            .fileUpdated,
            .fileDeleted,
            .fileContentChanged
        ]
        
        for eventType in fileEventTypes {
            let subscription = eventBus.register(for: eventType) { [weak self] event in
                self?.handleEvent(event)
            }
            
            eventSubscriptions.append(subscription)
        }
    }
    
    func handleEvent(_ event: Event) {
        switch event.type {
        case .fileCreated:
            handleFileCreated(event)
        case .fileUpdated:
            handleFileUpdated(event)
        case .fileDeleted:
            handleFileDeleted(event)
        case .fileContentChanged:
            handleFileContentChanged(event)
        default:
            break
        }
    }
    
    private func handleFileCreated(_ event: Event) {
        guard let baseEvent = event as? BaseEvent,
              let payload = baseEvent.payload else {
            return
        }
        
        // Check if it's a batch event
        if let isBatch = payload["isBatch"]?.value as? Bool, isBatch,
           let paths = payload["paths"]?.value as? [String] {
            // Handle batch file creation
            for path in paths {
                syncFileCreation(path: path)
            }
        } else if let path = payload["path"]?.value as? String {
            // Handle single file creation
            syncFileCreation(path: path)
        }
    }
    
    private func handleFileUpdated(_ event: Event) {
        guard let baseEvent = event as? BaseEvent,
              let payload = baseEvent.payload else {
            return
        }
        
        // Check if it's a batch event
        if let isBatch = payload["isBatch"]?.value as? Bool, isBatch,
           let paths = payload["paths"]?.value as? [String] {
            // Handle batch file update
            for path in paths {
                syncFileUpdate(path: path)
            }
        } else if let path = payload["path"]?.value as? String {
            // Handle single file update
            syncFileUpdate(path: path)
        }
    }
    
    private func handleFileDeleted(_ event: Event) {
        guard let baseEvent = event as? BaseEvent,
              let payload = baseEvent.payload else {
            return
        }
        
        // Check if it's a batch event
        if let isBatch = payload["isBatch"]?.value as? Bool, isBatch,
           let paths = payload["paths"]?.value as? [String] {
            // Handle batch file deletion
            for path in paths {
                syncFileDeletion(path: path)
            }
        } else if let path = payload["path"]?.value as? String {
            // Handle single file deletion
            syncFileDeletion(path: path)
        }
    }
    
    private func handleFileContentChanged(_ event: Event) {
        guard let baseEvent = event as? BaseEvent,
              let payload = baseEvent.payload,
              let path = payload["path"]?.value as? String else {
            return
        }
        
        // Sync file content change
        syncFileContentChange(path: path)
    }
    
    // Sync file creation with server
    private func syncFileCreation(path: String) {
        print("Syncing file creation: \(path)")
        // Implementation...
    }
    
    // Sync file update with server
    private func syncFileUpdate(path: String) {
        print("Syncing file update: \(path)")
        // Implementation...
    }
    
    // Sync file deletion with server
    private func syncFileDeletion(path: String) {
        print("Syncing file deletion: \(path)")
        // Implementation...
    }
    
    // Sync file content change with server
    private func syncFileContentChange(path: String) {
        print("Syncing file content change: \(path)")
        // Implementation...
    }
}
```

This implementation guide provides a comprehensive approach to event handling in the Mac client, covering event types, processing, routing, prioritization, and integration with app components.

---

# tasks/impl_file_explorer.md

---
name: implementation_file_explorer
type: task
agent: CodeActAgent
version: 1.0.0
triggers:
- file explorer
- file browser
---

# File Explorer Implementation

The File Explorer provides a read-only view of the workspace file system, allowing users to navigate directories and view file contents. All file operations are performed through the backend API.

## 1. Data Models

```swift
// Model representing a file or directory in the workspace
struct FileNode: Identifiable, Codable {
    var id: String { path }
    let name: String
    let path: String
    let isDirectory: Bool
    let size: Int?
    let lastModified: Date?
    var children: [FileNode]?
    var isExpanded: Bool = false
    
    enum CodingKeys: String, CodingKey {
        case name, path, isDirectory, size, lastModified, children
    }
}

// Model representing file content
struct FileContent: Codable {
    let path: String
    let content: String
    let encoding: String?
    let language: String?
}
```

## 2. API Client Methods

```swift
protocol FileExplorerService {
    func listFiles(conversationId: String, path: String?) async throws -> [FileNode]
    func getFileContent(conversationId: String, path: String) async throws -> FileContent
}

class FileExplorerServiceImpl: FileExplorerService {
    private let apiClient: APIClient
    
    init(apiClient: APIClient) {
        self.apiClient = apiClient
    }
    
    func listFiles(conversationId: String, path: String? = nil) async throws -> [FileNode] {
        var queryItems: [URLQueryItem] = []
        if let path = path {
            queryItems.append(URLQueryItem(name: "path", value: path))
        }
        
        return try await apiClient.get(
            endpoint: "api/conversations/\(conversationId)/list-files",
            queryItems: queryItems
        )
    }
    
    func getFileContent(conversationId: String, path: String) async throws -> FileContent {
        let queryItems = [URLQueryItem(name: "file", value: path)]
        
        let response: [String: String] = try await apiClient.get(
            endpoint: "api/conversations/\(conversationId)/select-file",
            queryItems: queryItems
        )
        
        // Backend returns {"code": "file_content"}
        guard let content = response["code"] else {
            throw APIError.invalidResponse
        }
        
        // Determine language from file extension
        let language = path.components(separatedBy: ".").last
        
        return FileContent(
            path: path,
            content: content,
            encoding: "utf-8",
            language: language
        )
    }
}
```

## 3. View Models

```swift
class FileExplorerViewModel: ObservableObject {
    @Published var rootNodes: [FileNode] = []
    @Published var selectedFilePath: String?
    @Published var selectedFileContent: FileContent?
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    
    private let fileService: FileExplorerService
    private let conversationId: String
    
    // Cache for file content to avoid unnecessary API calls
    private var fileContentCache: [String: FileContent] = [:]
    
    init(fileService: FileExplorerService, conversationId: String) {
        self.fileService = fileService
        self.conversationId = conversationId
    }
    
    func loadRootDirectory() async {
        await loadDirectory(path: nil)
    }
    
    func loadDirectory(path: String?) async {
        do {
            isLoading = true
            errorMessage = nil
            
            let files = try await fileService.listFiles(
                conversationId: conversationId,
                path: path
            )
            
            await MainActor.run {
                if path == nil {
                    // Root directory
                    self.rootNodes = files
                } else {
                    // Update children of a specific directory
                    self.updateDirectoryChildren(path: path!, children: files)
                }
                self.isLoading = false
            }
        } catch {
            await MainActor.run {
                self.errorMessage = "Failed to load directory: \(error.localizedDescription)"
                self.isLoading = false
            }
        }
    }
    
    func selectFile(path: String) async {
        await MainActor.run {
            self.selectedFilePath = path
            
            // Check if content is already cached
            if let cachedContent = fileContentCache[path] {
                self.selectedFileContent = cachedContent
                return
            }
            
            self.isLoading = true
            self.errorMessage = nil
        }
        
        do {
            let content = try await fileService.getFileContent(
                conversationId: conversationId,
                path: path
            )
            
            // Cache the content
            fileContentCache[path] = content
            
            await MainActor.run {
                self.selectedFileContent = content
                self.isLoading = false
            }
        } catch {
            await MainActor.run {
                self.errorMessage = "Failed to load file: \(error.localizedDescription)"
                self.isLoading = false
            }
        }
    }
    
    func toggleDirectory(path: String) async {
        // Find the directory node
        guard var node = findNode(path: path, in: rootNodes) else {
            return
        }
        
        // Toggle expansion state
        node.isExpanded = !node.isExpanded
        
        // If expanding and no children loaded yet, load them
        if node.isExpanded && (node.children == nil || node.children!.isEmpty) {
            await loadDirectory(path: path)
        }
        
        // Update the node in the tree
        updateNode(node, in: &rootNodes)
    }
    
    // Helper methods for tree manipulation
    private func updateDirectoryChildren(path: String, children: [FileNode]) {
        guard var node = findNode(path: path, in: rootNodes) else {
            return
        }
        
        node.children = children
        node.isExpanded = true
        
        updateNode(node, in: &rootNodes)
    }
    
    private func findNode(path: String, in nodes: [FileNode]) -> FileNode? {
        for var node in nodes {
            if node.path == path {
                return node
            }
            
            if node.isDirectory, let children = node.children {
                if let foundNode = findNode(path: path, in: children) {
                    return foundNode
                }
            }
        }
        
        return nil
    }
    
    private func updateNode(_ targetNode: FileNode, in nodes: inout [FileNode]) {
        for i in 0..<nodes.count {
            if nodes[i].path == targetNode.path {
                nodes[i] = targetNode
                return
            }
            
            if nodes[i].isDirectory, var children = nodes[i].children {
                updateNode(targetNode, in: &children)
                nodes[i].children = children
            }
        }
    }
}
```

## 4. UI Components

```swift
struct FileExplorerView: View {
    @ObservedObject var viewModel: FileExplorerViewModel
    
    var body: some View {
        VStack {
            if viewModel.isLoading && viewModel.rootNodes.isEmpty {
                ProgressView("Loading files...")
            } else if let errorMessage = viewModel.errorMessage, viewModel.rootNodes.isEmpty {
                Text(errorMessage)
                    .foregroundColor(.red)
                Button("Retry") {
                    Task {
                        await viewModel.loadRootDirectory()
                    }
                }
            } else {
                HSplitView {
                    // File tree view
                    List {
                        ForEach(viewModel.rootNodes) { node in
                            FileNodeView(
                                node: node,
                                selectedPath: viewModel.selectedFilePath,
                                onSelectFile: { path in
                                    Task {
                                        await viewModel.selectFile(path: path)
                                    }
                                },
                                onToggleDirectory: { path in
                                    Task {
                                        await viewModel.toggleDirectory(path: path)
                                    }
                                }
                            )
                        }
                    }
                    .frame(minWidth: 200)
                    
                    // File content view
                    if let selectedFileContent = viewModel.selectedFileContent {
                        FileContentView(fileContent: selectedFileContent)
                    } else {
                        Text("Select a file to view its contents")
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .background(Color(.textBackgroundColor))
                    }
                }
            }
        }
        .onAppear {
            Task {
                await viewModel.loadRootDirectory()
            }
        }
    }
}

struct FileNodeView: View {
    let node: FileNode
    let selectedPath: String?
    let onSelectFile: (String) -> Void
    let onToggleDirectory: (String) -> Void
    
    var body: some View {
        if node.isDirectory {
            DisclosureGroup(
                isExpanded: Binding(
                    get: { node.isExpanded },
                    set: { _ in onToggleDirectory(node.path) }
                )
            ) {
                if let children = node.children {
                    ForEach(children) { child in
                        FileNodeView(
                            node: child,
                            selectedPath: selectedPath,
                            onSelectFile: onSelectFile,
                            onToggleDirectory: onToggleDirectory
                        )
                        .padding(.leading, 10)
                    }
                }
            } label: {
                HStack {
                    Image(systemName: "folder")
                        .foregroundColor(.blue)
                    Text(node.name)
                }
            }
        } else {
            HStack {
                Image(systemName: "doc")
                    .foregroundColor(.gray)
                Text(node.name)
            }
            .contentShape(Rectangle())
            .onTapGesture {
                onSelectFile(node.path)
            }
            .background(
                selectedPath == node.path ? Color.accentColor.opacity(0.2) : Color.clear
            )
        }
    }
}

struct FileContentView: View {
    let fileContent: FileContent
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading) {
                Text(fileContent.content)
                    .font(.system(.body, design: .monospaced))
                    .padding()
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .background(Color(.textBackgroundColor))
    }
}
```

## 5. Integration with Backend

The File Explorer integrates with the backend through:

1. **REST API calls** for listing files and retrieving file content
2. **SocketIO events** for real-time updates when files change

```swift
// Example of handling file change events from SocketIO
func setupFileChangeListeners() {
    socketManager.on("oh_event") { [weak self] data in
        guard let self = self,
              let eventData = data as? [String: Any],
              let observation = eventData["observation"] as? [String: Any],
              let observationType = observation["observation"] as? String,
              observationType == "FileObservation" else {
            return
        }
        
        // File has changed, refresh if it's the currently selected file
        if let path = eventData["path"] as? String,
           path == self.selectedFilePath {
            Task {
                await self.viewModel.selectFile(path: path)
            }
        }
    }
}
```

## 6. Caching and Performance

To optimize performance, the File Explorer implementation includes:

1. **File content caching**: Store retrieved file contents to avoid redundant API calls
2. **Lazy loading**: Only load directory contents when expanded
3. **Pagination**: Support for handling large directories (to be implemented if needed)

```swift
// Example pagination implementation (if needed for large directories)
func loadDirectoryPage(path: String, page: Int, pageSize: Int) async throws -> [FileNode] {
    let queryItems = [
        URLQueryItem(name: "path", value: path),
        URLQueryItem(name: "page", value: String(page)),
        URLQueryItem(name: "pageSize", value: String(pageSize))
    ]
    
    return try await apiClient.get(
        endpoint: "api/conversations/\(conversationId)/list-files",
        queryItems: queryItems
    )
}
```

---

# tasks/impl_performance.md

# Performance Considerations for Mac Client

This document outlines implementation details for optimizing performance in the Mac client, including handling large outputs, maintaining UI responsiveness, and managing memory for long-running sessions.

## 1. Handling Large Agent Outputs

### 1.1 Chunked Message Processing

```swift
class ChunkedMessageProcessor {
    // Maximum size of a single chunk to process at once
    private let maxChunkSize = 10_000 // characters
    
    // Process large message in chunks
    func processLargeMessage(_ message: Message, handler: @escaping (MessageChunk) -> Void, completion: @escaping () -> Void) {
        let content = message.content
        
        // If content is small enough, process it directly
        if content.count <= maxChunkSize {
            let chunk = MessageChunk(
                id: message.id,
                content: content,
                isComplete: true,
                index: 0,
                totalChunks: 1
            )
            handler(chunk)
            completion()
            return
        }
        
        // Split content into chunks
        let chunks = splitIntoChunks(content: content)
        
        // Process chunks with a delay to allow UI to update
        processChunks(chunks, messageId: message.id, handler: handler, completion: completion)
    }
    
    // Split content into manageable chunks
    private func splitIntoChunks(content: String) -> [String] {
        var chunks: [String] = []
        var remainingContent = content
        
        while !remainingContent.isEmpty {
            let chunkEndIndex = remainingContent.index(
                remainingContent.startIndex,
                offsetBy: min(maxChunkSize, remainingContent.count)
            )
            
            // Try to find a natural break point (newline, space, punctuation)
            var actualEndIndex = chunkEndIndex
            if chunkEndIndex < remainingContent.endIndex {
                let searchRange = remainingContent.index(chunkEndIndex, offsetBy: -100, limitedBy: remainingContent.startIndex) ?? remainingContent.startIndex
                ..<chunkEndIndex
                
                if let newlineIndex = remainingContent.lastIndex(of: "\n", in: searchRange) {
                    actualEndIndex = remainingContent.index(after: newlineIndex)
                } else if let spaceIndex = remainingContent.lastIndex(of: " ", in: searchRange) {
                    actualEndIndex = remainingContent.index(after: spaceIndex)
                } else if let periodIndex = remainingContent.lastIndex(of: ".", in: searchRange) {
                    actualEndIndex = remainingContent.index(after: periodIndex)
                }
            }
            
            let chunk = String(remainingContent[..<actualEndIndex])
            chunks.append(chunk)
            
            remainingContent = String(remainingContent[actualEndIndex...])
        }
        
        return chunks
    }
    
    // Process chunks with a delay to allow UI to update
    private func processChunks(_ chunks: [String], messageId: String, handler: @escaping (MessageChunk) -> Void, completion: @escaping () -> Void) {
        let totalChunks = chunks.count
        
        func processNextChunk(index: Int) {
            guard index < totalChunks else {
                completion()
                return
            }
            
            let chunk = MessageChunk(
                id: messageId,
                content: chunks[index],
                isComplete: index == totalChunks - 1,
                index: index,
                totalChunks: totalChunks
            )
            
            handler(chunk)
            
            // Schedule next chunk with a small delay
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.01) {
                processNextChunk(index: index + 1)
            }
        }
        
        // Start processing chunks
        processNextChunk(index: 0)
    }
}

// Message chunk model
struct MessageChunk {
    let id: String
    let content: String
    let isComplete: Bool
    let index: Int
    let totalChunks: Int
}
```

### 1.2 Virtualized Text Display

```swift
struct VirtualizedTextView: NSViewRepresentable {
    let text: NSAttributedString
    let maxHeight: CGFloat
    
    func makeNSView(context: Context) -> NSScrollView {
        let scrollView = NSScrollView()
        scrollView.hasVerticalScroller = true
        scrollView.hasHorizontalScroller = true
        scrollView.autohidesScrollers = true
        
        let textView = NSTextView()
        textView.isEditable = false
        textView.isSelectable = true
        textView.allowsUndo = false
        textView.textContainer?.containerSize = NSSize(
            width: CGFloat.greatestFiniteMagnitude,
            height: CGFloat.greatestFiniteMagnitude
        )
        textView.textContainer?.widthTracksTextView = false
        textView.isVerticallyResizable = true
        textView.isHorizontallyResizable = true
        textView.autoresizingMask = [.width]
        
        scrollView.documentView = textView
        
        return scrollView
    }
    
    func updateNSView(_ scrollView: NSScrollView, context: Context) {
        guard let textView = scrollView.documentView as? NSTextView else {
            return
        }
        
        // Update text content
        textView.textStorage?.setAttributedString(text)
        
        // Adjust height based on content
        let contentHeight = min(textView.contentSize.height, maxHeight)
        scrollView.frame.size.height = contentHeight
    }
}

// Extension to get content size of NSTextView
extension NSTextView {
    var contentSize: CGSize {
        guard let layoutManager = layoutManager,
              let textContainer = textContainer else {
            return .zero
        }
        
        layoutManager.ensureLayout(for: textContainer)
        return layoutManager.usedRect(for: textContainer).size
    }
}
```

### 1.3 Lazy Loading for Code Blocks

```swift
class CodeBlockManager {
    private var loadedBlocks: [String: NSAttributedString] = [:]
    private let syntaxHighlighter: SyntaxHighlighter
    private let processingQueue = DispatchQueue(label: "com.openhands.mac.codeblocks", qos: .userInitiated)
    
    init(syntaxHighlighter: SyntaxHighlighter) {
        self.syntaxHighlighter = syntaxHighlighter
    }
    
    // Get or load code block
    func getCodeBlock(id: String, code: String, language: String, completion: @escaping (NSAttributedString) -> Void) {
        // Check if already loaded
        if let loadedBlock = loadedBlocks[id] {
            completion(loadedBlock)
            return
        }
        
        // Process on background queue
        processingQueue.async { [weak self] in
            guard let self = self else { return }
            
            // Apply syntax highlighting
            let highlightedCode = self.syntaxHighlighter.highlight(code: code, language: language)
            
            // Cache result
            self.loadedBlocks[id] = highlightedCode
            
            // Return on main queue
            DispatchQueue.main.async {
                completion(highlightedCode)
            }
        }
    }
    
    // Preload code blocks
    func preloadCodeBlocks(codeBlocks: [(id: String, code: String, language: String)]) {
        processingQueue.async { [weak self] in
            guard let self = self else { return }
            
            for (id, code, language) in codeBlocks {
                if self.loadedBlocks[id] == nil {
                    let highlightedCode = self.syntaxHighlighter.highlight(code: code, language: language)
                    self.loadedBlocks[id] = highlightedCode
                }
            }
        }
    }
    
    // Clear cache for blocks no longer needed
    func clearUnusedBlocks(activeBlockIds: Set<String>) {
        let keysToRemove = Set(loadedBlocks.keys).subtracting(activeBlockIds)
        
        for key in keysToRemove {
            loadedBlocks.removeValue(forKey: key)
        }
    }
}

// Lazy loading code block view
struct LazyCodeBlockView: View {
    let id: String
    let code: String
    let language: String
    
    @ObservedObject private var viewModel: CodeBlockViewModel
    
    init(id: String, code: String, language: String, codeBlockManager: CodeBlockManager) {
        self.id = id
        self.code = code
        self.language = language
        self.viewModel = CodeBlockViewModel(
            id: id,
            code: code,
            language: language,
            codeBlockManager: codeBlockManager
        )
    }
    
    var body: some View {
        VStack {
            if viewModel.isLoading {
                ProgressView()
                    .frame(maxWidth: .infinity, alignment: .center)
                    .padding()
            } else {
                CodeBlockView(attributedCode: viewModel.highlightedCode)
            }
        }
        .onAppear {
            viewModel.loadCodeBlock()
        }
    }
}

class CodeBlockViewModel: ObservableObject {
    let id: String
    let code: String
    let language: String
    
    @Published var highlightedCode: NSAttributedString = NSAttributedString()
    @Published var isLoading = true
    
    private let codeBlockManager: CodeBlockManager
    
    init(id: String, code: String, language: String, codeBlockManager: CodeBlockManager) {
        self.id = id
        self.code = code
        self.language = language
        self.codeBlockManager = codeBlockManager
    }
    
    func loadCodeBlock() {
        isLoading = true
        
        codeBlockManager.getCodeBlock(id: id, code: code, language: language) { [weak self] attributedCode in
            guard let self = self else { return }
            
            self.highlightedCode = attributedCode
            self.isLoading = false
        }
    }
}

struct CodeBlockView: NSViewRepresentable {
    let attributedCode: NSAttributedString
    
    func makeNSView(context: Context) -> NSScrollView {
        let scrollView = NSScrollView()
        scrollView.hasVerticalScroller = true
        scrollView.hasHorizontalScroller = true
        scrollView.autohidesScrollers = true
        
        let textView = NSTextView()
        textView.isEditable = false
        textView.isSelectable = true
        textView.allowsUndo = false
        textView.textContainer?.containerSize = NSSize(
            width: CGFloat.greatestFiniteMagnitude,
            height: CGFloat.greatestFiniteMagnitude
        )
        textView.textContainer?.widthTracksTextView = false
        textView.isVerticallyResizable = true
        textView.isHorizontallyResizable = true
        textView.autoresizingMask = [.width]
        
        scrollView.documentView = textView
        
        return scrollView
    }
    
    func updateNSView(_ scrollView: NSScrollView, context: Context) {
        guard let textView = scrollView.documentView as? NSTextView else {
            return
        }
        
        textView.textStorage?.setAttributedString(attributedCode)
    }
}
```

### 1.4 Image Optimization

```swift
class ImageOptimizer {
    // Maximum dimensions for displayed images
    private let maxImageDimension: CGFloat = 1200
    
    // Optimize image for display
    func optimizeImage(_ image: NSImage) -> NSImage {
        let originalSize = image.size
        
        // Check if image needs resizing
        if originalSize.width <= maxImageDimension && originalSize.height <= maxImageDimension {
            return image
        }
        
        // Calculate new size while maintaining aspect ratio
        let newSize: NSSize
        if originalSize.width > originalSize.height {
            let ratio = maxImageDimension / originalSize.width
            newSize = NSSize(width: maxImageDimension, height: originalSize.height * ratio)
        } else {
            let ratio = maxImageDimension / originalSize.height
            newSize = NSSize(width: originalSize.width * ratio, height: maxImageDimension)
        }
        
        // Create resized image
        let resizedImage = NSImage(size: newSize)
        
        resizedImage.lockFocus()
        NSGraphicsContext.current?.imageInterpolation = .high
        image.draw(in: NSRect(origin: .zero, size: newSize))
        resizedImage.unlockFocus()
        
        return resizedImage
    }
    
    // Load and optimize image from URL
    func loadAndOptimizeImage(from url: URL, completion: @escaping (NSImage?) -> Void) {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }
            
            if let image = NSImage(contentsOf: url) {
                let optimizedImage = self.optimizeImage(image)
                
                DispatchQueue.main.async {
                    completion(optimizedImage)
                }
            } else {
                DispatchQueue.main.async {
                    completion(nil)
                }
            }
        }
    }
    
    // Load and optimize image from data
    func loadAndOptimizeImage(from data: Data, completion: @escaping (NSImage?) -> Void) {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }
            
            if let image = NSImage(data: data) {
                let optimizedImage = self.optimizeImage(image)
                
                DispatchQueue.main.async {
                    completion(optimizedImage)
                }
            } else {
                DispatchQueue.main.async {
                    completion(nil)
                }
            }
        }
    }
}

// Lazy loading image view
struct LazyImageView: View {
    let url: URL
    
    @StateObject private var viewModel = LazyImageViewModel()
    
    var body: some View {
        Group {
            if let image = viewModel.image {
                Image(nsImage: image)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
            } else {
                ProgressView()
                    .frame(width: 200, height: 150)
            }
        }
        .onAppear {
            viewModel.loadImage(from: url)
        }
    }
}

class LazyImageViewModel: ObservableObject {
    @Published var image: NSImage?
    
    private let imageOptimizer = ImageOptimizer()
    
    func loadImage(from url: URL) {
        imageOptimizer.loadAndOptimizeImage(from: url) { [weak self] image in
            self?.image = image
        }
    }
}
```

## 2. UI Responsiveness During Heavy Operations

### 2.1 Background Processing Manager

```swift
class BackgroundProcessingManager {
    private let processingQueue = DispatchQueue(label: "com.openhands.mac.backgroundProcessing", qos: .userInitiated, attributes: .concurrent)
    private let serialQueue = DispatchQueue(label: "com.openhands.mac.serialProcessing", qos: .userInitiated)
    
    // Run task in background
    func runInBackground<T>(task: @escaping () -> T, completion: @escaping (T) -> Void) {
        processingQueue.async { [weak self] in
            guard let self = self else { return }
            
            let result = task()
            
            DispatchQueue.main.async {
                completion(result)
            }
        }
    }
    
    // Run tasks in sequence
    func runSequentially<T>(tasks: [() -> T], completion: @escaping ([T]) -> Void) {
        serialQueue.async { [weak self] in
            guard let self = self else { return }
            
            let results = tasks.map { $0() }
            
            DispatchQueue.main.async {
                completion(results)
            }
        }
    }
    
    // Run task with progress reporting
    func runWithProgress<T>(
        task: @escaping (@escaping (Double) -> Void) -> T,
        progressHandler: @escaping (Double) -> Void,
        completion: @escaping (T) -> Void
    ) {
        processingQueue.async { [weak self] in
            guard let self = self else { return }
            
            let result = task { progress in
                DispatchQueue.main.async {
                    progressHandler(progress)
                }
            }
            
            DispatchQueue.main.async {
                completion(result)
            }
        }
    }
    
    // Cancel all operations
    func cancelAllOperations() {
        // Not directly possible with GCD, but we can use a flag
        // to signal cancellation to long-running operations
        NotificationCenter.default.post(name: .cancelBackgroundOperations, object: nil)
    }
}

extension Notification.Name {
    static let cancelBackgroundOperations = Notification.Name("com.openhands.mac.cancelBackgroundOperations")
}
```

### 2.2 UI Throttling

```swift
class UIUpdateThrottler {
    private var lastUpdateTime: Date = Date.distantPast
    private var pendingUpdate: (() -> Void)?
    private var updateTimer: Timer?
    private let minimumInterval: TimeInterval
    
    init(minimumInterval: TimeInterval = 0.1) {
        self.minimumInterval = minimumInterval
    }
    
    // Schedule UI update with throttling
    func scheduleUpdate(_ update: @escaping () -> Void) {
        let now = Date()
        let timeSinceLastUpdate = now.timeIntervalSince(lastUpdateTime)
        
        // Cancel any pending update
        pendingUpdate = update
        updateTimer?.invalidate()
        
        if timeSinceLastUpdate >= minimumInterval {
            // Update immediately
            performUpdate()
        } else {
            // Schedule update after delay
            let delay = minimumInterval - timeSinceLastUpdate
            updateTimer = Timer.scheduledTimer(withTimeInterval: delay, repeats: false) { [weak self] _ in
                self?.performUpdate()
            }
        }
    }
    
    private func performUpdate() {
        guard let update = pendingUpdate else {
            return
        }
        
        // Perform the update
        update()
        
        // Update timestamp
        lastUpdateTime = Date()
        pendingUpdate = nil
    }
    
    // Cancel pending update
    func cancelPendingUpdate() {
        updateTimer?.invalidate()
        updateTimer = nil
        pendingUpdate = nil
    }
}

// Example usage in a view model
class ThrottledViewModel: ObservableObject {
    @Published var data: [String] = []
    
    private let throttler = UIUpdateThrottler(minimumInterval: 0.1)
    private var internalData: [String] = []
    
    // Add items with throttled UI updates
    func addItems(_ newItems: [String]) {
        // Update internal data immediately
        internalData.append(contentsOf: newItems)
        
        // Schedule throttled UI update
        throttler.scheduleUpdate { [weak self] in
            guard let self = self else { return }
            
            // Update published property on main thread
            DispatchQueue.main.async {
                self.data = self.internalData
            }
        }
    }
}
```

### 2.3 Progressive Loading Indicators

```swift
struct ProgressiveLoadingView<Content: View>: View {
    let isLoading: Bool
    let progress: Double
    let content: () -> Content
    
    @State private var showingProgress = false
    
    var body: some View {
        ZStack {
            // Content
            content()
                .opacity(isLoading ? 0.5 : 1.0)
                .disabled(isLoading)
            
            // Loading indicator
            if isLoading {
                VStack {
                    if progress > 0 && progress < 1.0 {
                        // Show progress bar for known progress
                        ProgressView(value: progress)
                            .progressViewStyle(LinearProgressViewStyle())
                            .frame(width: 200)
                        
                        Text("\(Int(progress * 100))%")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    } else if showingProgress {
                        // Show indeterminate spinner for unknown progress
                        ProgressView()
                            .scaleEffect(1.5)
                    }
                }
                .padding()
                .background(Color(NSColor.windowBackgroundColor).opacity(0.8))
                .cornerRadius(10)
                .shadow(radius: 5)
            }
        }
        .onAppear {
            // Delay showing progress indicator for quick operations
            if isLoading {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                    if isLoading {
                        showingProgress = true
                    }
                }
            }
        }
        .onChange(of: isLoading) { newValue in
            if !newValue {
                showingProgress = false
            } else {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                    if isLoading {
                        showingProgress = true
                    }
                }
            }
        }
    }
}

// Example usage
struct ContentLoadingView: View {
    @StateObject private var viewModel = ContentViewModel()
    
    var body: some View {
        ProgressiveLoadingView(
            isLoading: viewModel.isLoading,
            progress: viewModel.loadingProgress
        ) {
            List(viewModel.items, id: \.id) { item in
                Text(item.title)
            }
        }
        .onAppear {
            viewModel.loadData()
        }
    }
}

class ContentViewModel: ObservableObject {
    @Published var items: [Item] = []
    @Published var isLoading = false
    @Published var loadingProgress = 0.0
    
    func loadData() {
        isLoading = true
        loadingProgress = 0.0
        
        // Simulate progressive loading
        let totalItems = 100
        var loadedItems = 0
        
        func loadNextBatch() {
            guard loadedItems < totalItems else {
                DispatchQueue.main.async {
                    self.isLoading = false
                    self.loadingProgress = 1.0
                }
                return
            }
            
            // Load a batch of items
            let batchSize = 10
            let newItems = (0..<batchSize).map { i in
                Item(id: UUID().uuidString, title: "Item \(loadedItems + i)")
            }
            
            loadedItems += batchSize
            
            // Update progress
            let progress = Double(loadedItems) / Double(totalItems)
            
            DispatchQueue.main.async {
                self.items.append(contentsOf: newItems)
                self.loadingProgress = progress
                
                // Schedule next batch
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                    loadNextBatch()
                }
            }
        }
        
        // Start loading
        loadNextBatch()
    }
}

struct Item {
    let id: String
    let title: String
}
```

### 2.4 Operation Cancellation

```swift
class CancellableOperation<T> {
    private var isCancelled = false
    private var isExecuting = false
    private var task: ((@escaping (Double) -> Void, _ isCancelled: () -> Bool) -> T)?
    private var progressHandler: ((Double) -> Void)?
    private var completionHandler: ((Result<T, Error>) -> Void)?
    
    init(task: @escaping (@escaping (Double) -> Void, _ isCancelled: () -> Bool) -> T) {
        self.task = task
    }
    
    // Set progress handler
    func onProgress(_ handler: @escaping (Double) -> Void) -> CancellableOperation<T> {
        progressHandler = handler
        return self
    }
    
    // Set completion handler
    func onCompletion(_ handler: @escaping (Result<T, Error>) -> Void) -> CancellableOperation<T> {
        completionHandler = handler
        return self
    }
    
    // Start the operation
    func start() {
        guard !isExecuting && !isCancelled else {
            return
        }
        
        isExecuting = true
        
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self, let task = self.task else {
                return
            }
            
            do {
                // Execute task with progress reporting and cancellation check
                let result = task(
                    { [weak self] progress in
                        guard let self = self else { return }
                        
                        DispatchQueue.main.async {
                            self.progressHandler?(progress)
                        }
                    },
                    { [weak self] in
                        return self?.isCancelled ?? true
                    }
                )
                
                DispatchQueue.main.async { [weak self] in
                    guard let self = self, !self.isCancelled else { return }
                    
                    self.completionHandler?(.success(result))
                    self.isExecuting = false
                    self.task = nil
                }
            } catch {
                DispatchQueue.main.async { [weak self] in
                    guard let self = self else { return }
                    
                    self.completionHandler?(.failure(error))
                    self.isExecuting = false
                    self.task = nil
                }
            }
        }
    }
    
    // Cancel the operation
    func cancel() {
        isCancelled = true
        
        if !isExecuting {
            task = nil
            completionHandler?(.failure(NSError(domain: "CancellableOperation", code: -999, userInfo: [
                NSLocalizedDescriptionKey: "Operation was cancelled"
            ])))
        }
    }
}

// Example usage
class SearchViewModel: ObservableObject {
    @Published var results: [SearchResult] = []
    @Published var isSearching = false
    @Published var progress = 0.0
    
    private var currentOperation: CancellableOperation<[SearchResult]>?
    
    func search(query: String) {
        // Cancel any ongoing search
        cancelSearch()
        
        // Start new search
        isSearching = true
        progress = 0.0
        
        currentOperation = CancellableOperation<[SearchResult]> { progressHandler, isCancelled in
            // Simulate search operation
            var searchResults: [SearchResult] = []
            
            for i in 0..<100 {
                // Check for cancellation
                if isCancelled() {
                    throw NSError(domain: "SearchViewModel", code: -999, userInfo: [
                        NSLocalizedDescriptionKey: "Search was cancelled"
                    ])
                }
                
                // Simulate work
                Thread.sleep(forTimeInterval: 0.02)
                
                // Add result
                searchResults.append(SearchResult(id: UUID().uuidString, title: "Result \(i) for \(query)"))
                
                // Report progress
                let progress = Double(i + 1) / 100.0
                progressHandler(progress)
            }
            
            return searchResults
        }
        .onProgress { [weak self] progress in
            self?.progress = progress
        }
        .onCompletion { [weak self] result in
            guard let self = self else { return }
            
            self.isSearching = false
            
            switch result {
            case .success(let results):
                self.results = results
            case .failure(let error):
                print("Search failed: \(error)")
                self.results = []
            }
            
            self.currentOperation = nil
        }
        
        currentOperation?.start()
    }
    
    func cancelSearch() {
        currentOperation?.cancel()
        currentOperation = nil
        isSearching = false
    }
}

struct SearchResult {
    let id: String
    let title: String
}
```

## 3. Memory Management for Long-Running Sessions

### 3.1 Memory Monitor

```swift
class MemoryMonitor {
    // Memory usage thresholds
    private let warningThreshold: Double = 0.7 // 70% of available memory
    private let criticalThreshold: Double = 0.85 // 85% of available memory
    
    private var timer: Timer?
    private var observers: [UUID: (MemoryStatus) -> Void] = [:]
    
    init() {
        // Start monitoring
        startMonitoring()
    }
    
    deinit {
        stopMonitoring()
    }
    
    // Start periodic memory monitoring
    func startMonitoring(interval: TimeInterval = 5.0) {
        stopMonitoring()
        
        timer = Timer.scheduledTimer(withTimeInterval: interval, repeats: true) { [weak self] _ in
            self?.checkMemoryUsage()
        }
    }
    
    // Stop monitoring
    func stopMonitoring() {
        timer?.invalidate()
        timer = nil
    }
    
    // Add observer for memory status changes
    func addObserver(_ observer: @escaping (MemoryStatus) -> Void) -> UUID {
        let id = UUID()
        observers[id] = observer
        
        // Immediately notify with current status
        let status = currentMemoryStatus()
        observer(status)
        
        return id
    }
    
    // Remove observer
    func removeObserver(id: UUID) {
        observers.removeValue(forKey: id)
    }
    
    // Check memory usage and notify observers if needed
    private func checkMemoryUsage() {
        let status = currentMemoryStatus()
        
        // Notify all observers
        for observer in observers.values {
            observer(status)
        }
        
        // Take action based on memory status
        switch status.level {
        case .critical:
            NotificationCenter.default.post(name: .memoryStatusCritical, object: status)
        case .warning:
            NotificationCenter.default.post(name: .memoryStatusWarning, object: status)
        case .normal:
            break
        }
    }
    
    // Get current memory status
    func currentMemoryStatus() -> MemoryStatus {
        let memoryUsage = getMemoryUsage()
        
        let level: MemoryLevel
        if memoryUsage.usedPercentage >= criticalThreshold {
            level = .critical
        } else if memoryUsage.usedPercentage >= warningThreshold {
            level = .warning
        } else {
            level = .normal
        }
        
        return MemoryStatus(
            level: level,
            usedMemory: memoryUsage.used,
            totalMemory: memoryUsage.total,
            usedPercentage: memoryUsage.usedPercentage
        )
    }
    
    // Get memory usage information
    private func getMemoryUsage() -> (used: UInt64, total: UInt64, usedPercentage: Double) {
        var taskInfo = task_vm_info_data_t()
        var count = mach_msg_type_number_t(MemoryLayout<task_vm_info>.size) / 4
        let result: kern_return_t = withUnsafeMutablePointer(to: &taskInfo) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_, task_flavor_t(TASK_VM_INFO), $0, &count)
            }
        }
        
        var used: UInt64 = 0
        if result == KERN_SUCCESS {
            used = UInt64(taskInfo.phys_footprint)
        }
        
        // Get total physical memory
        let total = ProcessInfo.processInfo.physicalMemory
        
        // Calculate percentage
        let percentage = Double(used) / Double(total)
        
        return (used, total, percentage)
    }
}

// Memory status model
struct MemoryStatus {
    let level: MemoryLevel
    let usedMemory: UInt64
    let totalMemory: UInt64
    let usedPercentage: Double
    
    var formattedUsedMemory: String {
        return formatBytes(usedMemory)
    }
    
    var formattedTotalMemory: String {
        return formatBytes(totalMemory)
    }
    
    var formattedPercentage: String {
        return String(format: "%.1f%%", usedPercentage * 100)
    }
    
    private func formatBytes(_ bytes: UInt64) -> String {
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = [.useAll]
        formatter.countStyle = .file
        return formatter.string(fromByteCount: Int64(bytes))
    }
}

enum MemoryLevel {
    case normal
    case warning
    case critical
}

extension Notification.Name {
    static let memoryStatusWarning = Notification.Name("com.openhands.mac.memoryStatusWarning")
    static let memoryStatusCritical = Notification.Name("com.openhands.mac.memoryStatusCritical")
}
```

### 3.2 Cache Manager

```swift
class CacheManager {
    // Singleton instance
    static let shared = CacheManager()
    
    // Memory cache
    private let memoryCache = NSCache<NSString, AnyObject>()
    
    // Disk cache
    private let fileManager = FileManager.default
    private let cacheDirectory: URL
    
    // Memory monitor
    private let memoryMonitor = MemoryMonitor()
    private var memoryMonitorId: UUID?
    
    private init() {
        // Set up cache directory
        if let cachesDirectory = fileManager.urls(for: .cachesDirectory, in: .userDomainMask).first {
            cacheDirectory = cachesDirectory.appendingPathComponent("com.openhands.mac.cache")
            
            // Create directory if it doesn't exist
            if !fileManager.fileExists(atPath: cacheDirectory.path) {
                try? fileManager.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)
            }
        } else {
            // Fallback to temporary directory
            cacheDirectory = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("com.openhands.mac.cache")
        }
        
        // Configure memory cache
        memoryCache.name = "com.openhands.mac.memoryCache"
        memoryCache.countLimit = 100
        
        // Set up memory monitoring
        setupMemoryMonitoring()
    }
    
    // Set up memory monitoring
    private func setupMemoryMonitoring() {
        memoryMonitorId = memoryMonitor.addObserver { [weak self] status in
            guard let self = self else { return }
            
            // Adjust cache size based on memory pressure
            switch status.level {
            case .normal:
                self.memoryCache.countLimit = 100
            case .warning:
                self.memoryCache.countLimit = 50
                self.trimMemoryCache()
            case .critical:
                self.memoryCache.countLimit = 20
                self.clearMemoryCache()
            }
        }
    }
    
    // MARK: - Memory Cache
    
    // Store item in memory cache
    func storeInMemory<T: AnyObject>(object: T, forKey key: String) {
        memoryCache.setObject(object, forKey: key as NSString)
    }
    
    // Retrieve item from memory cache
    func retrieveFromMemory<T: AnyObject>(forKey key: String) -> T? {
        return memoryCache.object(forKey: key as NSString) as? T
    }
    
    // Remove item from memory cache
    func removeFromMemory(forKey key: String) {
        memoryCache.removeObject(forKey: key as NSString)
    }
    
    // Clear memory cache
    func clearMemoryCache() {
        memoryCache.removeAllObjects()
    }
    
    // Trim memory cache to reduce size
    func trimMemoryCache() {
        // This is a simple implementation that just removes half the objects
        // A more sophisticated approach would use access time or priority
        let allKeys = getAllMemoryCacheKeys()
        let keysToRemove = Array(allKeys.prefix(allKeys.count / 2))
        
        for key in keysToRemove {
            memoryCache.removeObject(forKey: key as NSString)
        }
    }
    
    // Get all keys in memory cache
    private func getAllMemoryCacheKeys() -> [String] {
        // NSCache doesn't provide a way to enumerate keys
        // This is a workaround using associated objects
        var keys: [String] = []
        
        // This is a placeholder - in a real implementation,
        // you would need to track keys separately
        return keys
    }
    
    // MARK: - Disk Cache
    
    // Store data in disk cache
    func storeOnDisk(data: Data, forKey key: String) {
        let fileURL = cacheDirectory.appendingPathComponent(key)
        
        do {
            try data.write(to: fileURL)
        } catch {
            print("Failed to write to disk cache: \(error)")
        }
    }
    
    // Retrieve data from disk cache
    func retrieveFromDisk(forKey key: String) -> Data? {
        let fileURL = cacheDirectory.appendingPathComponent(key)
        
        guard fileManager.fileExists(atPath: fileURL.path) else {
            return nil
        }
        
        do {
            return try Data(contentsOf: fileURL)
        } catch {
            print("Failed to read from disk cache: \(error)")
            return nil
        }
    }
    
    // Remove item from disk cache
    func removeFromDisk(forKey key: String) {
        let fileURL = cacheDirectory.appendingPathComponent(key)
        
        guard fileManager.fileExists(atPath: fileURL.path) else {
            return
        }
        
        do {
            try fileManager.removeItem(at: fileURL)
        } catch {
            print("Failed to remove from disk cache: \(error)")
        }
    }
    
    // Clear disk cache
    func clearDiskCache() {
        do {
            let contents = try fileManager.contentsOfDirectory(at: cacheDirectory, includingPropertiesForKeys: nil)
            
            for fileURL in contents {
                try fileManager.removeItem(at: fileURL)
            }
        } catch {
            print("Failed to clear disk cache: \(error)")
        }
    }
    
    // Get disk cache size
    func getDiskCacheSize() -> UInt64 {
        do {
            let contents = try fileManager.contentsOfDirectory(at: cacheDirectory, includingPropertiesForKeys: [.fileSizeKey])
            
            return contents.reduce(0) { total, fileURL in
                guard let attributes = try? fileManager.attributesOfItem(atPath: fileURL.path),
                      let size = attributes[.size] as? UInt64 else {
                    return total
                }
                
                return total + size
            }
        } catch {
            print("Failed to get disk cache size: \(error)")
            return 0
        }
    }
    
    // Trim disk cache to target size
    func trimDiskCache(toSize targetSize: UInt64) {
        do {
            let contents = try fileManager.contentsOfDirectory(
                at: cacheDirectory,
                includingPropertiesForKeys: [.fileSizeKey, .creationDateKey]
            )
            
            // Sort by creation date (oldest first)
            let sortedContents = try contents.sorted { fileURL1, fileURL2 in
                let attributes1 = try fileURL1.resourceValues(forKeys: [.creationDateKey])
                let attributes2 = try fileURL2.resourceValues(forKeys: [.creationDateKey])
                
                guard let date1 = attributes1.creationDate,
                      let date2 = attributes2.creationDate else {
                    return false
                }
                
                return date1 < date2
            }
            
            var currentSize = getDiskCacheSize()
            var index = 0
            
            // Remove oldest files until we're under target size
            while currentSize > targetSize && index < sortedContents.count {
                let fileURL = sortedContents[index]
                
                guard let attributes = try? fileManager.attributesOfItem(atPath: fileURL.path),
                      let size = attributes[.size] as? UInt64 else {
                    index += 1
                    continue
                }
                
                try fileManager.removeItem(at: fileURL)
                currentSize -= size
                index += 1
            }
        } catch {
            print("Failed to trim disk cache: \(error)")
        }
    }
}
```

### 3.3 Conversation History Manager

```swift
class ConversationHistoryManager {
    private let stateStore: StateStore
    private let cacheManager: CacheManager
    
    // Maximum number of conversations to keep in memory
    private let maxActiveConversations = 5
    
    init(stateStore: StateStore, cacheManager: CacheManager = CacheManager.shared) {
        self.stateStore = stateStore
        self.cacheManager = cacheManager
        
        // Set up memory pressure handling
        setupMemoryPressureHandling()
    }
    
    // Set up memory pressure handling
    private func setupMemoryPressureHandling() {
        NotificationCenter.default.addObserver(
            forName: .memoryStatusWarning,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.handleMemoryWarning()
        }
        
        NotificationCenter.default.addObserver(
            forName: .memoryStatusCritical,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.handleMemoryCritical()
        }
    }
    
    // Handle memory warning
    private func handleMemoryWarning() {
        // Archive older conversations
        archiveOlderConversations()
    }
    
    // Handle critical memory situation
    private func handleMemoryCritical() {
        // Archive all but current conversation
        archiveAllButCurrentConversation()
    }
    
    // Archive older conversations to disk
    func archiveOlderConversations() {
        stateStore.updateState { state in
            // Keep track of current conversation
            let currentId = state.currentConversationId
            
            // Sort conversations by last updated (newest first)
            let sortedConversations = state.conversations.sorted { $0.lastUpdated > $1.lastUpdated }
            
            // Keep the most recent conversations and current conversation in memory
            var conversationsToKeep: [Conversation] = []
            var conversationsToArchive: [Conversation] = []
            
            var keptCount = 0
            
            for conversation in sortedConversations {
                if keptCount < maxActiveConversations || conversation.id == currentId {
                    conversationsToKeep.append(conversation)
                    keptCount += 1
                } else {
                    conversationsToArchive.append(conversation)
                }
            }
            
            // Archive conversations
            for conversation in conversationsToArchive {
                archiveConversation(conversation)
            }
            
            // Update state with kept conversations
            state.conversations = conversationsToKeep
        }
    }
    
    // Archive all but current conversation
    func archiveAllButCurrentConversation() {
        stateStore.updateState { state in
            // Keep only current conversation in memory
            guard let currentId = state.currentConversationId else {
                return
            }
            
            let conversationsToKeep = state.conversations.filter { $0.id == currentId }
            let conversationsToArchive = state.conversations.filter { $0.id != currentId }
            
            // Archive conversations
            for conversation in conversationsToArchive {
                archiveConversation(conversation)
            }
            
            // Update state with kept conversations
            state.conversations = conversationsToKeep
        }
    }
    
    // Archive a conversation to disk
    private func archiveConversation(_ conversation: Conversation) {
        do {
            let encoder = JSONEncoder()
            let data = try encoder.encode(conversation)
            
            // Store in disk cache
            cacheManager.storeOnDisk(data: data, forKey: "conversation_\(conversation.id)")
        } catch {
            print("Failed to archive conversation: \(error)")
        }
    }
    
    // Load a conversation from disk
    func loadConversation(id: String, completion: @escaping (Conversation?) -> Void) {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            guard let self = self else { return }
            
            if let data = self.cacheManager.retrieveFromDisk(forKey: "conversation_\(id)") {
                do {
                    let decoder = JSONDecoder()
                    let conversation = try decoder.decode(Conversation.self, from: data)
                    
                    DispatchQueue.main.async {
                        completion(conversation)
                    }
                } catch {
                    print("Failed to decode conversation: \(error)")
                    DispatchQueue.main.async {
                        completion(nil)
                    }
                }
            } else {
                DispatchQueue.main.async {
                    completion(nil)
                }
            }
        }
    }
    
    // Restore a conversation to memory
    func restoreConversation(id: String, completion: @escaping (Bool) -> Void) {
        loadConversation(id: id) { [weak self] conversation in
            guard let self = self, let conversation = conversation else {
                completion(false)
                return
            }
            
            // Add conversation to state
            self.stateStore.updateState { state in
                // Check if conversation already exists
                if !state.conversations.contains(where: { $0.id == id }) {
                    state.conversations.append(conversation)
                }
            }
            
            completion(true)
        }
    }
    
    // Purge old conversations from disk
    func purgeOldConversations(olderThan date: Date) {
        DispatchQueue.global(qos: .background).async { [weak self] in
            guard let self = self else { return }
            
            // Get all conversation IDs from disk
            let conversationKeys = self.getAllConversationKeysFromDisk()
            
            for key in conversationKeys {
                if let data = self.cacheManager.retrieveFromDisk(forKey: key) {
                    do {
                        let decoder = JSONDecoder()
                        let conversation = try decoder.decode(Conversation.self, from: data)
                        
                        // Check if conversation is older than specified date
                        if conversation.lastUpdated < date {
                            self.cacheManager.removeFromDisk(forKey: key)
                        }
                    } catch {
                        print("Failed to decode conversation for purging: \(error)")
                    }
                }
            }
        }
    }
    
    // Get all conversation keys from disk
    private func getAllConversationKeysFromDisk() -> [String] {
        do {
            let contents = try FileManager.default.contentsOfDirectory(at: cacheManager.cacheDirectory, includingPropertiesForKeys: nil)
            
            return contents
                .map { $0.lastPathComponent }
                .filter { $0.hasPrefix("conversation_") }
        } catch {
            print("Failed to get conversation keys: \(error)")
            return []
        }
    }
}

// Extension to access cache directory
extension CacheManager {
    var cacheDirectory: URL {
        if let cachesDirectory = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first {
            return cachesDirectory.appendingPathComponent("com.openhands.mac.cache")
        } else {
            return URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("com.openhands.mac.cache")
        }
    }
}
```

### 3.4 Memory-Efficient Collection Views

```swift
// Memory-efficient list for large datasets
struct LazyLoadingList<Data, Content>: View where Data: RandomAccessCollection, Data.Element: Identifiable, Content: View {
    let data: Data
    let content: (Data.Element) -> Content
    
    // Pagination settings
    private let pageSize: Int
    @State private var loadedPages: Set<Int> = [0] // Start with first page
    
    init(data: Data, pageSize: Int = 20, @ViewBuilder content: @escaping (Data.Element) -> Content) {
        self.data = data
        self.pageSize = pageSize
        self.content = content
    }
    
    var body: some View {
        List {
            ForEach(Array(data.enumerated()), id: \.element.id) { index, element in
                content(element)
                    .onAppear {
                        // Calculate page and load if needed
                        let page = index / pageSize
                        if !loadedPages.contains(page) {
                            loadedPages.insert(page)
                        }
                        
                        // Preload next page
                        let nextPage = page + 1
                        if index % pageSize == pageSize - 3 && !loadedPages.contains(nextPage) {
                            loadedPages.insert(nextPage)
                        }
                    }
                    .id(element.id) // Ensure view is recreated when element changes
            }
        }
        .onDisappear {
            // Keep only current and adjacent pages in memory
            let currentPages = loadedPages
            loadedPages = Set()
            
            if let minPage = currentPages.min(), let maxPage = currentPages.max() {
                // Keep only a window of pages
                let pagesToKeep = max(3, min(5, maxPage - minPage + 1))
                let startPage = max(0, maxPage - pagesToKeep + 1)
                
                for page in startPage...maxPage {
                    loadedPages.insert(page)
                }
            }
        }
    }
}

// Memory-efficient grid for large datasets
struct LazyLoadingGrid<Data, Content>: View where Data: RandomAccessCollection, Data.Element: Identifiable, Content: View {
    let data: Data
    let columns: Int
    let content: (Data.Element) -> Content
    
    // Pagination settings
    private let pageSize: Int
    @State private var loadedPages: Set<Int> = [0] // Start with first page
    
    init(data: Data, columns: Int, pageSize: Int = 50, @ViewBuilder content: @escaping (Data.Element) -> Content) {
        self.data = data
        self.columns = columns
        self.pageSize = pageSize
        self.content = content
    }
    
    var body: some View {
        ScrollView {
            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: columns)) {
                ForEach(Array(data.enumerated()), id: \.element.id) { index, element in
                    content(element)
                        .onAppear {
                            // Calculate page and load if needed
                            let page = index / pageSize
                            if !loadedPages.contains(page) {
                                loadedPages.insert(page)
                            }
                            
                            // Preload next page
                            let nextPage = page + 1
                            if index % pageSize == pageSize - 5 && !loadedPages.contains(nextPage) {
                                loadedPages.insert(nextPage)
                            }
                        }
                        .id(element.id) // Ensure view is recreated when element changes
                }
            }
            .padding()
        }
        .onDisappear {
            // Keep only current and adjacent pages in memory
            let currentPages = loadedPages
            loadedPages = Set()
            
            if let minPage = currentPages.min(), let maxPage = currentPages.max() {
                // Keep only a window of pages
                let pagesToKeep = max(3, min(5, maxPage - minPage + 1))
                let startPage = max(0, maxPage - pagesToKeep + 1)
                
                for page in startPage...maxPage {
                    loadedPages.insert(page)
                }
            }
        }
    }
}

// Example usage
struct GalleryView: View {
    @StateObject private var viewModel = GalleryViewModel()
    
    var body: some View {
        LazyLoadingGrid(data: viewModel.images, columns: 3) { image in
            AsyncImage(url: image.url) { phase in
                switch phase {
                case .empty:
                    ProgressView()
                case .success(let image):
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: 100, height: 100)
                        .clipped()
                case .failure:
                    Image(systemName: "photo")
                        .frame(width: 100, height: 100)
                @unknown default:
                    EmptyView()
                }
            }
            .frame(width: 100, height: 100)
        }
    }
}

class GalleryViewModel: ObservableObject {
    @Published var images: [ImageItem] = []
    
    init() {
        // Generate sample data
        images = (0..<1000).map { i in
            ImageItem(
                id: UUID().uuidString,
                url: URL(string: "https://picsum.photos/id/\(i % 100)/100")!
            )
        }
    }
}

struct ImageItem: Identifiable {
    let id: String
    let url: URL
}
```

This implementation guide provides a comprehensive approach to performance optimization in the Mac client, covering large output handling, UI responsiveness, and memory management for long-running sessions.

---

# tasks/impl_socket_io.md

# Socket.IO Implementation Guide for Mac Client

This document outlines the implementation details for Socket.IO in the Mac client, including connection management, error handling, and event processing.

## 1. Socket.IO Connection Setup

### 1.1 Basic Connection Configuration

```swift
import SocketIO

class SocketManager {
    private let manager: SocketManager
    private var socket: SocketIOClient
    private var lastEventId: Int = -1
    private var conversationId: String
    
    init(conversationId: String) {
        self.conversationId = conversationId
        
        // Configure the Socket.IO manager
        let url = URL(string: AppConfig.backendBaseURL)!
        manager = SocketManager(socketURL: url, config: [
            .log(true),
            .compress,
            .forceWebsockets(true),
            .reconnects(true),
            .reconnectAttempts(10),
            .reconnectWait(5),
            .connectParams(["conversation_id": conversationId, 
                           "latest_event_id": lastEventId])
        ])
        
        socket = manager.defaultSocket
        setupSocketHandlers()
    }
    
    private func setupSocketHandlers() {
        // Connection handlers
        socket.on(clientEvent: .connect) { [weak self] _, _ in
            self?.handleConnect()
        }
        
        socket.on(clientEvent: .disconnect) { [weak self] data, _ in
            self?.handleDisconnect(data: data)
        }
        
        socket.on(clientEvent: .error) { [weak self] data, _ in
            self?.handleError(data: data)
        }
        
        // Event handlers
        socket.on("oh_event") { [weak self] data, _ in
            self?.handleEvent(data: data)
        }
    }
    
    func connect() {
        socket.connect()
    }
    
    func disconnect() {
        socket.disconnect()
    }
}
```

### 1.2 Connection Status Management

```swift
enum ConnectionStatus {
    case connected
    case disconnected
    case connecting
    case error(String)
}

class SocketManager {
    // ... previous code ...
    
    @Published private(set) var connectionStatus: ConnectionStatus = .disconnected
    
    private func handleConnect() {
        connectionStatus = .connected
        NotificationCenter.default.post(name: .socketConnected, object: nil)
    }
    
    private func handleDisconnect(data: [Any]) {
        connectionStatus = .disconnected
        
        // Update connection params with the latest event ID for reconnection
        if let lastId = lastEventId {
            socket.setConnectionParameters(["latest_event_id": lastId])
        }
        
        NotificationCenter.default.post(name: .socketDisconnected, object: nil)
    }
    
    private func handleError(data: [Any]) {
        let errorMessage = extractErrorMessage(from: data)
        connectionStatus = .error(errorMessage)
        NotificationCenter.default.post(name: .socketError, object: errorMessage)
    }
}
```

## 2. Reconnection Strategy

The Mac client implements a robust reconnection strategy to handle network interruptions:

### 2.1 Automatic Reconnection

```swift
// In SocketManager initialization
manager = SocketManager(socketURL: url, config: [
    .reconnects(true),
    .reconnectAttempts(10),  // Try to reconnect up to 10 times
    .reconnectWait(5),       // Wait 5 seconds between attempts
    .randomizationFactor(0.5) // Add randomization to prevent thundering herd
])
```

### 2.2 Exponential Backoff

For more advanced reconnection handling, implement an exponential backoff strategy:

```swift
class ReconnectionManager {
    private var reconnectAttempts = 0
    private let maxReconnectAttempts = 10
    private var timer: Timer?
    
    func attemptReconnect(socketManager: SocketManager) {
        guard reconnectAttempts < maxReconnectAttempts else {
            // Max attempts reached, notify user
            NotificationCenter.default.post(
                name: .reconnectionFailed, 
                object: "Failed to reconnect after \(maxReconnectAttempts) attempts"
            )
            return
        }
        
        // Calculate delay with exponential backoff
        let delay = min(30, pow(2.0, Double(reconnectAttempts)))
        reconnectAttempts += 1
        
        timer = Timer.scheduledTimer(withTimeInterval: delay, repeats: false) { [weak self] _ in
            socketManager.connect()
        }
    }
    
    func resetAttempts() {
        reconnectAttempts = 0
        timer?.invalidate()
        timer = nil
    }
}
```

## 3. Error Handling

### 3.1 Error Types and Handling

```swift
enum SocketError: Error {
    case connectionFailed(String)
    case messageError(String, metadata: [String: Any]?)
    case disconnected
    case timeout
}

extension SocketManager {
    private func extractErrorMessage(from data: [Any]) -> String {
        // Extract error message from Socket.IO error data
        if let errorData = data.first as? [String: Any],
           let message = errorData["message"] as? String {
            return message
        }
        return "Unknown error occurred"
    }
    
    private func handleError(data: [Any]) {
        let errorMessage = extractErrorMessage(from: data)
        var metadata: [String: Any]? = nil
        
        // Extract additional error metadata if available
        if let errorData = data.first as? [String: Any],
           let dataDict = errorData["data"] as? [String: Any] {
            metadata = dataDict
        }
        
        // Create appropriate error type
        let error = SocketError.messageError(errorMessage, metadata: metadata)
        
        // Update UI and notify observers
        connectionStatus = .error(errorMessage)
        NotificationCenter.default.post(name: .socketError, object: error)
        
        // Log error for debugging
        Logger.error("Socket error: \(errorMessage)", metadata: metadata)
    }
}
```

### 3.2 User Feedback for Errors

```swift
class ConnectionStatusView: View {
    @ObservedObject var socketManager: SocketManager
    
    var body: some View {
        switch socketManager.connectionStatus {
        case .connected:
            Label("Connected", systemImage: "wifi")
                .foregroundColor(.green)
        case .connecting:
            Label("Connecting...", systemImage: "wifi.exclamationmark")
                .foregroundColor(.yellow)
        case .disconnected:
            Label("Disconnected", systemImage: "wifi.slash")
                .foregroundColor(.red)
        case .error(let message):
            VStack {
                Label("Connection Error", systemImage: "exclamationmark.triangle")
                    .foregroundColor(.red)
                Text(message)
                    .font(.caption)
                    .foregroundColor(.red)
                Button("Retry") {
                    socketManager.connect()
                }
                .buttonStyle(.bordered)
            }
        }
    }
}
```

## 4. Event Queuing During Disconnections

### 4.1 Outgoing Event Queue

```swift
class SocketManager {
    // ... previous code ...
    
    private var outgoingEventQueue: [SocketEvent] = []
    private var isProcessingQueue = false
    
    struct SocketEvent {
        let eventName: String
        let payload: [String: Any]
        let timestamp: Date
    }
    
    func sendUserAction(type: String, args: [String: Any]) {
        let payload: [String: Any] = [
            "type": type,
            "args": args,
            "timestamp": ISO8601DateFormatter().string(from: Date())
        ]
        
        // If connected, send immediately
        if connectionStatus == .connected {
            socket.emit("oh_action", payload)
        } else {
            // Otherwise, queue for later
            let event = SocketEvent(
                eventName: "oh_action", 
                payload: payload,
                timestamp: Date()
            )
            outgoingEventQueue.append(event)
            
            // Attempt to connect if disconnected
            if connectionStatus == .disconnected {
                connect()
            }
        }
    }
    
    private func processEventQueue() {
        guard !isProcessingQueue && !outgoingEventQueue.isEmpty else {
            return
        }
        
        isProcessingQueue = true
        
        // Process events in order
        while !outgoingEventQueue.isEmpty && connectionStatus == .connected {
            let event = outgoingEventQueue.removeFirst()
            socket.emit(event.eventName, event.payload)
        }
        
        isProcessingQueue = false
    }
    
    private func handleConnect() {
        connectionStatus = .connected
        NotificationCenter.default.post(name: .socketConnected, object: nil)
        
        // Process queued events when connection is established
        processEventQueue()
    }
}
```

### 4.2 Event Persistence

For critical events that must survive app restarts:

```swift
extension SocketManager {
    // Save queued events to persistent storage
    private func persistEventQueue() {
        let encoder = JSONEncoder()
        if let encoded = try? encoder.encode(outgoingEventQueue) {
            UserDefaults.standard.set(encoded, forKey: "queued_events")
        }
    }
    
    // Load queued events from persistent storage
    private func loadPersistedEvents() {
        if let data = UserDefaults.standard.data(forKey: "queued_events"),
           let events = try? JSONDecoder().decode([SocketEvent].self, from: data) {
            // Filter out events older than 24 hours
            let cutoffDate = Date().addingTimeInterval(-86400)
            outgoingEventQueue = events.filter { $0.timestamp > cutoffDate }
        }
    }
}
```

## 5. Integration with SwiftUI

### 5.1 Socket Manager as Observable Object

```swift
class SocketManager: ObservableObject {
    @Published private(set) var connectionStatus: ConnectionStatus = .disconnected
    @Published private(set) var events: [OpenHandsEvent] = []
    @Published private(set) var isLoadingMessages = false
    
    // ... rest of implementation ...
}
```

### 5.2 Using in SwiftUI Views

```swift
struct ConversationView: View {
    @StateObject private var socketManager: SocketManager
    
    init(conversationId: String) {
        _socketManager = StateObject(wrappedValue: SocketManager(conversationId: conversationId))
    }
    
    var body: some View {
        VStack {
            ConnectionStatusView(socketManager: socketManager)
            
            MessageList(events: socketManager.events)
            
            MessageInputField(onSend: { message in
                socketManager.sendUserAction(type: "message", args: ["content": message])
            })
        }
        .onAppear {
            socketManager.connect()
        }
        .onDisappear {
            socketManager.disconnect()
        }
    }
}
```

## 6. Testing Socket.IO Implementation

### 6.1 Mock Socket for Testing

```swift
class MockSocketManager: SocketManager {
    override func connect() {
        // Simulate connection
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            self.connectionStatus = .connected
            NotificationCenter.default.post(name: .socketConnected, object: nil)
        }
    }
    
    override func sendUserAction(type: String, args: [String: Any]) {
        // Simulate sending and receiving a response
        let payload: [String: Any] = [
            "type": type,
            "args": args,
            "timestamp": ISO8601DateFormatter().string(from: Date())
        ]
        
        // Simulate response
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            let responseEvent = OpenHandsEvent(
                id: UUID().uuidString,
                source: "agent",
                type: "message",
                message: "This is a mock response",
                timestamp: Date()
            )
            self.events.append(responseEvent)
        }
    }
}
```

This implementation guide provides a comprehensive approach to Socket.IO integration in the Mac client, covering connection management, error handling, event queuing, and SwiftUI integration.

---

# tasks/impl_state_sync.md

# State Synchronization for Mac Client

This document outlines the implementation details for state synchronization between the Mac client and backend server, including handling conflicts, divergent states, and stale data.

## 1. State Synchronization Architecture

### 1.1 State Model

```swift
// Core state model that represents the application state
struct AppState: Codable, Equatable {
    var conversations: [Conversation]
    var currentConversationId: String?
    var preferences: UserPreferences
    var fileSystem: FileSystemState
    var lastSyncTimestamp: Date
    
    // Version tracking for conflict resolution
    var stateVersion: Int
}

struct Conversation: Codable, Identifiable, Equatable {
    let id: String
    var title: String
    var messages: [Message]
    var status: ConversationStatus
    var lastUpdated: Date
    var isArchived: Bool
    
    // Local-only properties (not synchronized)
    var localDraft: String?
    var unreadCount: Int
    
    // Version tracking for conflict resolution
    var version: Int
}

enum ConversationStatus: String, Codable, Equatable {
    case active
    case completed
    case error
}

struct Message: Codable, Identifiable, Equatable {
    let id: String
    let source: MessageSource
    let content: String
    let timestamp: Date
    let metadata: [String: AnyCodable]?
    
    // Server-assigned sequence for ordering
    let sequence: Int
    
    // Flag to track if message has been acknowledged by server
    var isAcknowledged: Bool
}

enum MessageSource: String, Codable, Equatable {
    case user
    case agent
    case system
}

struct UserPreferences: Codable, Equatable {
    var theme: AppTheme
    var fontSize: Int
    var enableNotifications: Bool
    var autoSaveInterval: TimeInterval
    
    // Version tracking for conflict resolution
    var version: Int
}

enum AppTheme: String, Codable, Equatable {
    case system
    case light
    case dark
}

struct FileSystemState: Codable, Equatable {
    var recentFiles: [RecentFile]
    var expandedFolders: [String]
    var fileFilters: [String]
    
    // Version tracking for conflict resolution
    var version: Int
}

struct RecentFile: Codable, Identifiable, Equatable {
    let id: String
    let path: String
    let lastAccessed: Date
}
```

### 1.2 State Store

```swift
class StateStore: ObservableObject {
    @Published private(set) var state: AppState
    
    private let syncManager: StateSyncManager
    private let persistenceManager: StatePersistenceManager
    
    init(syncManager: StateSyncManager, persistenceManager: StatePersistenceManager) {
        self.syncManager = syncManager
        self.persistenceManager = persistenceManager
        
        // Load initial state from persistence
        if let savedState = persistenceManager.loadState() {
            self.state = savedState
        } else {
            self.state = AppState.default
        }
        
        // Set up sync manager
        syncManager.onStateReceived = { [weak self] serverState in
            self?.handleServerState(serverState)
        }
        
        // Set up state change observation
        setupStateObservation()
    }
    
    private func setupStateObservation() {
        // Observe state changes to trigger persistence and sync
        $state
            .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
            .sink { [weak self] newState in
                self?.persistenceManager.saveState(newState)
                self?.syncManager.queueStateForSync(newState)
            }
            .store(in: &cancellables)
    }
    
    // MARK: - State Updates
    
    func updateState(_ update: (inout AppState) -> Void) {
        var newState = state
        update(&newState)
        
        // Update version
        newState.stateVersion += 1
        
        // Update timestamp
        newState.lastSyncTimestamp = Date()
        
        // Publish new state
        state = newState
    }
    
    // MARK: - Server State Handling
    
    private func handleServerState(_ serverState: AppState) {
        // Merge server state with local state
        let mergedState = mergeStates(local: state, server: serverState)
        
        // Update state if changes were made
        if mergedState != state {
            state = mergedState
        }
    }
    
    private func mergeStates(local: AppState, server: AppState) -> AppState {
        var result = local
        
        // Apply server-side conversation changes
        for serverConversation in server.conversations {
            if let localIndex = local.conversations.firstIndex(where: { $0.id == serverConversation.id }) {
                // Existing conversation - merge based on version
                let localConversation = local.conversations[localIndex]
                
                if serverConversation.version > localConversation.version {
                    // Server has newer version - use server data but preserve local-only properties
                    var updatedConversation = serverConversation
                    updatedConversation.localDraft = localConversation.localDraft
                    updatedConversation.unreadCount = localConversation.unreadCount
                    
                    result.conversations[localIndex] = updatedConversation
                } else if serverConversation.version == localConversation.version {
                    // Same version - merge messages
                    var updatedConversation = localConversation
                    updatedConversation.messages = mergeMessages(
                        local: localConversation.messages,
                        server: serverConversation.messages
                    )
                    
                    result.conversations[localIndex] = updatedConversation
                }
                // If local version is higher, keep local version
            } else {
                // New conversation from server - add it
                result.conversations.append(serverConversation)
            }
        }
        
        // Apply preference changes if server has newer version
        if server.preferences.version > local.preferences.version {
            result.preferences = server.preferences
        }
        
        // Apply file system state changes if server has newer version
        if server.fileSystem.version > local.fileSystem.version {
            result.fileSystem = server.fileSystem
        }
        
        // Update current conversation if needed
        if let serverCurrentId = server.currentConversationId,
           serverCurrentId != local.currentConversationId {
            result.currentConversationId = serverCurrentId
        }
        
        // Update last sync timestamp
        result.lastSyncTimestamp = Date()
        
        return result
    }
    
    private func mergeMessages(local: [Message], server: [Message]) -> [Message] {
        var result = local
        
        // Add any server messages not in local
        for serverMessage in server {
            if !local.contains(where: { $0.id == serverMessage.id }) {
                result.append(serverMessage)
            }
        }
        
        // Sort by sequence number
        result.sort { $0.sequence < $1.sequence }
        
        return result
    }
}
```

## 2. Synchronization Manager

### 2.1 Sync Manager Implementation

```swift
class StateSyncManager {
    // Callback for when state is received from server
    var onStateReceived: ((AppState) -> Void)?
    
    private let socketManager: SocketManager
    private var syncQueue: OperationQueue
    private var pendingStateUpdates: [AppState] = []
    private var isSyncing = false
    private var lastSyncedVersion: Int = 0
    
    init(socketManager: SocketManager) {
        self.socketManager = socketManager
        
        // Create a serial queue for sync operations
        syncQueue = OperationQueue()
        syncQueue.maxConcurrentOperationCount = 1
        
        // Set up socket event handlers
        setupSocketHandlers()
    }
    
    private func setupSocketHandlers() {
        // Listen for state updates from server
        socketManager.on("state_update") { [weak self] data in
            guard let self = self,
                  let stateData = data.first as? [String: Any] else {
                return
            }
            
            do {
                // Convert to JSON data
                let jsonData = try JSONSerialization.data(withJSONObject: stateData)
                
                // Decode server state
                let serverState = try JSONDecoder().decode(AppState.self, from: jsonData)
                
                // Notify state store
                DispatchQueue.main.async {
                    self.onStateReceived?(serverState)
                }
                
                // Update last synced version
                self.lastSyncedVersion = serverState.stateVersion
            } catch {
                print("Error decoding server state: \(error)")
            }
        }
        
        // Listen for sync acknowledgements
        socketManager.on("sync_ack") { [weak self] data in
            guard let self = self,
                  let ackData = data.first as? [String: Any],
                  let version = ackData["version"] as? Int else {
                return
            }
            
            // Update last synced version
            self.lastSyncedVersion = version
            
            // Remove acknowledged updates from pending queue
            self.pendingStateUpdates.removeAll { $0.stateVersion <= version }
            
            // Continue syncing if more updates are pending
            self.isSyncing = false
            self.processPendingUpdates()
        }
    }
    
    // Queue state for synchronization
    func queueStateForSync(_ state: AppState) {
        // Only queue if version is newer than last synced
        if state.stateVersion > lastSyncedVersion {
            pendingStateUpdates.append(state)
            processPendingUpdates()
        }
    }
    
    private func processPendingUpdates() {
        // Skip if already syncing or no updates
        guard !isSyncing, !pendingStateUpdates.isEmpty else {
            return
        }
        
        // Get latest state update
        guard let latestState = pendingStateUpdates.last else {
            return
        }
        
        // Mark as syncing
        isSyncing = true
        
        // Prepare state for sync (remove local-only properties)
        let syncState = prepareStateForSync(latestState)
        
        do {
            // Encode state to JSON
            let encoder = JSONEncoder()
            let jsonData = try encoder.encode(syncState)
            
            // Convert to dictionary
            if let stateDict = try JSONSerialization.jsonObject(with: jsonData) as? [String: Any] {
                // Send to server
                socketManager.emit("state_sync", stateDict)
            }
        } catch {
            print("Error encoding state for sync: \(error)")
            isSyncing = false
        }
    }
    
    private func prepareStateForSync(_ state: AppState) -> AppState {
        var syncState = state
        
        // Remove local-only properties from conversations
        for i in 0..<syncState.conversations.count {
            syncState.conversations[i].localDraft = nil
            syncState.conversations[i].unreadCount = 0
        }
        
        return syncState
    }
    
    // Force immediate sync
    func forceSync() {
        if let currentState = pendingStateUpdates.last {
            pendingStateUpdates = [currentState]
            isSyncing = false
            processPendingUpdates()
        }
    }
}
```

### 2.2 State Persistence Manager

```swift
class StatePersistenceManager {
    private let fileManager = FileManager.default
    private let stateFileName = "app_state.json"
    
    // Get URL for state file
    private var stateFileURL: URL? {
        guard let documentsDirectory = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return nil
        }
        
        return documentsDirectory.appendingPathComponent(stateFileName)
    }
    
    // Save state to disk
    func saveState(_ state: AppState) {
        guard let fileURL = stateFileURL else {
            print("Error: Could not determine state file URL")
            return
        }
        
        do {
            let encoder = JSONEncoder()
            encoder.outputFormatting = .prettyPrinted
            let data = try encoder.encode(state)
            try data.write(to: fileURL)
        } catch {
            print("Error saving state: \(error)")
        }
    }
    
    // Load state from disk
    func loadState() -> AppState? {
        guard let fileURL = stateFileURL,
              fileManager.fileExists(atPath: fileURL.path) else {
            return nil
        }
        
        do {
            let data = try Data(contentsOf: fileURL)
            let decoder = JSONDecoder()
            return try decoder.decode(AppState.self, from: data)
        } catch {
            print("Error loading state: \(error)")
            return nil
        }
    }
    
    // Clear saved state
    func clearState() {
        guard let fileURL = stateFileURL,
              fileManager.fileExists(atPath: fileURL.path) else {
            return
        }
        
        do {
            try fileManager.removeItem(at: fileURL)
        } catch {
            print("Error clearing state: \(error)")
        }
    }
}
```

## 3. Conflict Resolution

### 3.1 Version-Based Conflict Resolution

```swift
enum ConflictResolutionStrategy {
    case serverWins
    case clientWins
    case merge
    case manual
}

class ConflictResolver {
    // Resolve conflicts between local and server states
    static func resolveConflicts(
        local: AppState,
        server: AppState,
        strategy: ConflictResolutionStrategy = .merge
    ) -> AppState {
        switch strategy {
        case .serverWins:
            return resolveServerWins(local: local, server: server)
            
        case .clientWins:
            return resolveClientWins(local: local, server: server)
            
        case .merge:
            return resolveMerge(local: local, server: server)
            
        case .manual:
            // Return both states for manual resolution
            // This would typically show a UI for the user to choose
            return local
        }
    }
    
    // Server wins strategy - use server state but preserve local-only data
    private static func resolveServerWins(local: AppState, server: AppState) -> AppState {
        var result = server
        
        // Preserve local-only data in conversations
        for i in 0..<result.conversations.count {
            let serverId = result.conversations[i].id
            
            if let localConversation = local.conversations.first(where: { $0.id == serverId }) {
                result.conversations[i].localDraft = localConversation.localDraft
                result.conversations[i].unreadCount = localConversation.unreadCount
            }
        }
        
        return result
    }
    
    // Client wins strategy - use local state but incorporate new server data
    private static func resolveClientWins(local: AppState, server: AppState) -> AppState {
        var result = local
        
        // Add new conversations from server
        for serverConversation in server.conversations {
            if !local.conversations.contains(where: { $0.id == serverConversation.id }) {
                result.conversations.append(serverConversation)
            }
        }
        
        return result
    }
    
    // Merge strategy - intelligently merge based on entity versions
    private static func resolveMerge(local: AppState, server: AppState) -> AppState {
        var result = local
        
        // Merge conversations
        var mergedConversations: [Conversation] = []
        
        // Process all conversations from both states
        let allConversationIds = Set(
            local.conversations.map { $0.id } + 
            server.conversations.map { $0.id }
        )
        
        for conversationId in allConversationIds {
            let localConversation = local.conversations.first(where: { $0.id == conversationId })
            let serverConversation = server.conversations.first(where: { $0.id == conversationId })
            
            if let local = localConversation, let server = serverConversation {
                // Both exist - resolve based on version
                if local.version > server.version {
                    mergedConversations.append(local)
                } else if server.version > local.version {
                    var merged = server
                    merged.localDraft = local.localDraft
                    merged.unreadCount = local.unreadCount
                    mergedConversations.append(merged)
                } else {
                    // Same version - merge messages
                    var merged = local
                    merged.messages = mergeMessages(local: local.messages, server: server.messages)
                    mergedConversations.append(merged)
                }
            } else if let local = localConversation {
                // Only in local
                mergedConversations.append(local)
            } else if let server = serverConversation {
                // Only in server
                mergedConversations.append(server)
            }
        }
        
        result.conversations = mergedConversations
        
        // Merge preferences based on version
        if server.preferences.version > local.preferences.version {
            result.preferences = server.preferences
        }
        
        // Merge file system state based on version
        if server.fileSystem.version > local.fileSystem.version {
            result.fileSystem = server.fileSystem
        }
        
        // Use higher state version
        result.stateVersion = max(local.stateVersion, server.stateVersion)
        
        return result
    }
    
    // Merge messages from local and server
    private static func mergeMessages(local: [Message], server: [Message]) -> [Message] {
        var result: [Message] = []
        
        // Combine all messages
        let allMessages = local + server.filter { serverMsg in
            !local.contains { $0.id == serverMsg.id }
        }
        
        // Sort by sequence and timestamp
        result = allMessages.sorted { first, second in
            if first.sequence != second.sequence {
                return first.sequence < second.sequence
            }
            return first.timestamp < second.timestamp
        }
        
        return result
    }
}
```

### 3.2 Conflict Detection

```swift
class ConflictDetector {
    // Detect conflicts between local and server states
    static func detectConflicts(local: AppState, server: AppState) -> [StateConflict] {
        var conflicts: [StateConflict] = []
        
        // Check for conversation conflicts
        for localConversation in local.conversations {
            if let serverConversation = server.conversations.first(where: { $0.id == localConversation.id }) {
                // Both have the same conversation - check for conflicts
                if localConversation.version != serverConversation.version {
                    conflicts.append(
                        .conversationConflict(
                            id: localConversation.id,
                            localVersion: localConversation.version,
                            serverVersion: serverConversation.version
                        )
                    )
                }
                
                // Check for message conflicts
                let messageConflicts = detectMessageConflicts(
                    local: localConversation.messages,
                    server: serverConversation.messages
                )
                
                conflicts.append(contentsOf: messageConflicts.map {
                    .messageConflict(conversationId: localConversation.id, conflict: $0)
                })
            }
        }
        
        // Check for preference conflicts
        if local.preferences.version != server.preferences.version {
            conflicts.append(
                .preferencesConflict(
                    localVersion: local.preferences.version,
                    serverVersion: server.preferences.version
                )
            )
        }
        
        // Check for file system state conflicts
        if local.fileSystem.version != server.fileSystem.version {
            conflicts.append(
                .fileSystemConflict(
                    localVersion: local.fileSystem.version,
                    serverVersion: server.fileSystem.version
                )
            )
        }
        
        return conflicts
    }
    
    // Detect conflicts between message sets
    private static func detectMessageConflicts(local: [Message], server: [Message]) -> [MessageConflict] {
        var conflicts: [MessageConflict] = []
        
        // Check for messages with same ID but different content
        for localMessage in local {
            if let serverMessage = server.first(where: { $0.id == localMessage.id }) {
                if localMessage.content != serverMessage.content {
                    conflicts.append(
                        .contentMismatch(
                            messageId: localMessage.id,
                            localContent: localMessage.content,
                            serverContent: serverMessage.content
                        )
                    )
                }
                
                if localMessage.sequence != serverMessage.sequence {
                    conflicts.append(
                        .sequenceMismatch(
                            messageId: localMessage.id,
                            localSequence: localMessage.sequence,
                            serverSequence: serverMessage.sequence
                        )
                    )
                }
            }
        }
        
        return conflicts
    }
}

// Conflict types
enum StateConflict {
    case conversationConflict(id: String, localVersion: Int, serverVersion: Int)
    case messageConflict(conversationId: String, conflict: MessageConflict)
    case preferencesConflict(localVersion: Int, serverVersion: Int)
    case fileSystemConflict(localVersion: Int, serverVersion: Int)
}

enum MessageConflict {
    case contentMismatch(messageId: String, localContent: String, serverContent: String)
    case sequenceMismatch(messageId: String, localSequence: Int, serverSequence: Int)
}
```

## 4. Handling Stale State

### 4.1 Stale State Detection

```swift
class StaleStateDetector {
    // Check if state is stale based on timestamp
    static func isStateStale(state: AppState, threshold: TimeInterval = 300) -> Bool {
        let now = Date()
        return now.timeIntervalSince(state.lastSyncTimestamp) > threshold
    }
    
    // Check if specific conversation is stale
    static func isConversationStale(conversation: Conversation, threshold: TimeInterval = 300) -> Bool {
        let now = Date()
        return now.timeIntervalSince(conversation.lastUpdated) > threshold
    }
    
    // Get stale conversations
    static func getStaleConversations(in state: AppState, threshold: TimeInterval = 300) -> [Conversation] {
        let now = Date()
        return state.conversations.filter {
            now.timeIntervalSince($0.lastUpdated) > threshold
        }
    }
}
```

### 4.2 Stale State Refresh

```swift
class StateRefresher {
    private let socketManager: SocketManager
    
    init(socketManager: SocketManager) {
        self.socketManager = socketManager
    }
    
    // Request full state refresh from server
    func requestFullStateRefresh(completion: @escaping (Result<AppState, Error>) -> Void) {
        socketManager.emit("request_full_state") { [weak self] response in
            guard let self = self else { return }
            
            if let error = response.error {
                completion(.failure(error))
                return
            }
            
            guard let stateData = response.data as? [String: Any] else {
                completion(.failure(NSError(domain: "StateRefresher", code: 1, userInfo: [
                    NSLocalizedDescriptionKey: "Invalid state data received"
                ])))
                return
            }
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: stateData)
                let state = try JSONDecoder().decode(AppState.self, from: jsonData)
                completion(.success(state))
            } catch {
                completion(.failure(error))
            }
        }
    }
    
    // Request refresh for specific conversation
    func refreshConversation(id: String, completion: @escaping (Result<Conversation, Error>) -> Void) {
        socketManager.emit("request_conversation", ["id": id]) { response in
            if let error = response.error {
                completion(.failure(error))
                return
            }
            
            guard let conversationData = response.data as? [String: Any] else {
                completion(.failure(NSError(domain: "StateRefresher", code: 2, userInfo: [
                    NSLocalizedDescriptionKey: "Invalid conversation data received"
                ])))
                return
            }
            
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: conversationData)
                let conversation = try JSONDecoder().decode(Conversation.self, from: jsonData)
                completion(.success(conversation))
            } catch {
                completion(.failure(error))
            }
        }
    }
}
```

### 4.3 Automatic Refresh Policy

```swift
class AutoRefreshPolicy {
    private let stateStore: StateStore
    private let stateRefresher: StateRefresher
    private var refreshTimer: Timer?
    private let refreshInterval: TimeInterval
    
    init(stateStore: StateStore, stateRefresher: StateRefresher, refreshInterval: TimeInterval = 300) {
        self.stateStore = stateStore
        self.stateRefresher = stateRefresher
        self.refreshInterval = refreshInterval
        
        startRefreshTimer()
    }
    
    private func startRefreshTimer() {
        refreshTimer = Timer.scheduledTimer(
            timeInterval: refreshInterval,
            target: self,
            selector: #selector(checkForStaleState),
            userInfo: nil,
            repeats: true
        )
    }
    
    @objc private func checkForStaleState() {
        let state = stateStore.state
        
        // Check if overall state is stale
        if StaleStateDetector.isStateStale(state: state) {
            refreshFullState()
            return
        }
        
        // Check for stale conversations
        let staleConversations = StaleStateDetector.getStaleConversations(in: state)
        for conversation in staleConversations {
            refreshConversation(id: conversation.id)
        }
    }
    
    private func refreshFullState() {
        stateRefresher.requestFullStateRefresh { [weak self] result in
            guard let self = self else { return }
            
            switch result {
            case .success(let refreshedState):
                self.stateStore.updateState { state in
                    // Apply refreshed state
                    state = refreshedState
                }
                
            case .failure(let error):
                print("Failed to refresh state: \(error)")
                // Could implement retry logic here
            }
        }
    }
    
    private func refreshConversation(id: String) {
        stateRefresher.refreshConversation(id: id) { [weak self] result in
            guard let self = self else { return }
            
            switch result {
            case .success(let refreshedConversation):
                self.stateStore.updateState { state in
                    // Find and update the conversation
                    if let index = state.conversations.firstIndex(where: { $0.id == id }) {
                        state.conversations[index] = refreshedConversation
                    }
                }
                
            case .failure(let error):
                print("Failed to refresh conversation \(id): \(error)")
            }
        }
    }
}
```

## 5. Offline Mode and Reconnection Syncing

### 5.1 Offline Queue Manager

```swift
class OfflineQueueManager {
    private let persistenceManager: StatePersistenceManager
    private var offlineActions: [OfflineAction] = []
    private let offlineActionsFileName = "offline_actions.json"
    
    init(persistenceManager: StatePersistenceManager) {
        self.persistenceManager = persistenceManager
        loadOfflineActions()
    }
    
    // Add action to offline queue
    func queueAction(_ action: OfflineAction) {
        offlineActions.append(action)
        saveOfflineActions()
    }
    
    // Get all queued actions
    func getQueuedActions() -> [OfflineAction] {
        return offlineActions
    }
    
    // Clear specific actions
    func clearActions(_ actionIds: [String]) {
        offlineActions.removeAll { actionIds.contains($0.id) }
        saveOfflineActions()
    }
    
    // Clear all actions
    func clearAllActions() {
        offlineActions.removeAll()
        saveOfflineActions()
    }
    
    // Save offline actions to disk
    private func saveOfflineActions() {
        guard let fileURL = getOfflineActionsFileURL() else {
            print("Error: Could not determine offline actions file URL")
            return
        }
        
        do {
            let encoder = JSONEncoder()
            encoder.outputFormatting = .prettyPrinted
            let data = try encoder.encode(offlineActions)
            try data.write(to: fileURL)
        } catch {
            print("Error saving offline actions: \(error)")
        }
    }
    
    // Load offline actions from disk
    private func loadOfflineActions() {
        guard let fileURL = getOfflineActionsFileURL(),
              FileManager.default.fileExists(atPath: fileURL.path) else {
            return
        }
        
        do {
            let data = try Data(contentsOf: fileURL)
            let decoder = JSONDecoder()
            offlineActions = try decoder.decode([OfflineAction].self, from: data)
        } catch {
            print("Error loading offline actions: \(error)")
        }
    }
    
    // Get URL for offline actions file
    private func getOfflineActionsFileURL() -> URL? {
        guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return nil
        }
        
        return documentsDirectory.appendingPathComponent(offlineActionsFileName)
    }
}

// Offline action model
struct OfflineAction: Codable, Identifiable {
    let id: String
    let type: String
    let payload: [String: AnyCodable]
    let timestamp: Date
    let conversationId: String?
    var retryCount: Int
    
    init(type: String, payload: [String: Any], conversationId: String? = nil) {
        self.id = UUID().uuidString
        self.type = type
        self.payload = payload.mapValues { AnyCodable($0) }
        self.timestamp = Date()
        self.conversationId = conversationId
        self.retryCount = 0
    }
}

// Helper for encoding/decoding Any values
struct AnyCodable: Codable {
    let value: Any
    
    init(_ value: Any) {
        self.value = value
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        
        if container.decodeNil() {
            self.value = NSNull()
        } else if let bool = try? container.decode(Bool.self) {
            self.value = bool
        } else if let int = try? container.decode(Int.self) {
            self.value = int
        } else if let double = try? container.decode(Double.self) {
            self.value = double
        } else if let string = try? container.decode(String.self) {
            self.value = string
        } else if let array = try? container.decode([AnyCodable].self) {
            self.value = array.map { $0.value }
        } else if let dictionary = try? container.decode([String: AnyCodable].self) {
            self.value = dictionary.mapValues { $0.value }
        } else {
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: "AnyCodable value cannot be decoded"
            )
        }
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        
        switch value {
        case is NSNull:
            try container.encodeNil()
        case let bool as Bool:
            try container.encode(bool)
        case let int as Int:
            try container.encode(int)
        case let double as Double:
            try container.encode(double)
        case let string as String:
            try container.encode(string)
        case let array as [Any]:
            try container.encode(array.map { AnyCodable($0) })
        case let dictionary as [String: Any]:
            try container.encode(dictionary.mapValues { AnyCodable($0) })
        default:
            let context = EncodingError.Context(
                codingPath: container.codingPath,
                debugDescription: "AnyCodable value cannot be encoded"
            )
            throw EncodingError.invalidValue(value, context)
        }
    }
}
```

### 5.2 Offline Mode Manager

```swift
class OfflineModeManager: ObservableObject {
    @Published private(set) var isOffline = false
    @Published private(set) var pendingActionCount = 0
    
    private let socketManager: SocketManager
    private let offlineQueueManager: OfflineQueueManager
    private let stateStore: StateStore
    
    init(socketManager: SocketManager, offlineQueueManager: OfflineQueueManager, stateStore: StateStore) {
        self.socketManager = socketManager
        self.offlineQueueManager = offlineQueueManager
        self.stateStore = stateStore
        
        // Set up connection status monitoring
        setupConnectionMonitoring()
        
        // Update pending action count
        updatePendingActionCount()
    }
    
    private func setupConnectionMonitoring() {
        // Monitor socket connection status
        socketManager.onStatusChange = { [weak self] status in
            guard let self = self else { return }
            
            let wasOffline = self.isOffline
            
            // Update offline status
            switch status {
            case .connected:
                self.isOffline = false
            case .disconnected, .error:
                self.isOffline = true
            case .connecting, .reconnecting:
                // Keep current offline status during connection attempts
                break
            }
            
            // If transitioning from offline to online, sync queued actions
            if wasOffline && !self.isOffline {
                self.syncOfflineActions()
            }
        }
    }
    
    // Perform action with offline support
    func performAction(type: String, payload: [String: Any], conversationId: String? = nil) {
        if !isOffline {
            // Online - send directly
            socketManager.emit(type, payload)
        } else {
            // Offline - queue for later
            let action = OfflineAction(type: type, payload: payload, conversationId: conversationId)
            offlineQueueManager.queueAction(action)
            updatePendingActionCount()
            
            // Also update local state to reflect the action
            applyOfflineActionToLocalState(action)
        }
    }
    
    // Apply offline action to local state for immediate feedback
    private func applyOfflineActionToLocalState(_ action: OfflineAction) {
        stateStore.updateState { state in
            switch action.type {
            case "send_message":
                if let conversationId = action.conversationId,
                   let content = action.payload["content"]?.value as? String,
                   let conversationIndex = state.conversations.firstIndex(where: { $0.id == conversationId }) {
                    
                    // Create a temporary message
                    let tempMessage = Message(
                        id: action.id,
                        source: .user,
                        content: content,
                        timestamp: action.timestamp,
                        metadata: nil,
                        sequence: state.conversations[conversationIndex].messages.count,
                        isAcknowledged: false
                    )
                    
                    // Add to conversation
                    state.conversations[conversationIndex].messages.append(tempMessage)
                    state.conversations[conversationIndex].lastUpdated = action.timestamp
                }
                
            case "update_conversation":
                if let conversationId = action.conversationId,
                   let title = action.payload["title"]?.value as? String,
                   let conversationIndex = state.conversations.firstIndex(where: { $0.id == conversationId }) {
                    
                    // Update conversation title
                    state.conversations[conversationIndex].title = title
                    state.conversations[conversationIndex].lastUpdated = action.timestamp
                }
                
            case "update_preferences":
                if let theme = action.payload["theme"]?.value as? String {
                    if let appTheme = AppTheme(rawValue: theme) {
                        state.preferences.theme = appTheme
                    }
                }
                
                if let fontSize = action.payload["fontSize"]?.value as? Int {
                    state.preferences.fontSize = fontSize
                }
                
                if let enableNotifications = action.payload["enableNotifications"]?.value as? Bool {
                    state.preferences.enableNotifications = enableNotifications
                }
                
                // Increment version
                state.preferences.version += 1
                
            default:
                // Other action types not handled for local state updates
                break
            }
        }
    }
    
    // Sync offline actions when back online
    private func syncOfflineActions() {
        let actions = offlineQueueManager.getQueuedActions()
        
        if actions.isEmpty {
            return
        }
        
        // Process actions in order
        var processedActionIds: [String] = []
        
        for action in actions {
            // Convert AnyCodable payload back to regular dictionary
            let payload = action.payload.mapValues { $0.value }
            
            // Send to server
            socketManager.emit(action.type, payload)
            
            // Add to processed list
            processedActionIds.append(action.id)
        }
        
        // Clear processed actions
        offlineQueueManager.clearActions(processedActionIds)
        updatePendingActionCount()
    }
    
    // Update pending action count
    private func updatePendingActionCount() {
        let count = offlineQueueManager.getQueuedActions().count
        
        DispatchQueue.main.async {
            self.pendingActionCount = count
        }
    }
    
    // Force sync of offline actions
    func forceSyncOfflineActions() {
        if !isOffline {
            syncOfflineActions()
        }
    }
}
```

### 5.3 Offline Indicator UI

```swift
struct OfflineIndicatorView: View {
    @ObservedObject var offlineModeManager: OfflineModeManager
    
    var body: some View {
        if offlineModeManager.isOffline || offlineModeManager.pendingActionCount > 0 {
            HStack(spacing: 8) {
                // Offline icon
                Image(systemName: offlineModeManager.isOffline ? "wifi.slash" : "arrow.up.arrow.down")
                    .foregroundColor(offlineModeManager.isOffline ? .red : .orange)
                
                // Status text
                Text(statusText)
                    .font(.caption)
                    .foregroundColor(offlineModeManager.isOffline ? .red : .orange)
                
                // Sync button if needed
                if !offlineModeManager.isOffline && offlineModeManager.pendingActionCount > 0 {
                    Button(action: {
                        offlineModeManager.forceSyncOfflineActions()
                    }) {
                        Image(systemName: "arrow.clockwise")
                            .font(.caption)
                    }
                    .buttonStyle(BorderlessButtonStyle())
                }
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 6)
            .background(backgroundColor)
            .cornerRadius(12)
        }
    }
    
    private var statusText: String {
        if offlineModeManager.isOffline {
            return "Offline Mode"
        } else if offlineModeManager.pendingActionCount > 0 {
            return "Syncing (\(offlineModeManager.pendingActionCount) pending)"
        } else {
            return ""
        }
    }
    
    private var backgroundColor: Color {
        offlineModeManager.isOffline ? Color.red.opacity(0.1) : Color.orange.opacity(0.1)
    }
}
```

This implementation guide provides a comprehensive approach to state synchronization in the Mac client, covering state models, synchronization, conflict resolution, stale state handling, and offline mode support.

---

# tasks/impl_swift.md

# Swift Implementation Details for Mac Client

This document outlines specific Swift implementation details for the Mac client, including concurrency approaches, property wrapper usage for state management, and dependency injection patterns.

## 1. Swift Concurrency Approach

### 1.1 Async/Await Implementation

```swift
// MARK: - Core Async API Client

class AsyncAPIClient {
    private let baseURL: URL
    private let session: URLSession
    
    init(baseURL: URL, session: URLSession = .shared) {
        self.baseURL = baseURL
        self.session = session
    }
    
    // Generic request method using async/await
    func request<T: Decodable>(
        endpoint: String,
        method: HTTPMethod = .get,
        parameters: [String: Any]? = nil,
        headers: [String: String]? = nil
    ) async throws -> T {
        // Construct URL
        let url = baseURL.appendingPathComponent(endpoint)
        
        // Create request
        var request = URLRequest(url: url)
        request.httpMethod = method.rawValue
        
        // Add headers
        headers?.forEach { request.addValue($1, forHTTPHeaderField: $0) }
        
        // Add default headers
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue("application/json", forHTTPHeaderField: "Accept")
        
        // Add parameters
        if let parameters = parameters {
            switch method {
            case .get:
                // Add query parameters
                var components = URLComponents(url: url, resolvingAgainstBaseURL: true)!
                components.queryItems = parameters.map { URLQueryItem(name: $0.key, value: "\($0.value)") }
                request.url = components.url
                
            case .post, .put, .patch:
                // Add body parameters
                request.httpBody = try JSONSerialization.data(withJSONObject: parameters)
                
            case .delete:
                // Add body parameters for DELETE if needed
                if !parameters.isEmpty {
                    request.httpBody = try JSONSerialization.data(withJSONObject: parameters)
                }
            }
        }
        
        // Perform request
        let (data, response) = try await session.data(for: request)
        
        // Check response
        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIError.invalidResponse
        }
        
        // Check status code
        guard (200...299).contains(httpResponse.statusCode) else {
            throw APIError.httpError(statusCode: httpResponse.statusCode, data: data)
        }
        
        // Decode response
        do {
            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            decoder.dateDecodingStrategy = .iso8601
            return try decoder.decode(T.self, from: data)
        } catch {
            throw APIError.decodingError(error)
        }
    }
    
    // Upload file using async/await
    func uploadFile(
        endpoint: String,
        fileURL: URL,
        mimeType: String,
        parameters: [String: String]? = nil
    ) async throws -> UploadResponse {
        // Construct URL
        let url = baseURL.appendingPathComponent(endpoint)
        
        // Create request
        var request = URLRequest(url: url)
        request.httpMethod = HTTPMethod.post.rawValue
        
        // Generate boundary
        let boundary = UUID().uuidString
        
        // Set content type
        request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type")
        
        // Create body
        var body = Data()
        
        // Add parameters
        parameters?.forEach { key, value in
            body.append("--\(boundary)\r\n".data(using: .utf8)!)
            body.append("Content-Disposition: form-data; name=\"\(key)\"\r\n\r\n".data(using: .utf8)!)
            body.append("\(value)\r\n".data(using: .utf8)!)
        }
        
        // Add file
        body.append("--\(boundary)\r\n".data(using: .utf8)!)
        body.append("Content-Disposition: form-data; name=\"file\"; filename=\"\(fileURL.lastPathComponent)\"\r\n".data(using: .utf8)!)
        body.append("Content-Type: \(mimeType)\r\n\r\n".data(using: .utf8)!)
        body.append(try Data(contentsOf: fileURL))
        body.append("\r\n".data(using: .utf8)!)
        
        // Add closing boundary
        body.append("--\(boundary)--\r\n".data(using: .utf8)!)
        
        // Set body
        request.httpBody = body
        
        // Perform request
        let (data, response) = try await session.data(for: request)
        
        // Check response
        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIError.invalidResponse
        }
        
        // Check status code
        guard (200...299).contains(httpResponse.statusCode) else {
            throw APIError.httpError(statusCode: httpResponse.statusCode, data: data)
        }
        
        // Decode response
        do {
            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            return try decoder.decode(UploadResponse.self, from: data)
        } catch {
            throw APIError.decodingError(error)
        }
    }
    
    // Download file using async/await
    func downloadFile(
        endpoint: String,
        parameters: [String: Any]? = nil,
        destination: URL
    ) async throws -> URL {
        // Construct URL
        var urlComponents = URLComponents(url: baseURL.appendingPathComponent(endpoint), resolvingAgainstBaseURL: true)!
        
        // Add query parameters
        if let parameters = parameters {
            urlComponents.queryItems = parameters.map { URLQueryItem(name: $0.key, value: "\($0.value)") }
        }
        
        // Create request
        var request = URLRequest(url: urlComponents.url!)
        request.httpMethod = HTTPMethod.get.rawValue
        
        // Perform download
        let (fileURL, response) = try await session.download(for: request)
        
        // Check response
        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIError.invalidResponse
        }
        
        // Check status code
        guard (200...299).contains(httpResponse.statusCode) else {
            throw APIError.httpError(statusCode: httpResponse.statusCode, data: Data())
        }
        
        // Move file to destination
        try FileManager.default.moveItem(at: fileURL, to: destination)
        
        return destination
    }
}

// HTTP Method enum
enum HTTPMethod: String {
    case get = "GET"
    case post = "POST"
    case put = "PUT"
    case patch = "PATCH"
    case delete = "DELETE"
}

// API Error enum
enum APIError: Error {
    case invalidResponse
    case httpError(statusCode: Int, data: Data)
    case decodingError(Error)
    case invalidURL
    case networkError(Error)
}

// Upload Response model
struct UploadResponse: Codable {
    let id: String
    let url: String
    let filename: String
    let size: Int
}

// MARK: - Usage Examples

// Example service using async/await
class UserService {
    private let apiClient: AsyncAPIClient
    
    init(apiClient: AsyncAPIClient) {
        self.apiClient = apiClient
    }
    
    // Get user profile
    func getUserProfile() async throws -> UserProfile {
        return try await apiClient.request(endpoint: "users/profile")
    }
    
    // Update user profile
    func updateUserProfile(name: String, email: String) async throws -> UserProfile {
        return try await apiClient.request(
            endpoint: "users/profile",
            method: .put,
            parameters: ["name": name, "email": email]
        )
    }
    
    // Upload profile picture
    func uploadProfilePicture(imageURL: URL) async throws -> UploadResponse {
        return try await apiClient.uploadFile(
            endpoint: "users/profile/picture",
            fileURL: imageURL,
            mimeType: "image/jpeg"
        )
    }
}

// User Profile model
struct UserProfile: Codable {
    let id: String
    let name: String
    let email: String
    let profilePictureURL: String?
}

// Example view model using async/await
class ProfileViewModel: ObservableObject {
    @Published var profile: UserProfile?
    @Published var isLoading = false
    @Published var error: Error?
    
    private let userService: UserService
    
    init(userService: UserService) {
        self.userService = userService
    }
    
    // Load profile using async/await
    @MainActor
    func loadProfile() async {
        isLoading = true
        error = nil
        
        do {
            profile = try await userService.getUserProfile()
        } catch {
            self.error = error
        }
        
        isLoading = false
    }
    
    // Update profile using async/await
    @MainActor
    func updateProfile(name: String, email: String) async {
        isLoading = true
        error = nil
        
        do {
            profile = try await userService.updateUserProfile(name: name, email: email)
        } catch {
            self.error = error
        }
        
        isLoading = false
    }
    
    // Upload profile picture using async/await
    @MainActor
    func uploadProfilePicture(imageURL: URL) async {
        isLoading = true
        error = nil
        
        do {
            let response = try await userService.uploadProfilePicture(imageURL: imageURL)
            
            // Reload profile to get updated picture URL
            profile = try await userService.getUserProfile()
        } catch {
            self.error = error
        }
        
        isLoading = false
    }
}

// Example view using async/await
struct ProfileView: View {
    @StateObject private var viewModel: ProfileViewModel
    
    init(viewModel: ProfileViewModel) {
        _viewModel = StateObject(wrappedValue: viewModel)
    }
    
    var body: some View {
        VStack {
            if viewModel.isLoading {
                ProgressView()
            } else if let profile = viewModel.profile {
                Text("Name: \(profile.name)")
                Text("Email: \(profile.email)")
                
                Button("Refresh") {
                    Task {
                        await viewModel.loadProfile()
                    }
                }
            } else if let error = viewModel.error {
                Text("Error: \(error.localizedDescription)")
                
                Button("Retry") {
                    Task {
                        await viewModel.loadProfile()
                    }
                }
            }
        }
        .onAppear {
            Task {
                await viewModel.loadProfile()
            }
        }
    }
}
```

### 1.2 Combine Implementation

```swift
// MARK: - Core Combine API Client

class CombineAPIClient {
    private let baseURL: URL
    private let session: URLSession
    
    init(baseURL: URL, session: URLSession = .shared) {
        self.baseURL = baseURL
        self.session = session
    }
    
    // Generic request method using Combine
    func request<T: Decodable>(
        endpoint: String,
        method: HTTPMethod = .get,
        parameters: [String: Any]? = nil,
        headers: [String: String]? = nil
    ) -> AnyPublisher<T, Error> {
        // Construct URL
        let url = baseURL.appendingPathComponent(endpoint)
        
        // Create request
        var request = URLRequest(url: url)
        request.httpMethod = method.rawValue
        
        // Add headers
        headers?.forEach { request.addValue($1, forHTTPHeaderField: $0) }
        
        // Add default headers
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue("application/json", forHTTPHeaderField: "Accept")
        
        // Add parameters
        if let parameters = parameters {
            do {
                switch method {
                case .get:
                    // Add query parameters
                    var components = URLComponents(url: url, resolvingAgainstBaseURL: true)!
                    components.queryItems = parameters.map { URLQueryItem(name: $0.key, value: "\($0.value)") }
                    request.url = components.url
                    
                case .post, .put, .patch:
                    // Add body parameters
                    request.httpBody = try JSONSerialization.data(withJSONObject: parameters)
                    
                case .delete:
                    // Add body parameters for DELETE if needed
                    if !parameters.isEmpty {
                        request.httpBody = try JSONSerialization.data(withJSONObject: parameters)
                    }
                }
            } catch {
                return Fail(error: APIError.networkError(error)).eraseToAnyPublisher()
            }
        }
        
        // Perform request
        return session.dataTaskPublisher(for: request)
            .tryMap { data, response in
                // Check response
                guard let httpResponse = response as? HTTPURLResponse else {
                    throw APIError.invalidResponse
                }
                
                // Check status code
                guard (200...299).contains(httpResponse.statusCode) else {
                    throw APIError.httpError(statusCode: httpResponse.statusCode, data: data)
                }
                
                return data
            }
            .decode(type: T.self, decoder: JSONDecoder())
            .mapError { error in
                if let apiError = error as? APIError {
                    return apiError
                } else if error is DecodingError {
                    return APIError.decodingError(error)
                } else {
                    return APIError.networkError(error)
                }
            }
            .eraseToAnyPublisher()
    }
    
    // Upload file using Combine
    func uploadFile(
        endpoint: String,
        fileURL: URL,
        mimeType: String,
        parameters: [String: String]? = nil
    ) -> AnyPublisher<UploadResponse, Error> {
        // Construct URL
        let url = baseURL.appendingPathComponent(endpoint)
        
        // Create request
        var request = URLRequest(url: url)
        request.httpMethod = HTTPMethod.post.rawValue
        
        // Generate boundary
        let boundary = UUID().uuidString
        
        // Set content type
        request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type")
        
        // Create body
        var body = Data()
        
        // Add parameters
        parameters?.forEach { key, value in
            body.append("--\(boundary)\r\n".data(using: .utf8)!)
            body.append("Content-Disposition: form-data; name=\"\(key)\"\r\n\r\n".data(using: .utf8)!)
            body.append("\(value)\r\n".data(using: .utf8)!)
        }
        
        // Add file
        do {
            body.append("--\(boundary)\r\n".data(using: .utf8)!)
            body.append("Content-Disposition: form-data; name=\"file\"; filename=\"\(fileURL.lastPathComponent)\"\r\n".data(using: .utf8)!)
            body.append("Content-Type: \(mimeType)\r\n\r\n".data(using: .utf8)!)
            body.append(try Data(contentsOf: fileURL))
            body.append("\r\n".data(using: .utf8)!)
            
            // Add closing boundary
            body.append("--\(boundary)--\r\n".data(using: .utf8)!)
            
            // Set body
            request.httpBody = body
        } catch {
            return Fail(error: APIError.networkError(error)).eraseToAnyPublisher()
        }
        
        // Perform request
        return session.dataTaskPublisher(for: request)
            .tryMap { data, response in
                // Check response
                guard let httpResponse = response as? HTTPURLResponse else {
                    throw APIError.invalidResponse
                }
                
                // Check status code
                guard (200...299).contains(httpResponse.statusCode) else {
                    throw APIError.httpError(statusCode: httpResponse.statusCode, data: data)
                }
                
                return data
            }
            .decode(type: UploadResponse.self, decoder: JSONDecoder())
            .mapError { error in
                if let apiError = error as? APIError {
                    return apiError
                } else if error is DecodingError {
                    return APIError.decodingError(error)
                } else {
                    return APIError.networkError(error)
                }
            }
            .eraseToAnyPublisher()
    }
}

// MARK: - Usage Examples

// Example service using Combine
class CombineUserService {
    private let apiClient: CombineAPIClient
    
    init(apiClient: CombineAPIClient) {
        self.apiClient = apiClient
    }
    
    // Get user profile
    func getUserProfile() -> AnyPublisher<UserProfile, Error> {
        return apiClient.request(endpoint: "users/profile")
    }
    
    // Update user profile
    func updateUserProfile(name: String, email: String) -> AnyPublisher<UserProfile, Error> {
        return apiClient.request(
            endpoint: "users/profile",
            method: .put,
            parameters: ["name": name, "email": email]
        )
    }
    
    // Upload profile picture
    func uploadProfilePicture(imageURL: URL) -> AnyPublisher<UploadResponse, Error> {
        return apiClient.uploadFile(
            endpoint: "users/profile/picture",
            fileURL: imageURL,
            mimeType: "image/jpeg"
        )
    }
}

// Example view model using Combine
class CombineProfileViewModel: ObservableObject {
    @Published var profile: UserProfile?
    @Published var isLoading = false
    @Published var error: Error?
    
    private let userService: CombineUserService
    private var cancellables = Set<AnyCancellable>()
    
    init(userService: CombineUserService) {
        self.userService = userService
    }
    
    // Load profile using Combine
    func loadProfile() {
        isLoading = true
        error = nil
        
        userService.getUserProfile()
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error
                    }
                },
                receiveValue: { [weak self] profile in
                    self?.profile = profile
                }
            )
            .store(in: &cancellables)
    }
    
    // Update profile using Combine
    func updateProfile(name: String, email: String) {
        isLoading = true
        error = nil
        
        userService.updateUserProfile(name: name, email: email)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error
                    }
                },
                receiveValue: { [weak self] profile in
                    self?.profile = profile
                }
            )
            .store(in: &cancellables)
    }
    
    // Upload profile picture using Combine
    func uploadProfilePicture(imageURL: URL) {
        isLoading = true
        error = nil
        
        userService.uploadProfilePicture(imageURL: imageURL)
            .flatMap { [weak self] _ -> AnyPublisher<UserProfile, Error> in
                guard let self = self else {
                    return Fail(error: NSError(domain: "ProfileViewModel", code: -1, userInfo: nil)).eraseToAnyPublisher()
                }
                
                // Reload profile to get updated picture URL
                return self.userService.getUserProfile()
            }
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error
                    }
                },
                receiveValue: { [weak self] profile in
                    self?.profile = profile
                }
            )
            .store(in: &cancellables)
    }
}

// Example view using Combine
struct CombineProfileView: View {
    @StateObject private var viewModel: CombineProfileViewModel
    
    init(viewModel: CombineProfileViewModel) {
        _viewModel = StateObject(wrappedValue: viewModel)
    }
    
    var body: some View {
        VStack {
            if viewModel.isLoading {
                ProgressView()
            } else if let profile = viewModel.profile {
                Text("Name: \(profile.name)")
                Text("Email: \(profile.email)")
                
                Button("Refresh") {
                    viewModel.loadProfile()
                }
            } else if let error = viewModel.error {
                Text("Error: \(error.localizedDescription)")
                
                Button("Retry") {
                    viewModel.loadProfile()
                }
            }
        }
        .onAppear {
            viewModel.loadProfile()
        }
    }
}
```

### 1.3 Hybrid Approach (Combining Async/Await with Combine)

```swift
// MARK: - Hybrid API Client

class HybridAPIClient {
    private let baseURL: URL
    private let session: URLSession
    
    init(baseURL: URL, session: URLSession = .shared) {
        self.baseURL = baseURL
        self.session = session
    }
    
    // Async/await method
    func request<T: Decodable>(
        endpoint: String,
        method: HTTPMethod = .get,
        parameters: [String: Any]? = nil,
        headers: [String: String]? = nil
    ) async throws -> T {
        // Implementation as in AsyncAPIClient
        // ...
        
        // Placeholder implementation
        let url = baseURL.appendingPathComponent(endpoint)
        var request = URLRequest(url: url)
        // Configure request...
        
        let (data, response) = try await session.data(for: request)
        
        // Process response...
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw APIError.invalidResponse
        }
        
        return try JSONDecoder().decode(T.self, from: data)
    }
    
    // Combine method that wraps the async method
    func requestPublisher<T: Decodable>(
        endpoint: String,
        method: HTTPMethod = .get,
        parameters: [String: Any]? = nil,
        headers: [String: String]? = nil
    ) -> AnyPublisher<T, Error> {
        return Future { [weak self] promise in
            guard let self = self else {
                promise(.failure(APIError.invalidResponse))
                return
            }
            
            Task {
                do {
                    let result = try await self.request(
                        endpoint: endpoint,
                        method: method,
                        parameters: parameters,
                        headers: headers
                    ) as T
                    
                    promise(.success(result))
                } catch {
                    promise(.failure(error))
                }
            }
        }
        .eraseToAnyPublisher()
    }
}

// MARK: - Combine Extensions for Async/Await

extension Publisher {
    // Convert publisher to async/await
    func asyncFirst() async throws -> Output {
        try await withCheckedThrowingContinuation { continuation in
            var cancellable: AnyCancellable?
            
            cancellable = first()
                .sink(
                    receiveCompletion: { completion in
                        switch completion {
                        case .finished:
                            break
                        case .failure(let error):
                            continuation.resume(throwing: error)
                        }
                        
                        cancellable?.cancel()
                    },
                    receiveValue: { value in
                        continuation.resume(returning: value)
                        cancellable?.cancel()
                    }
                )
        }
    }
    
    // Convert publisher to async sequence
    func values() -> AsyncThrowingPublisher<Self> {
        AsyncThrowingPublisher(self)
    }
}

// Async publisher wrapper
struct AsyncThrowingPublisher<P: Publisher>: AsyncSequence {
    typealias Element = P.Output
    typealias AsyncIterator = Iterator
    
    struct Iterator: AsyncIteratorProtocol {
        private let publisher: P
        private var continuation: AsyncThrowingStream<P.Output, Error>.Continuation?
        private var cancellable: AnyCancellable?
        private var stream: AsyncThrowingStream<P.Output, Error>?
        
        init(publisher: P) {
            self.publisher = publisher
            
            let (stream, continuation) = AsyncThrowingStream<P.Output, Error>.makeStream()
            self.stream = stream
            self.continuation = continuation
            
            self.cancellable = publisher.sink(
                receiveCompletion: { completion in
                    switch completion {
                    case .finished:
                        continuation.finish()
                    case .failure(let error):
                        continuation.finish(throwing: error)
                    }
                },
                receiveValue: { value in
                    continuation.yield(value)
                }
            )
        }
        
        mutating func next() async throws -> P.Output? {
            try await stream?.next()
        }
    }
    
    let publisher: P
    
    init(_ publisher: P) {
        self.publisher = publisher
    }
    
    func makeAsyncIterator() -> Iterator {
        Iterator(publisher: publisher)
    }
}

// MARK: - Usage Examples

// Example service using hybrid approach
class HybridUserService {
    private let apiClient: HybridAPIClient
    
    init(apiClient: HybridAPIClient) {
        self.apiClient = apiClient
    }
    
    // Async/await methods
    func getUserProfile() async throws -> UserProfile {
        return try await apiClient.request(endpoint: "users/profile")
    }
    
    func updateUserProfile(name: String, email: String) async throws -> UserProfile {
        return try await apiClient.request(
            endpoint: "users/profile",
            method: .put,
            parameters: ["name": name, "email": email]
        )
    }
    
    // Combine methods
    func getUserProfilePublisher() -> AnyPublisher<UserProfile, Error> {
        return apiClient.requestPublisher(endpoint: "users/profile")
    }
    
    func updateUserProfilePublisher(name: String, email: String) -> AnyPublisher<UserProfile, Error> {
        return apiClient.requestPublisher(
            endpoint: "users/profile",
            method: .put,
            parameters: ["name": name, "email": email]
        )
    }
}

// Example view model using hybrid approach
class HybridProfileViewModel: ObservableObject {
    @Published var profile: UserProfile?
    @Published var isLoading = false
    @Published var error: Error?
    
    private let userService: HybridUserService
    private var cancellables = Set<AnyCancellable>()
    
    init(userService: HybridUserService) {
        self.userService = userService
    }
    
    // Load profile using async/await
    @MainActor
    func loadProfileAsync() async {
        isLoading = true
        error = nil
        
        do {
            profile = try await userService.getUserProfile()
        } catch {
            self.error = error
        }
        
        isLoading = false
    }
    
    // Load profile using Combine
    func loadProfileCombine() {
        isLoading = true
        error = nil
        
        userService.getUserProfilePublisher()
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error
                    }
                },
                receiveValue: { [weak self] profile in
                    self?.profile = profile
                }
            )
            .store(in: &cancellables)
    }
    
    // Convert Combine publisher to async/await
    @MainActor
    func loadProfileHybrid() async {
        isLoading = true
        error = nil
        
        do {
            profile = try await userService.getUserProfilePublisher().asyncFirst()
        } catch {
            self.error = error
        }
        
        isLoading = false
    }
    
    // Process async sequence from publisher
    @MainActor
    func processProfileUpdates() async {
        let profileUpdates = userService.getUserProfilePublisher()
            .receive(on: DispatchQueue.main)
            .values()
        
        do {
            for try await profile in profileUpdates {
                self.profile = profile
                // Process each update as it arrives
            }
        } catch {
            self.error = error
        }
    }
}
```

### 1.4 Recommended Approach for Mac Client

For the OpenHands Mac client, we recommend a hybrid approach that leverages both async/await and Combine:

1. **Use async/await for:**
   - Network requests and file operations
   - Sequential operations with clear dependencies
   - Error handling with try/catch
   - Background processing with Task

2. **Use Combine for:**
   - UI state management and binding
   - Event streams and real-time updates (like Socket.IO events)
   - Reactive data transformations
   - Coordinating multiple asynchronous operations

3. **Integration patterns:**
   - Convert between async/await and Combine using the bridge methods shown above
   - Use @MainActor for UI updates from async code
   - Use Combine's receive(on:) for thread management

This hybrid approach gives us the best of both worlds: the clarity and error handling of async/await with the reactive capabilities of Combine.

## 2. Property Wrapper Usage for State Management

### 2.1 Custom Property Wrappers

```swift
// MARK: - Persistence Property Wrapper

@propertyWrapper
struct Persisted<T: Codable> {
    private let key: String
    private let defaultValue: T
    private let storage: UserDefaults
    
    init(wrappedValue defaultValue: T, key: String, storage: UserDefaults = .standard) {
        self.key = key
        self.defaultValue = defaultValue
        self.storage = storage
    }
    
    var wrappedValue: T {
        get {
            guard let data = storage.data(forKey: key) else {
                return defaultValue
            }
            
            do {
                return try JSONDecoder().decode(T.self, from: data)
            } catch {
                print("Error decoding \(T.self) from UserDefaults: \(error)")
                return defaultValue
            }
        }
        set {
            do {
                let data = try JSONEncoder().encode(newValue)
                storage.set(data, forKey: key)
            } catch {
                print("Error encoding \(T.self) to UserDefaults: \(error)")
            }
        }
    }
    
    var projectedValue: Binding<T> {
        Binding(
            get: { wrappedValue },
            set: { wrappedValue = $0 }
        )
    }
}

// MARK: - Throttled Property Wrapper

@propertyWrapper
class Throttled<T> {
    private var value: T
    private let duration: TimeInterval
    private var lastUpdateTime: Date = .distantPast
    private var timer: Timer?
    private var pendingValue: T?
    
    init(wrappedValue: T, duration: TimeInterval) {
        self.value = wrappedValue
        self.duration = duration
    }
    
    var wrappedValue: T {
        get { value }
        set {
            let now = Date()
            let timeSinceLastUpdate = now.timeIntervalSince(lastUpdateTime)
            
            if timeSinceLastUpdate >= duration {
                // Update immediately
                value = newValue
                lastUpdateTime = now
                pendingValue = nil
                timer?.invalidate()
                timer = nil
            } else {
                // Schedule update
                pendingValue = newValue
                
                if timer == nil {
                    let delay = duration - timeSinceLastUpdate
                    timer = Timer.scheduledTimer(withTimeInterval: delay, repeats: false) { [weak self] _ in
                        guard let self = self, let pendingValue = self.pendingValue else { return }
                        
                        self.value = pendingValue
                        self.lastUpdateTime = Date()
                        self.pendingValue = nil
                        self.timer = nil
                    }
                }
            }
        }
    }
    
    var projectedValue: Binding<T> {
        Binding(
            get: { wrappedValue },
            set: { wrappedValue = $0 }
        )
    }
}

// MARK: - Validated Property Wrapper

@propertyWrapper
struct Validated<T> {
    private var value: T
    private let validator: (T) -> Bool
    private let errorMessage: String
    
    var isValid: Bool {
        validator(value)
    }
    
    var validationError: String? {
        isValid ? nil : errorMessage
    }
    
    init(wrappedValue: T, validator: @escaping (T) -> Bool, errorMessage: String) {
        self.value = wrappedValue
        self.validator = validator
        self.errorMessage = errorMessage
    }
    
    var wrappedValue: T {
        get { value }
        set { value = newValue }
    }
    
    var projectedValue: ValidatedValue<T> {
        ValidatedValue(value: value, isValid: isValid, errorMessage: validationError)
    }
}

struct ValidatedValue<T> {
    let value: T
    let isValid: Bool
    let errorMessage: String?
}

// MARK: - Observable Property Wrapper

@propertyWrapper
class Observable<T> {
    private var value: T
    private var observers: [(T) -> Void] = []
    
    init(wrappedValue: T) {
        self.value = wrappedValue
    }
    
    var wrappedValue: T {
        get { value }
        set {
            value = newValue
            notifyObservers()
        }
    }
    
    var projectedValue: Observable<T> {
        return self
    }
    
    func observe(_ observer: @escaping (T) -> Void) -> ObservationToken {
        observers.append(observer)
        observer(value) // Notify with current value
        
        return ObservationToken { [weak self] in
            self?.observers.removeAll { $0 as AnyObject === observer as AnyObject }
        }
    }
    
    private func notifyObservers() {
        observers.forEach { $0(value) }
    }
}

class ObservationToken {
    private let cancellation: () -> Void
    
    init(cancellation: @escaping () -> Void) {
        self.cancellation = cancellation
    }
    
    func cancel() {
        cancellation()
    }
    
    deinit {
        cancel()
    }
}

// MARK: - Debounced Property Wrapper

@propertyWrapper
class Debounced<T> {
    private var value: T
    private let delay: TimeInterval
    private var timer: Timer?
    
    init(wrappedValue: T, delay: TimeInterval) {
        self.value = wrappedValue
        self.delay = delay
    }
    
    var wrappedValue: T {
        get { value }
        set {
            timer?.invalidate()
            
            timer = Timer.scheduledTimer(withTimeInterval: delay, repeats: false) { [weak self] _ in
                guard let self = self else { return }
                self.value = newValue
                self.timer = nil
            }
        }
    }
    
    var projectedValue: Binding<T> {
        Binding(
            get: { wrappedValue },
            set: { wrappedValue = $0 }
        )
    }
}
```

### 2.2 State Management with Property Wrappers

```swift
// MARK: - App Settings with Property Wrappers

class AppSettings {
    @Persisted(key: "theme")
    var theme: AppTheme = .system
    
    @Persisted(key: "fontSize")
    var fontSize: Int = 14
    
    @Persisted(key: "enableNotifications")
    var enableNotifications: Bool = true
    
    @Persisted(key: "autoSaveInterval")
    var autoSaveInterval: TimeInterval = 60.0
    
    @Persisted(key: "recentFiles")
    var recentFiles: [RecentFile] = []
    
    @Throttled(duration: 0.5)
    var searchQuery: String = ""
    
    @Validated(validator: { $0.count >= 3 }, errorMessage: "Username must be at least 3 characters")
    var username: String = ""
    
    @Observable
    var connectionStatus: ConnectionStatus = .disconnected
    
    @Debounced(delay: 0.3)
    var windowSize: CGSize = .zero
}

// MARK: - View Model with Property Wrappers

class SearchViewModel: ObservableObject {
    @Published var results: [SearchResult] = []
    @Published var isLoading = false
    @Published var error: Error?
    
    @Throttled(duration: 0.5)
    var searchQuery: String = ""
    
    @Persisted(key: "recentSearches")
    var recentSearches: [String] = []
    
    private let searchService: SearchService
    private var cancellables = Set<AnyCancellable>()
    
    init(searchService: SearchService) {
        self.searchService = searchService
        
        // Observe throttled search query changes
        $searchQuery.sink { [weak self] query in
            guard let self = self, !query.isEmpty else { return }
            self.performSearch(query: query)
        }
        .store(in: &cancellables)
    }
    
    private func performSearch(query: String) {
        isLoading = true
        error = nil
        
        searchService.search(query: query)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error
                    } else {
                        // Add to recent searches
                        if !self.recentSearches.contains(query) {
                            self.recentSearches.insert(query, at: 0)
                            
                            // Limit recent searches
                            if self.recentSearches.count > 10 {
                                self.recentSearches = Array(self.recentSearches.prefix(10))
                            }
                        }
                    }
                },
                receiveValue: { [weak self] results in
                    self?.results = results
                }
            )
            .store(in: &cancellables)
    }
}

// MARK: - SwiftUI View with Property Wrappers

struct SettingsView: View {
    @EnvironmentObject var appSettings: AppSettings
    @Environment(\.presentationMode) var presentationMode
    
    @State private var tempUsername: String = ""
    @State private var showUsernameError = false
    
    var body: some View {
        Form {
            Section(header: Text("Appearance")) {
                Picker("Theme", selection: $appSettings.theme) {
                    Text("System").tag(AppTheme.system)
                    Text("Light").tag(AppTheme.light)
                    Text("Dark").tag(AppTheme.dark)
                }
                
                Stepper("Font Size: \(appSettings.fontSize)", value: $appSettings.fontSize, in: 10...24)
            }
            
            Section(header: Text("Notifications")) {
                Toggle("Enable Notifications", isOn: $appSettings.enableNotifications)
            }
            
            Section(header: Text("Auto Save")) {
                Picker("Auto Save Interval", selection: $appSettings.autoSaveInterval) {
                    Text("30 seconds").tag(30.0)
                    Text("1 minute").tag(60.0)
                    Text("5 minutes").tag(300.0)
                    Text("10 minutes").tag(600.0)
                }
            }
            
            Section(header: Text("User Profile")) {
                TextField("Username", text: $tempUsername)
                    .onAppear {
                        tempUsername = appSettings.username
                    }
                
                if showUsernameError, let error = appSettings.$username.errorMessage {
                    Text(error)
                        .foregroundColor(.red)
                        .font(.caption)
                }
                
                Button("Save Username") {
                    appSettings.username = tempUsername
                    showUsernameError = !appSettings.$username.isValid
                }
                .disabled(tempUsername.isEmpty)
            }
            
            Section(header: Text("Recent Files")) {
                if appSettings.recentFiles.isEmpty {
                    Text("No recent files")
                        .foregroundColor(.secondary)
                } else {
                    ForEach(appSettings.recentFiles) { file in
                        Text(file.path)
                    }
                    .onDelete { indexSet in
                        appSettings.recentFiles.remove(atOffsets: indexSet)
                    }
                }
            }
        }
        .navigationTitle("Settings")
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Done") {
                    presentationMode.wrappedValue.dismiss()
                }
            }
        }
    }
}
```

### 2.3 Recommended Property Wrappers for Mac Client

For the OpenHands Mac client, we recommend the following property wrapper usage:

1. **@Published** - For SwiftUI binding and Combine integration
2. **@State, @StateObject, @ObservedObject, @EnvironmentObject** - For SwiftUI state management
3. **@Persisted** - For persistent settings and user preferences
4. **@Throttled** - For search queries and frequent UI updates
5. **@Validated** - For form validation
6. **@Observable** - For non-UI state that needs observation
7. **@Debounced** - For window resizing and other events that should be delayed

These property wrappers provide a clean, declarative way to manage state throughout the application while handling common patterns like persistence, validation, and throttling.

## 3. Dependency Injection Approach

### 3.1 Service Locator Pattern

```swift
// MARK: - Service Locator

class ServiceLocator {
    static let shared = ServiceLocator()
    
    private var services: [String: Any] = [:]
    
    private init() {}
    
    // Register a service
    func register<T>(_ service: T, for type: T.Type) {
        let key = String(describing: type)
        services[key] = service
    }
    
    // Resolve a service
    func resolve<T>(_ type: T.Type) -> T? {
        let key = String(describing: type)
        return services[key] as? T
    }
    
    // Remove a service
    func remove<T>(_ type: T.Type) {
        let key = String(describing: type)
        services.removeValue(forKey: key)
    }
    
    // Clear all services
    func clear() {
        services.removeAll()
    }
}

// MARK: - Service Protocol Definitions

protocol APIClientProtocol {
    func request<T: Decodable>(
        endpoint: String,
        method: HTTPMethod,
        parameters: [String: Any]?,
        headers: [String: String]?
    ) async throws -> T
}

protocol UserServiceProtocol {
    func getUserProfile() async throws -> UserProfile
    func updateUserProfile(name: String, email: String) async throws -> UserProfile
}

protocol AuthServiceProtocol {
    func signIn(email: String, password: String) async throws -> AuthToken
    func signOut() async throws
    func refreshToken() async throws -> AuthToken
    var isAuthenticated: Bool { get }
}

// MARK: - Service Implementations

class APIClient: APIClientProtocol {
    private let baseURL: URL
    
    init(baseURL: URL) {
        self.baseURL = baseURL
    }
    
    func request<T: Decodable>(
        endpoint: String,
        method: HTTPMethod = .get,
        parameters: [String: Any]? = nil,
        headers: [String: String]? = nil
    ) async throws -> T {
        // Implementation...
        fatalError("Not implemented")
    }
}

class UserService: UserServiceProtocol {
    private let apiClient: APIClientProtocol
    
    init(apiClient: APIClientProtocol) {
        self.apiClient = apiClient
    }
    
    func getUserProfile() async throws -> UserProfile {
        return try await apiClient.request(
            endpoint: "users/profile",
            method: .get,
            parameters: nil,
            headers: nil
        )
    }
    
    func updateUserProfile(name: String, email: String) async throws -> UserProfile {
        return try await apiClient.request(
            endpoint: "users/profile",
            method: .put,
            parameters: ["name": name, "email": email],
            headers: nil
        )
    }
}

class AuthService: AuthServiceProtocol {
    private let apiClient: APIClientProtocol
    private var token: AuthToken?
    
    init(apiClient: APIClientProtocol) {
        self.apiClient = apiClient
    }
    
    var isAuthenticated: Bool {
        token != nil && !(token?.isExpired ?? true)
    }
    
    func signIn(email: String, password: String) async throws -> AuthToken {
        let token: AuthToken = try await apiClient.request(
            endpoint: "auth/signin",
            method: .post,
            parameters: ["email": email, "password": password],
            headers: nil
        )
        
        self.token = token
        return token
    }
    
    func signOut() async throws {
        try await apiClient.request(
            endpoint: "auth/signout",
            method: .post,
            parameters: nil,
            headers: nil
        ) as EmptyResponse
        
        token = nil
    }
    
    func refreshToken() async throws -> AuthToken {
        guard let currentToken = token else {
            throw AuthError.notAuthenticated
        }
        
        let token: AuthToken = try await apiClient.request(
            endpoint: "auth/refresh",
            method: .post,
            parameters: ["refreshToken": currentToken.refreshToken],
            headers: nil
        )
        
        self.token = token
        return token
    }
}

// MARK: - Models

struct AuthToken: Codable {
    let accessToken: String
    let refreshToken: String
    let expiresAt: Date
    
    var isExpired: Bool {
        Date() >= expiresAt
    }
}

struct EmptyResponse: Codable {}

enum AuthError: Error {
    case notAuthenticated
    case invalidCredentials
    case tokenExpired
}

// MARK: - Service Registration

func registerServices() {
    let baseURL = URL(string: "https://api.example.com")!
    
    // Create services
    let apiClient = APIClient(baseURL: baseURL)
    let userService = UserService(apiClient: apiClient)
    let authService = AuthService(apiClient: apiClient)
    
    // Register services
    let serviceLocator = ServiceLocator.shared
    serviceLocator.register(apiClient, for: APIClientProtocol.self)
    serviceLocator.register(userService, for: UserServiceProtocol.self)
    serviceLocator.register(authService, for: AuthServiceProtocol.self)
}

// MARK: - Service Usage

class ProfileViewModel: ObservableObject {
    @Published var profile: UserProfile?
    @Published var isLoading = false
    @Published var error: Error?
    
    private let userService: UserServiceProtocol
    
    init(userService: UserServiceProtocol? = nil) {
        // Use provided service or resolve from service locator
        self.userService = userService ?? ServiceLocator.shared.resolve(UserServiceProtocol.self)!
    }
    
    @MainActor
    func loadProfile() async {
        isLoading = true
        error = nil
        
        do {
            profile = try await userService.getUserProfile()
        } catch {
            self.error = error
        }
        
        isLoading = false
    }
}
```

### 3.2 Property Injection

```swift
// MARK: - Property Injection

protocol Injectable {}

@propertyWrapper
struct Inject<T> {
    private var service: T
    
    init() {
        guard let resolvedService = ServiceLocator.shared.resolve(T.self) else {
            fatalError("Failed to resolve service of type \(T.self)")
        }
        
        self.service = resolvedService
    }
    
    var wrappedValue: T {
        get { return service }
        mutating set { service = newValue }
    }
}

// MARK: - Usage

class UserProfileViewModel: ObservableObject, Injectable {
    @Inject private var userService: UserServiceProtocol
    @Inject private var authService: AuthServiceProtocol
    
    @Published var profile: UserProfile?
    @Published var isLoading = false
    @Published var error: Error?
    
    @MainActor
    func loadProfile() async {
        guard authService.isAuthenticated else {
            error = AuthError.notAuthenticated
            return
        }
        
        isLoading = true
        error = nil
        
        do {
            profile = try await userService.getUserProfile()
        } catch {
            self.error = error
        }
        
        isLoading = false
    }
}
```

### 3.3 Factory Pattern

```swift
// MARK: - Factory Pattern

protocol ViewModelFactory {
    func makeProfileViewModel() -> ProfileViewModel
    func makeSettingsViewModel() -> SettingsViewModel
    func makeSearchViewModel() -> SearchViewModel
}

class DefaultViewModelFactory: ViewModelFactory {
    private let serviceLocator: ServiceLocator
    
    init(serviceLocator: ServiceLocator = .shared) {
        self.serviceLocator = serviceLocator
    }
    
    func makeProfileViewModel() -> ProfileViewModel {
        guard let userService = serviceLocator.resolve(UserServiceProtocol.self) else {
            fatalError("Failed to resolve UserService")
        }
        
        return ProfileViewModel(userService: userService)
    }
    
    func makeSettingsViewModel() -> SettingsViewModel {
        guard let userService = serviceLocator.resolve(UserServiceProtocol.self),
              let appSettings = serviceLocator.resolve(AppSettings.self) else {
            fatalError("Failed to resolve services for SettingsViewModel")
        }
        
        return SettingsViewModel(userService: userService, appSettings: appSettings)
    }
    
    func makeSearchViewModel() -> SearchViewModel {
        guard let searchService = serviceLocator.resolve(SearchService.self) else {
            fatalError("Failed to resolve SearchService")
        }
        
        return SearchViewModel(searchService: searchService)
    }
}

// MARK: - Usage with Factory

class AppCoordinator {
    private let viewModelFactory: ViewModelFactory
    
    init(viewModelFactory: ViewModelFactory = DefaultViewModelFactory()) {
        self.viewModelFactory = viewModelFactory
    }
    
    func makeProfileView() -> some View {
        let viewModel = viewModelFactory.makeProfileViewModel()
        return ProfileView(viewModel: viewModel)
    }
    
    func makeSettingsView() -> some View {
        let viewModel = viewModelFactory.makeSettingsViewModel()
        return SettingsView(viewModel: viewModel)
    }
    
    func makeSearchView() -> some View {
        let viewModel = viewModelFactory.makeSearchViewModel()
        return SearchView(viewModel: viewModel)
    }
}
```

### 3.4 Environment Values

```swift
// MARK: - Environment Values

// Define environment keys
private struct UserServiceKey: EnvironmentKey {
    static let defaultValue: UserServiceProtocol = MockUserService()
}

private struct AuthServiceKey: EnvironmentKey {
    static let defaultValue: AuthServiceProtocol = MockAuthService()
}

private struct APIClientKey: EnvironmentKey {
    static let defaultValue: APIClientProtocol = MockAPIClient()
}

// Extend EnvironmentValues
extension EnvironmentValues {
    var userService: UserServiceProtocol {
        get { self[UserServiceKey.self] }
        set { self[UserServiceKey.self] = newValue }
    }
    
    var authService: AuthServiceProtocol {
        get { self[AuthServiceKey.self] }
        set { self[AuthServiceKey.self] = newValue }
    }
    
    var apiClient: APIClientProtocol {
        get { self[APIClientKey.self] }
        set { self[APIClientKey.self] = newValue }
    }
}

// Mock implementations for default values
class MockUserService: UserServiceProtocol {
    func getUserProfile() async throws -> UserProfile {
        throw NSError(domain: "MockUserService", code: -1, userInfo: [NSLocalizedDescriptionKey: "Not implemented"])
    }
    
    func updateUserProfile(name: String, email: String) async throws -> UserProfile {
        throw NSError(domain: "MockUserService", code: -1, userInfo: [NSLocalizedDescriptionKey: "Not implemented"])
    }
}

class MockAuthService: AuthServiceProtocol {
    var isAuthenticated: Bool = false
    
    func signIn(email: String, password: String) async throws -> AuthToken {
        throw NSError(domain: "MockAuthService", code: -1, userInfo: [NSLocalizedDescriptionKey: "Not implemented"])
    }
    
    func signOut() async throws {
        throw NSError(domain: "MockAuthService", code: -1, userInfo: [NSLocalizedDescriptionKey: "Not implemented"])
    }
    
    func refreshToken() async throws -> AuthToken {
        throw NSError(domain: "MockAuthService", code: -1, userInfo: [NSLocalizedDescriptionKey: "Not implemented"])
    }
}

class MockAPIClient: APIClientProtocol {
    func request<T: Decodable>(
        endpoint: String,
        method: HTTPMethod,
        parameters: [String: Any]?,
        headers: [String: String]?
    ) async throws -> T {
        throw NSError(domain: "MockAPIClient", code: -1, userInfo: [NSLocalizedDescriptionKey: "Not implemented"])
    }
}

// MARK: - Usage with Environment

struct ProfileEnvironmentView: View {
    @Environment(\.userService) private var userService
    @Environment(\.authService) private var authService
    
    @StateObject private var viewModel = ProfileEnvironmentViewModel()
    
    var body: some View {
        VStack {
            if viewModel.isLoading {
                ProgressView()
            } else if let profile = viewModel.profile {
                Text("Name: \(profile.name)")
                Text("Email: \(profile.email)")
                
                Button("Refresh") {
                    Task {
                        await viewModel.loadProfile()
                    }
                }
            } else if let error = viewModel.error {
                Text("Error: \(error.localizedDescription)")
                
                Button("Retry") {
                    Task {
                        await viewModel.loadProfile()
                    }
                }
            }
        }
        .onAppear {
            // Inject dependencies from environment
            viewModel.userService = userService
            viewModel.authService = authService
            
            Task {
                await viewModel.loadProfile()
            }
        }
    }
}

class ProfileEnvironmentViewModel: ObservableObject {
    @Published var profile: UserProfile?
    @Published var isLoading = false
    @Published var error: Error?
    
    var userService: UserServiceProtocol!
    var authService: AuthServiceProtocol!
    
    @MainActor
    func loadProfile() async {
        guard let userService = userService, let authService = authService else {
            error = NSError(domain: "ProfileViewModel", code: -1, userInfo: [NSLocalizedDescriptionKey: "Services not initialized"])
            return
        }
        
        guard authService.isAuthenticated else {
            error = AuthError.notAuthenticated
            return
        }
        
        isLoading = true
        error = nil
        
        do {
            profile = try await userService.getUserProfile()
        } catch {
            self.error = error
        }
        
        isLoading = false
    }
}

// Set up environment in app
struct MainApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(\.userService, UserService(apiClient: APIClient(baseURL: URL(string: "https://api.example.com")!)))
                .environment(\.authService, AuthService(apiClient: APIClient(baseURL: URL(string: "https://api.example.com")!)))
                .environment(\.apiClient, APIClient(baseURL: URL(string: "https://api.example.com")!))
        }
    }
}
```

### 3.5 Recommended Dependency Injection Approach for Mac Client

For the OpenHands Mac client, we recommend a hybrid approach to dependency injection:

1. **Service Locator Pattern** for global services:
   - Core services like API clients, Socket.IO manager, and authentication
   - Persistence managers and cache managers
   - Logging and analytics services

2. **Property Injection** for view models:
   - Use the `@Inject` property wrapper for cleaner dependency injection
   - Makes testing easier by allowing mock services to be injected

3. **Factory Pattern** for complex object creation:
   - ViewModelFactory for creating view models with proper dependencies
   - ServiceFactory for creating services with proper configuration

4. **Environment Values** for SwiftUI integration:
   - Use for services that need to be accessible throughout the view hierarchy
   - Particularly useful for theme, localization, and user preferences

This hybrid approach provides flexibility while maintaining clean architecture and testability. The Service Locator pattern gives us a central place to register and resolve dependencies, while property injection and factories provide a clean way to use those dependencies in our code.

## 4. Implementation Guidelines

### 4.1 Recommended Swift Features

1. **Swift Concurrency**:
   - Use `async/await` for asynchronous operations
   - Use `Task` for background work
   - Use `@MainActor` for UI updates

2. **Combine**:
   - Use for reactive programming and data binding
   - Use for event streams and real-time updates
   - Use for coordinating multiple asynchronous operations

3. **Property Wrappers**:
   - Use `@Published` for SwiftUI binding
   - Use custom property wrappers for persistence, validation, etc.

4. **Result Builders**:
   - Use for building complex UI hierarchies
   - Use for building complex query expressions

5. **Actors**:
   - Use for thread-safe state management
   - Use for isolating mutable state

### 4.2 Code Organization

1. **Module Structure**:
   - Core: Base protocols, extensions, and utilities
   - Services: API clients, Socket.IO, file system, etc.
   - Models: Data models and state
   - ViewModels: Business logic and state management
   - Views: UI components and screens
   - Coordinators: Navigation and flow control

2. **File Organization**:
   - Group related files together
   - Use extensions for protocol conformance
   - Keep files focused on a single responsibility

3. **Naming Conventions**:
   - Use clear, descriptive names
   - Use verb-noun pairs for actions (e.g., `loadProfile()`)
   - Use noun phrases for properties (e.g., `userProfile`)
   - Use protocol names that describe capabilities (e.g., `UserServiceProtocol`)

### 4.3 Testing Approach

1. **Unit Testing**:
   - Test services and view models
   - Use dependency injection for testability
   - Use mock objects for dependencies

2. **UI Testing**:
   - Test key user flows
   - Use accessibility identifiers for UI elements
   - Use test plans for different configurations

3. **Test Doubles**:
   - Use mocks for verifying interactions
   - Use stubs for providing test data
   - Use fakes for simulating complex behavior

This implementation guide provides a comprehensive approach to Swift implementation details for the Mac client, covering concurrency, property wrappers, and dependency injection patterns.

---

# tasks/impl_ui.md

# UI Component Architecture for Mac Client

This document outlines the UI component architecture for the Mac client, including component breakdown, view hierarchy, navigation flow, and MVVM implementation for each feature.

## 1. UI Component Breakdown

### 1.1 Core Components

```swift
// MARK: - Core UI Components

// Base text field with common styling and behavior
struct OHTextField: View {
    let title: String
    @Binding var text: String
    var placeholder: String = ""
    var isSecure: Bool = false
    var keyboardType: UIKeyboardType = .default
    var onSubmit: (() -> Void)?
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(title)
                .font(.caption)
                .foregroundColor(.secondary)
            
            if isSecure {
                SecureField(placeholder, text: $text)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .onSubmit {
                        onSubmit?()
                    }
            } else {
                TextField(placeholder, text: $text)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .keyboardType(keyboardType)
                    .onSubmit {
                        onSubmit?()
                    }
            }
        }
        .padding(.vertical, 4)
    }
}

// Primary button with consistent styling
struct OHPrimaryButton: View {
    let title: String
    let action: () -> Void
    var isLoading: Bool = false
    var isDisabled: Bool = false
    
    var body: some View {
        Button(action: {
            if !isLoading && !isDisabled {
                action()
            }
        }) {
            HStack {
                if isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle())
                        .scaleEffect(0.8)
                        .padding(.trailing, 5)
                }
                
                Text(title)
                    .fontWeight(.medium)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 10)
        }
        .buttonStyle(.borderedProminent)
        .disabled(isDisabled || isLoading)
    }
}

// Secondary button with consistent styling
struct OHSecondaryButton: View {
    let title: String
    let action: () -> Void
    var isLoading: Bool = false
    var isDisabled: Bool = false
    
    var body: some View {
        Button(action: {
            if !isLoading && !isDisabled {
                action()
            }
        }) {
            HStack {
                if isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle())
                        .scaleEffect(0.8)
                        .padding(.trailing, 5)
                }
                
                Text(title)
                    .fontWeight(.medium)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 10)
        }
        .buttonStyle(.bordered)
        .disabled(isDisabled || isLoading)
    }
}

// Card container with consistent styling
struct OHCard<Content: View>: View {
    let content: Content
    var padding: CGFloat = 16
    var cornerRadius: CGFloat = 12
    
    init(padding: CGFloat = 16, cornerRadius: CGFloat = 12, @ViewBuilder content: () -> Content) {
        self.content = content()
        self.padding = padding
        self.cornerRadius = cornerRadius
    }
    
    var body: some View {
        content
            .padding(padding)
            .background(Color(NSColor.controlBackgroundColor))
            .cornerRadius(cornerRadius)
            .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1)
    }
}

// Section header with consistent styling
struct OHSectionHeader: View {
    let title: String
    var showDivider: Bool = true
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(title)
                .font(.headline)
                .foregroundColor(.primary)
            
            if showDivider {
                Divider()
            }
        }
        .padding(.vertical, 8)
    }
}

// Empty state view
struct OHEmptyStateView: View {
    let title: String
    let message: String
    var icon: String = "doc.text"
    var action: (() -> Void)?
    var actionTitle: String?
    
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: icon)
                .font(.system(size: 48))
                .foregroundColor(.secondary)
            
            Text(title)
                .font(.headline)
                .multilineTextAlignment(.center)
            
            Text(message)
                .font(.subheadline)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
            
            if let action = action, let actionTitle = actionTitle {
                Button(actionTitle, action: action)
                    .buttonStyle(.bordered)
                    .padding(.top, 8)
            }
        }
        .padding()
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

// Loading overlay
struct OHLoadingOverlay: View {
    let message: String
    
    var body: some View {
        ZStack {
            Color(NSColor.windowBackgroundColor)
                .opacity(0.7)
            
            VStack(spacing: 16) {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle())
                    .scaleEffect(1.5)
                
                Text(message)
                    .font(.headline)
            }
            .padding(24)
            .background(Color(NSColor.controlBackgroundColor))
            .cornerRadius(12)
            .shadow(radius: 10)
        }
        .edgesIgnoringSafeArea(.all)
    }
}

// Toast notification
struct OHToast: View {
    let message: String
    let type: ToastType
    let onDismiss: () -> Void
    
    enum ToastType {
        case success
        case error
        case info
        case warning
    }
    
    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: iconName)
                .foregroundColor(iconColor)
            
            Text(message)
                .foregroundColor(.primary)
            
            Spacer()
            
            Button(action: onDismiss) {
                Image(systemName: "xmark")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            .buttonStyle(PlainButtonStyle())
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
        .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
        .padding(.horizontal)
    }
    
    private var iconName: String {
        switch type {
        case .success:
            return "checkmark.circle.fill"
        case .error:
            return "exclamationmark.circle.fill"
        case .info:
            return "info.circle.fill"
        case .warning:
            return "exclamationmark.triangle.fill"
        }
    }
    
    private var iconColor: Color {
        switch type {
        case .success:
            return .green
        case .error:
            return .red
        case .info:
            return .blue
        case .warning:
            return .yellow
        }
    }
}

// Sidebar item
struct OHSidebarItem: View {
    let title: String
    let icon: String
    var badge: Int? = nil
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Image(systemName: icon)
                    .frame(width: 24)
                
                Text(title)
                    .fontWeight(isSelected ? .semibold : .regular)
                
                Spacer()
                
                if let badge = badge, badge > 0 {
                    Text("\(badge)")
                        .font(.caption)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.accentColor)
                        .foregroundColor(.white)
                        .clipShape(Capsule())
                }
            }
            .padding(.vertical, 8)
            .padding(.horizontal, 12)
            .background(isSelected ? Color.accentColor.opacity(0.1) : Color.clear)
            .cornerRadius(6)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

// Code block view
struct OHCodeBlockView: View {
    let code: String
    let language: String
    
    @State private var isExpanded = false
    @State private var isCopied = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header
            HStack {
                Text(language.uppercased())
                    .font(.caption)
                    .fontWeight(.semibold)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Button(action: {
                    NSPasteboard.general.clearContents()
                    NSPasteboard.general.setString(code, forType: .string)
                    
                    isCopied = true
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                        isCopied = false
                    }
                }) {
                    Label(isCopied ? "Copied" : "Copy", systemImage: isCopied ? "checkmark" : "doc.on.doc")
                        .font(.caption)
                }
                .buttonStyle(PlainButtonStyle())
                
                Button(action: {
                    isExpanded.toggle()
                }) {
                    Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                        .font(.caption)
                }
                .buttonStyle(PlainButtonStyle())
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 8)
            .background(Color(NSColor.controlBackgroundColor))
            
            Divider()
            
            // Code content
            ScrollView([.horizontal, .vertical]) {
                Text(code)
                    .font(.system(.body, design: .monospaced))
                    .padding(12)
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
            .frame(height: isExpanded ? nil : 200)
        }
        .background(Color(NSColor.textBackgroundColor))
        .cornerRadius(8)
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(Color.gray.opacity(0.2), lineWidth: 1)
        )
    }
}

// Markdown content view
struct OHMarkdownView: View {
    let content: String
    
    var body: some View {
        ScrollView {
            Text(LocalizedStringKey(content))
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding()
        }
    }
}
```

### 1.2 Conversation Components

```swift
// MARK: - Conversation Components

// Message bubble
struct OHMessageBubble: View {
    let message: Message
    var onCodeBlockTap: ((String, String) -> Void)?
    
    var body: some View {
        HStack(alignment: .top) {
            if message.source == .user {
                Spacer()
            }
            
            VStack(alignment: message.source == .user ? .trailing : .leading, spacing: 4) {
                // Message content
                MessageContentView(message: message, onCodeBlockTap: onCodeBlockTap)
                
                // Timestamp
                Text(message.timestamp, style: .time)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            .padding(12)
            .background(backgroundColor)
            .cornerRadius(12)
            .shadow(color: Color.black.opacity(0.05), radius: 1, x: 0, y: 1)
            
            if message.source == .agent {
                Spacer()
            }
        }
        .padding(.horizontal)
        .padding(.vertical, 4)
    }
    
    private var backgroundColor: Color {
        switch message.source {
        case .user:
            return Color.accentColor.opacity(0.1)
        case .agent:
            return Color(NSColor.controlBackgroundColor)
        case .system:
            return Color.gray.opacity(0.1)
        }
    }
}

// Message content view
struct MessageContentView: View {
    let message: Message
    var onCodeBlockTap: ((String, String) -> Void)?
    
    @State private var parsedContent: [MessageContentBlock] = []
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            ForEach(parsedContent, id: \.id) { block in
                switch block.type {
                case .text:
                    Text(block.content)
                        .frame(maxWidth: .infinity, alignment: .leading)
                
                case .code:
                    OHCodeBlockView(code: block.content, language: block.language ?? "text")
                        .onTapGesture {
                            onCodeBlockTap?(block.content, block.language ?? "text")
                        }
                
                case .image:
                    if let url = URL(string: block.content) {
                        AsyncImage(url: url) { phase in
                            switch phase {
                            case .empty:
                                ProgressView()
                            case .success(let image):
                                image
                                    .resizable()
                                    .aspectRatio(contentMode: .fit)
                                    .cornerRadius(8)
                            case .failure:
                                Image(systemName: "photo")
                                    .foregroundColor(.secondary)
                            @unknown default:
                                EmptyView()
                            }
                        }
                        .frame(maxWidth: 300, maxHeight: 300)
                    }
                }
            }
        }
        .onAppear {
            parsedContent = parseMessageContent(message.content)
        }
    }
    
    // Parse message content into blocks
    private func parseMessageContent(_ content: String) -> [MessageContentBlock] {
        var blocks: [MessageContentBlock] = []
        
        // Simple parser for demonstration
        // In a real implementation, use a proper Markdown parser
        
        let codeBlockRegex = try! NSRegularExpression(pattern: "```([a-zA-Z0-9]*)\\s*\\n([\\s\\S]*?)\\n```", options: [])
        let imageRegex = try! NSRegularExpression(pattern: "!\\[(.*?)\\]\\((.*?)\\)", options: [])
        
        let nsContent = content as NSString
        var lastIndex = 0
        
        // Find code blocks
        let codeMatches = codeBlockRegex.matches(in: content, options: [], range: NSRange(location: 0, length: nsContent.length))
        
        for match in codeMatches {
            // Add text before code block
            if match.range.location > lastIndex {
                let textRange = NSRange(location: lastIndex, length: match.range.location - lastIndex)
                let textContent = nsContent.substring(with: textRange)
                
                if !textContent.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                    blocks.append(MessageContentBlock(type: .text, content: textContent))
                }
            }
            
            // Add code block
            let languageRange = match.range(at: 1)
            let codeRange = match.range(at: 2)
            
            let language = languageRange.location != NSNotFound ? nsContent.substring(with: languageRange) : "text"
            let code = codeRange.location != NSNotFound ? nsContent.substring(with: codeRange) : ""
            
            blocks.append(MessageContentBlock(type: .code, content: code, language: language))
            
            lastIndex = match.range.location + match.range.length
        }
        
        // Add remaining text
        if lastIndex < nsContent.length {
            let textRange = NSRange(location: lastIndex, length: nsContent.length - lastIndex)
            let textContent = nsContent.substring(with: textRange)
            
            // Find images in the remaining text
            let imageMatches = imageRegex.matches(in: textContent, options: [], range: NSRange(location: 0, length: textContent.count))
            
            if imageMatches.isEmpty {
                blocks.append(MessageContentBlock(type: .text, content: textContent))
            } else {
                var textLastIndex = 0
                
                for match in imageMatches {
                    // Add text before image
                    if match.range.location > textLastIndex {
                        let subTextRange = NSRange(location: textLastIndex, length: match.range.location - textLastIndex)
                        let subTextContent = (textContent as NSString).substring(with: subTextRange)
                        
                        if !subTextContent.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                            blocks.append(MessageContentBlock(type: .text, content: subTextContent))
                        }
                    }
                    
                    // Add image
                    let urlRange = match.range(at: 2)
                    let url = urlRange.location != NSNotFound ? (textContent as NSString).substring(with: urlRange) : ""
                    
                    blocks.append(MessageContentBlock(type: .image, content: url))
                    
                    textLastIndex = match.range.location + match.range.length
                }
                
                // Add remaining text
                if textLastIndex < textContent.count {
                    let subTextRange = NSRange(location: textLastIndex, length: textContent.count - textLastIndex)
                    let subTextContent = (textContent as NSString).substring(with: subTextRange)
                    
                    if !subTextContent.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                        blocks.append(MessageContentBlock(type: .text, content: subTextContent))
                    }
                }
            }
        }
        
        return blocks
    }
}

// Message content block
struct MessageContentBlock {
    let id = UUID()
    let type: MessageContentType
    let content: String
    var language: String?
    
    enum MessageContentType {
        case text
        case code
        case image
    }
}

// Message input view
struct OHMessageInputView: View {
    @Binding var message: String
    let onSend: () -> Void
    var isLoading: Bool = false
    
    var body: some View {
        VStack(spacing: 0) {
            Divider()
            
            HStack(spacing: 12) {
                // Text input
                TextField("Type a message...", text: $message, axis: .vertical)
                    .textFieldStyle(PlainTextFieldStyle())
                    .padding(10)
                    .background(Color(NSColor.textBackgroundColor))
                    .cornerRadius(8)
                    .lineLimit(1...5)
                
                // Send button
                Button(action: {
                    if !message.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty && !isLoading {
                        onSend()
                    }
                }) {
                    if isLoading {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                            .frame(width: 36, height: 36)
                    } else {
                        Image(systemName: "paperplane.fill")
                            .foregroundColor(.white)
                            .frame(width: 36, height: 36)
                            .background(Color.accentColor)
                            .cornerRadius(18)
                    }
                }
                .buttonStyle(PlainButtonStyle())
                .disabled(message.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty || isLoading)
            }
            .padding()
        }
        .background(Color(NSColor.windowBackgroundColor))
    }
}

// Conversation header
struct OHConversationHeader: View {
    let title: String
    var status: ConversationStatus = .active
    var onTitleEdit: ((String) -> Void)?
    var onClose: (() -> Void)?
    
    @State private var isEditing = false
    @State private var editedTitle = ""
    
    var body: some View {
        HStack {
            // Status indicator
            Circle()
                .fill(statusColor)
                .frame(width: 8, height: 8)
            
            // Title
            if isEditing {
                TextField("Conversation title", text: $editedTitle, onCommit: {
                    isEditing = false
                    if !editedTitle.isEmpty {
                        onTitleEdit?(editedTitle)
                    } else {
                        editedTitle = title
                    }
                })
                .textFieldStyle(PlainTextFieldStyle())
                .padding(4)
                .background(Color(NSColor.textBackgroundColor))
                .cornerRadius(4)
            } else {
                Text(title)
                    .fontWeight(.semibold)
                    .onTapGesture(count: 2) {
                        if onTitleEdit != nil {
                            isEditing = true
                            editedTitle = title
                        }
                    }
            }
            
            Spacer()
            
            // Close button
            if let onClose = onClose {
                Button(action: onClose) {
                    Image(systemName: "xmark")
                        .foregroundColor(.secondary)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding()
        .background(Color(NSColor.windowBackgroundColor))
    }
    
    private var statusColor: Color {
        switch status {
        case .active:
            return .green
        case .completed:
            return .blue
        case .error:
            return .red
        }
    }
}

// Conversation list item
struct OHConversationListItem: View {
    let conversation: Conversation
    let isSelected: Bool
    let onSelect: () -> Void
    
    var body: some View {
        Button(action: onSelect) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(conversation.title)
                        .fontWeight(isSelected ? .semibold : .regular)
                        .lineLimit(1)
                    
                    Text(conversationPreview)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .lineLimit(1)
                }
                
                Spacer()
                
                VStack(alignment: .trailing, spacing: 4) {
                    Text(conversation.lastUpdated, style: .time)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    
                    if conversation.unreadCount > 0 {
                        Text("\(conversation.unreadCount)")
                            .font(.caption)
                            .padding(.horizontal, 6)
                            .padding(.vertical, 2)
                            .background(Color.accentColor)
                            .foregroundColor(.white)
                            .clipShape(Capsule())
                    }
                }
            }
            .padding(.vertical, 8)
            .padding(.horizontal, 12)
            .background(isSelected ? Color.accentColor.opacity(0.1) : Color.clear)
            .cornerRadius(6)
        }
        .buttonStyle(PlainButtonStyle())
    }
    
    private var conversationPreview: String {
        if let lastMessage = conversation.messages.last {
            return lastMessage.content.prefix(50).replacingOccurrences(of: "\n", with: " ")
        } else if let draft = conversation.localDraft, !draft.isEmpty {
            return "Draft: \(draft.prefix(40))"
        } else {
            return "No messages"
        }
    }
}
```

### 1.3 File Explorer Components

```swift
// MARK: - File Explorer Components

// File item view
struct OHFileItemView: View {
    let file: FileItem
    let isSelected: Bool
    let onSelect: () -> Void
    
    var body: some View {
        Button(action: onSelect) {
            HStack {
                // File icon
                Image(systemName: file.isDirectory ? "folder.fill" : fileIcon)
                    .foregroundColor(file.isDirectory ? .blue : iconColor)
                    .frame(width: 24)
                
                // File name
                Text(file.name)
                    .fontWeight(isSelected ? .semibold : .regular)
                
                Spacer()
                
                // File size or item count
                if file.isDirectory {
                    if let itemCount = file.itemCount {
                        Text("\(itemCount) items")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                } else {
                    if let size = file.size {
                        Text(formatFileSize(size))
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }
            .padding(.vertical, 6)
            .padding(.horizontal, 12)
            .background(isSelected ? Color.accentColor.opacity(0.1) : Color.clear)
            .cornerRadius(6)
        }
        .buttonStyle(PlainButtonStyle())
    }
    
    private var fileIcon: String {
        switch file.extension?.lowercased() {
        case "pdf":
            return "doc.fill"
        case "jpg", "jpeg", "png", "gif":
            return "photo.fill"
        case "mp4", "mov", "avi":
            return "film.fill"
        case "mp3", "wav", "aac":
            return "music.note"
        case "zip", "rar", "tar", "gz":
            return "archivebox.fill"
        case "swift", "java", "cpp", "c", "h", "py", "js", "html", "css":
            return "doc.plaintext.fill"
        case "md", "txt":
            return "doc.text.fill"
        case "json", "xml", "yaml", "yml":
            return "curlybraces"
        default:
            return "doc.fill"
        }
    }
    
    private var iconColor: Color {
        switch file.extension?.lowercased() {
        case "pdf":
            return .red
        case "jpg", "jpeg", "png", "gif":
            return .green
        case "mp4", "mov", "avi":
            return .purple
        case "mp3", "wav", "aac":
            return .pink
        case "zip", "rar", "tar", "gz":
            return .orange
        case "swift", "java", "cpp", "c", "h", "py", "js", "html", "css":
            return .blue
        case "md", "txt":
            return .gray
        case "json", "xml", "yaml", "yml":
            return .yellow
        default:
            return .gray
        }
    }
    
    private func formatFileSize(_ size: Int) -> String {
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = [.useAll]
        formatter.countStyle = .file
        return formatter.string(fromByteCount: Int64(size))
    }
}

// File path breadcrumb
struct OHFileBreadcrumbView: View {
    let path: String
    let onNavigate: (String) -> Void
    
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 4) {
                ForEach(pathComponents.indices, id: \.self) { index in
                    if index > 0 {
                        Image(systemName: "chevron.right")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    
                    Button(action: {
                        let path = pathComponents[0...index].joined(separator: "/")
                        onNavigate(path)
                    }) {
                        Text(pathComponents[index])
                            .foregroundColor(.primary)
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
            .padding(.vertical, 8)
            .padding(.horizontal, 12)
        }
        .background(Color(NSColor.controlBackgroundColor))
    }
    
    private var pathComponents: [String] {
        var components = path.split(separator: "/").map(String.init)
        if components.isEmpty {
            components = ["/"]
        } else {
            components.insert("/", at: 0)
        }
        return components
    }
}

// File explorer toolbar
struct OHFileExplorerToolbar: View {
    let onNewFolder: () -> Void
    let onRefresh: () -> Void
    let onUpload: () -> Void
    let onSearch: (String) -> Void
    
    @State private var searchText = ""
    
    var body: some View {
        HStack {
            // Search field
            HStack {
                Image(systemName: "magnifyingglass")
                    .foregroundColor(.secondary)
                
                TextField("Search files", text: $searchText, onCommit: {
                    onSearch(searchText)
                })
                .textFieldStyle(PlainTextFieldStyle())
                
                if !searchText.isEmpty {
                    Button(action: {
                        searchText = ""
                        onSearch("")
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.secondary)
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
            .padding(6)
            .background(Color(NSColor.textBackgroundColor))
            .cornerRadius(6)
            
            Spacer()
            
            // Action buttons
            Button(action: onNewFolder) {
                Image(systemName: "folder.badge.plus")
            }
            .buttonStyle(PlainButtonStyle())
            .help("New Folder")
            
            Button(action: onRefresh) {
                Image(systemName: "arrow.clockwise")
            }
            .buttonStyle(PlainButtonStyle())
            .help("Refresh")
            
            Button(action: onUpload) {
                Image(systemName: "square.and.arrow.up")
            }
            .buttonStyle(PlainButtonStyle())
            .help("Upload")
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .background(Color(NSColor.windowBackgroundColor))
    }
}

// File preview
struct OHFilePreviewView: View {
    let file: FileItem
    let content: String?
    var isLoading: Bool = false
    
    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Image(systemName: fileIcon)
                    .foregroundColor(iconColor)
                
                Text(file.name)
                    .fontWeight(.semibold)
                
                Spacer()
                
                if let size = file.size {
                    Text(formatFileSize(size))
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            .padding()
            .background(Color(NSColor.windowBackgroundColor))
            
            Divider()
            
            // Content
            if isLoading {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle())
                    .scaleEffect(1.5)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if let content = content {
                if isImageFile {
                    if let image = NSImage(contentsOfFile: file.path) {
                        Image(nsImage: image)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .padding()
                    } else {
                        Text("Unable to load image")
                            .foregroundColor(.secondary)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                    }
                } else if isPDFFile {
                    if let url = URL(string: "file://\(file.path)") {
                        PDFKitView(url: url)
                    } else {
                        Text("Unable to load PDF")
                            .foregroundColor(.secondary)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                    }
                } else {
                    ScrollView {
                        if isCodeFile {
                            OHCodeBlockView(code: content, language: file.extension ?? "text")
                                .padding()
                        } else if isMarkdownFile {
                            OHMarkdownView(content: content)
                        } else {
                            Text(content)
                                .font(.body)
                                .padding()
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                    }
                }
            } else {
                Text("No preview available")
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            }
        }
    }
    
    private var fileIcon: String {
        switch file.extension?.lowercased() {
        case "pdf":
            return "doc.fill"
        case "jpg", "jpeg", "png", "gif":
            return "photo.fill"
        case "mp4", "mov", "avi":
            return "film.fill"
        case "mp3", "wav", "aac":
            return "music.note"
        case "zip", "rar", "tar", "gz":
            return "archivebox.fill"
        case "swift", "java", "cpp", "c", "h", "py", "js", "html", "css":
            return "doc.plaintext.fill"
        case "md", "txt":
            return "doc.text.fill"
        case "json", "xml", "yaml", "yml":
            return "curlybraces"
        default:
            return "doc.fill"
        }
    }
    
    private var iconColor: Color {
        switch file.extension?.lowercased() {
        case "pdf":
            return .red
        case "jpg", "jpeg", "png", "gif":
            return .green
        case "mp4", "mov", "avi":
            return .purple
        case "mp3", "wav", "aac":
            return .pink
        case "zip", "rar", "tar", "gz":
            return .orange
        case "swift", "java", "cpp", "c", "h", "py", "js", "html", "css":
            return .blue
        case "md", "txt":
            return .gray
        case "json", "xml", "yaml", "yml":
            return .yellow
        default:
            return .gray
        }
    }
    
    private var isImageFile: Bool {
        ["jpg", "jpeg", "png", "gif"].contains(file.extension?.lowercased())
    }
    
    private var isPDFFile: Bool {
        file.extension?.lowercased() == "pdf"
    }
    
    private var isCodeFile: Bool {
        ["swift", "java", "cpp", "c", "h", "py", "js", "html", "css", "json", "xml", "yaml", "yml"].contains(file.extension?.lowercased())
    }
    
    private var isMarkdownFile: Bool {
        file.extension?.lowercased() == "md"
    }
    
    private func formatFileSize(_ size: Int) -> String {
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = [.useAll]
        formatter.countStyle = .file
        return formatter.string(fromByteCount: Int64(size))
    }
}

// PDF view wrapper
struct PDFKitView: NSViewRepresentable {
    let url: URL
    
    func makeNSView(context: Context) -> PDFView {
        let pdfView = PDFView()
        pdfView.autoScales = true
        pdfView.displayMode = .singlePage
        pdfView.displayDirection = .vertical
        return pdfView
    }
    
    func updateNSView(_ pdfView: PDFView, context: Context) {
        if let document = PDFDocument(url: url) {
            pdfView.document = document
        }
    }
}
```

## 2. View Hierarchy and Navigation Flow

### 2.1 Main Window Structure

```swift
// MARK: - Main Window Structure

// Main window content view
struct MainContentView: View {
    @StateObject private var navigationViewModel = NavigationViewModel()
    
    var body: some View {
        NavigationSplitView {
            // Sidebar
            SidebarView(navigationViewModel: navigationViewModel)
        } content: {
            // Content list
            ContentListView(navigationViewModel: navigationViewModel)
        } detail: {
            // Detail view
            DetailView(navigationViewModel: navigationViewModel)
        }
        .navigationSplitViewStyle(.balanced)
    }
}

// Navigation view model
class NavigationViewModel: ObservableObject {
    @Published var selectedSidebarItem: SidebarItem = .conversations
    @Published var selectedConversationId: String?
    @Published var selectedFilePath: String?
    
    enum SidebarItem {
        case conversations
        case files
        case settings
    }
    
    // Select conversation
    func selectConversation(_ id: String) {
        selectedSidebarItem = .conversations
        selectedConversationId = id
        selectedFilePath = nil
    }
    
    // Select file
    func selectFile(_ path: String) {
        selectedSidebarItem = .files
        selectedFilePath = path
        selectedConversationId = nil
    }
    
    // Select settings
    func selectSettings() {
        selectedSidebarItem = .settings
        selectedConversationId = nil
        selectedFilePath = nil
    }
}

// Sidebar view
struct SidebarView: View {
    @ObservedObject var navigationViewModel: NavigationViewModel
    
    var body: some View {
        List {
            Section(header: Text("OpenHands")) {
                OHSidebarItem(
                    title: "Conversations",
                    icon: "bubble.left.and.bubble.right",
                    isSelected: navigationViewModel.selectedSidebarItem == .conversations,
                    action: {
                        navigationViewModel.selectedSidebarItem = .conversations
                    }
                )
                
                OHSidebarItem(
                    title: "Files",
                    icon: "folder",
                    isSelected: navigationViewModel.selectedSidebarItem == .files,
                    action: {
                        navigationViewModel.selectedSidebarItem = .files
                    }
                )
            }
            
            Section(header: Text("App")) {
                OHSidebarItem(
                    title: "Settings",
                    icon: "gear",
                    isSelected: navigationViewModel.selectedSidebarItem == .settings,
                    action: {
                        navigationViewModel.selectSettings()
                    }
                )
            }
        }
        .listStyle(SidebarListStyle())
        .frame(minWidth: 200)
    }
}

// Content list view
struct ContentListView: View {
    @ObservedObject var navigationViewModel: NavigationViewModel
    
    var body: some View {
        Group {
            switch navigationViewModel.selectedSidebarItem {
            case .conversations:
                ConversationListView(navigationViewModel: navigationViewModel)
            case .files:
                FileExplorerListView(navigationViewModel: navigationViewModel)
            case .settings:
                EmptyView()
            }
        }
        .frame(minWidth: 250)
    }
}

// Detail view
struct DetailView: View {
    @ObservedObject var navigationViewModel: NavigationViewModel
    
    var body: some View {
        Group {
            switch navigationViewModel.selectedSidebarItem {
            case .conversations:
                if let conversationId = navigationViewModel.selectedConversationId {
                    ConversationDetailView(conversationId: conversationId)
                } else {
                    OHEmptyStateView(
                        title: "No Conversation Selected",
                        message: "Select a conversation from the list or create a new one.",
                        icon: "bubble.left.and.bubble.right"
                    )
                }
            case .files:
                if let filePath = navigationViewModel.selectedFilePath {
                    FileDetailView(filePath: filePath)
                } else {
                    OHEmptyStateView(
                        title: "No File Selected",
                        message: "Select a file from the explorer to view its contents.",
                        icon: "doc.text"
                    )
                }
            case .settings:
                SettingsView()
            }
        }
    }
}
```

### 2.2 Conversation Flow

```swift
// MARK: - Conversation Flow

// Conversation list view
struct ConversationListView: View {
    @ObservedObject var navigationViewModel: NavigationViewModel
    @StateObject private var viewModel = ConversationListViewModel()
    
    var body: some View {
        VStack(spacing: 0) {
            // Toolbar
            HStack {
                Text("Conversations")
                    .font(.headline)
                
                Spacer()
                
                Button(action: {
                    viewModel.createNewConversation()
                }) {
                    Image(systemName: "plus")
                }
                .buttonStyle(PlainButtonStyle())
                .help("New Conversation")
            }
            .padding()
            .background(Color(NSColor.windowBackgroundColor))
            
            Divider()
            
            // Conversation list
            if viewModel.isLoading {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle())
                    .scaleEffect(1.5)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if viewModel.conversations.isEmpty {
                OHEmptyStateView(
                    title: "No Conversations",
                    message: "Start a new conversation to chat with the agent.",
                    icon: "bubble.left.and.bubble.right",
                    action: {
                        viewModel.createNewConversation()
                    },
                    actionTitle: "New Conversation"
                )
            } else {
                List {
                    ForEach(viewModel.conversations) { conversation in
                        OHConversationListItem(
                            conversation: conversation,
                            isSelected: navigationViewModel.selectedConversationId == conversation.id,
                            onSelect: {
                                navigationViewModel.selectConversation(conversation.id)
                            }
                        )
                        .contextMenu {
                            Button("Rename") {
                                viewModel.startRenaming(conversation)
                            }
                            
                            Button("Delete") {
                                viewModel.deleteConversation(conversation)
                            }
                        }
                    }
                }
                .listStyle(PlainListStyle())
            }
        }
        .sheet(item: $viewModel.conversationToRename) { conversation in
            RenameConversationView(
                conversation: conversation,
                onRename: { newTitle in
                    viewModel.renameConversation(conversation, newTitle: newTitle)
                },
                onCancel: {
                    viewModel.conversationToRename = nil
                }
            )
        }
        .alert(item: $viewModel.error) { error in
            Alert(
                title: Text("Error"),
                message: Text(error.localizedDescription),
                dismissButton: .default(Text("OK"))
            )
        }
    }
}

// Rename conversation view
struct RenameConversationView: View {
    let conversation: Conversation
    let onRename: (String) -> Void
    let onCancel: () -> Void
    
    @State private var title: String
    @Environment(\.presentationMode) var presentationMode
    
    init(conversation: Conversation, onRename: @escaping (String) -> Void, onCancel: @escaping () -> Void) {
        self.conversation = conversation
        self.onRename = onRename
        self.onCancel = onCancel
        _title = State(initialValue: conversation.title)
    }
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Rename Conversation")
                .font(.headline)
            
            TextField("Conversation title", text: $title)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .padding(.horizontal)
            
            HStack {
                Button("Cancel") {
                    onCancel()
                    presentationMode.wrappedValue.dismiss()
                }
                
                Button("Rename") {
                    if !title.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                        onRename(title)
                        presentationMode.wrappedValue.dismiss()
                    }
                }
                .disabled(title.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
            }
            .padding()
        }
        .padding()
        .frame(width: 300)
    }
}

// Conversation detail view
struct ConversationDetailView: View {
    let conversationId: String
    @StateObject private var viewModel: ConversationViewModel
    
    init(conversationId: String) {
        self.conversationId = conversationId
        _viewModel = StateObject(wrappedValue: ConversationViewModel(conversationId: conversationId))
    }
    
    var body: some View {
        VStack(spacing: 0) {
            // Conversation header
            OHConversationHeader(
                title: viewModel.conversation?.title ?? "Loading...",
                status: viewModel.conversation?.status ?? .active,
                onTitleEdit: { newTitle in
                    viewModel.updateTitle(newTitle)
                }
            )
            
            Divider()
            
            // Messages
            if viewModel.isLoading {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle())
                    .scaleEffect(1.5)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if let conversation = viewModel.conversation {
                if conversation.messages.isEmpty {
                    OHEmptyStateView(
                        title: "No Messages",
                        message: "Start the conversation by sending a message.",
                        icon: "bubble.left.and.bubble.right"
                    )
                } else {
                    ScrollViewReader { scrollView in
                        ScrollView {
                            LazyVStack(spacing: 0) {
                                ForEach(conversation.messages) { message in
                                    OHMessageBubble(
                                        message: message,
                                        onCodeBlockTap: { code, language in
                                            viewModel.handleCodeBlockTap(code: code, language: language)
                                        }
                                    )
                                    .id(message.id)
                                }
                                
                                if viewModel.isAgentResponding {
                                    HStack {
                                        OHMessageBubble(
                                            message: Message(
                                                id: "typing",
                                                source: .agent,
                                                content: "Thinking...",
                                                timestamp: Date(),
                                                metadata: nil,
                                                sequence: conversation.messages.count,
                                                isAcknowledged: true
                                            )
                                        )
                                        
                                        Spacer()
                                    }
                                    .id("typing")
                                }
                            }
                            .padding(.vertical)
                        }
                        .onChange(of: conversation.messages.count) { _ in
                            if let lastMessage = conversation.messages.last {
                                scrollView.scrollTo(lastMessage.id, anchor: .bottom)
                            }
                        }
                        .onChange(of: viewModel.isAgentResponding) { isResponding in
                            if isResponding {
                                scrollView.scrollTo("typing", anchor: .bottom)
                            }
                        }
                        .onAppear {
                            if let lastMessage = conversation.messages.last {
                                scrollView.scrollTo(lastMessage.id, anchor: .bottom)
                            }
                        }
                    }
                }
            } else {
                OHEmptyStateView(
                    title: "Conversation Not Found",
                    message: "The conversation you're looking for doesn't exist or couldn't be loaded.",
                    icon: "exclamationmark.triangle"
                )
            }
            
            // Message input
            OHMessageInputView(
                message: $viewModel.messageText,
                onSend: {
                    viewModel.sendMessage()
                },
                isLoading: viewModel.isAgentResponding
            )
        }
        .sheet(item: $viewModel.codeBlockToShow) { codeBlock in
            CodeBlockDetailView(
                code: codeBlock.code,
                language: codeBlock.language
            )
        }
        .alert(item: $viewModel.error) { error in
            Alert(
                title: Text("Error"),
                message: Text(error.localizedDescription),
                dismissButton: .default(Text("OK"))
            )
        }
    }
}

// Code block detail view
struct CodeBlockDetailView: View {
    let code: String
    let language: String
    
    @State private var isCopied = false
    @Environment(\.presentationMode) var presentationMode
    
    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Text(language.uppercased())
                    .font(.headline)
                
                Spacer()
                
                Button(action: {
                    NSPasteboard.general.clearContents()
                    NSPasteboard.general.setString(code, forType: .string)
                    
                    isCopied = true
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                        isCopied = false
                    }
                }) {
                    Label(isCopied ? "Copied" : "Copy", systemImage: isCopied ? "checkmark" : "doc.on.doc")
                }
                .buttonStyle(.bordered)
                
                Button(action: {
                    presentationMode.wrappedValue.dismiss()
                }) {
                    Image(systemName: "xmark")
                }
                .buttonStyle(.bordered)
            }
            .padding()
            .background(Color(NSColor.windowBackgroundColor))
            
            Divider()
            
            // Code content
            ScrollView([.horizontal, .vertical]) {
                Text(code)
                    .font(.system(.body, design: .monospaced))
                    .padding()
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
        }
        .frame(width: 600, height: 400)
    }
}
```

### 2.3 File Explorer Flow

```swift
// MARK: - File Explorer Flow

// File explorer list view
struct FileExplorerListView: View {
    @ObservedObject var navigationViewModel: NavigationViewModel
    @StateObject private var viewModel = FileExplorerViewModel()
    
    var body: some View {
        VStack(spacing: 0) {
            // Toolbar
            OHFileExplorerToolbar(
                onNewFolder: {
                    viewModel.showNewFolderDialog()
                },
                onRefresh: {
                    viewModel.refreshCurrentDirectory()
                },
                onUpload: {
                    viewModel.showUploadDialog()
                },
                onSearch: { query in
                    viewModel.searchFiles(query: query)
                }
            )
            
            Divider()
            
            // Breadcrumb
            OHFileBreadcrumbView(
                path: viewModel.currentPath,
                onNavigate: { path in
                    viewModel.navigateToPath(path)
                }
            )
            
            Divider()
            
            // File list
            if viewModel.isLoading {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle())
                    .scaleEffect(1.5)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if viewModel.files.isEmpty {
                OHEmptyStateView(
                    title: "Empty Directory",
                    message: "This directory is empty.",
                    icon: "folder"
                )
            } else {
                List {
                    ForEach(viewModel.files) { file in
                        OHFileItemView(
                            file: file,
                            isSelected: navigationViewModel.selectedFilePath == file.path,
                            onSelect: {
                                if file.isDirectory {
                                    viewModel.navigateToPath(file.path)
                                } else {
                                    navigationViewModel.selectFile(file.path)
                                }
                            }
                        )
                        .contextMenu {
                            Button("Rename") {
                                viewModel.showRenameDialog(file: file)
                            }
                            
                            Button("Delete") {
                                viewModel.showDeleteConfirmation(file: file)
                            }
                            
                            if !file.isDirectory {
                                Button("Copy Path") {
                                    NSPasteboard.general.clearContents()
                                    NSPasteboard.general.setString(file.path, forType: .string)
                                }
                            }
                        }
                    }
                }
                .listStyle(PlainListStyle())
            }
        }
        .sheet(isPresented: $viewModel.showingNewFolderDialog) {
            NewFolderView(
                currentPath: viewModel.currentPath,
                onCreateFolder: { folderName in
                    viewModel.createFolder(name: folderName)
                },
                onCancel: {
                    viewModel.showingNewFolderDialog = false
                }
            )
        }
        .sheet(isPresented: $viewModel.showingUploadDialog) {
            // This would typically use NSOpenPanel in a real implementation
            Text("Upload Dialog")
                .frame(width: 300, height: 200)
        }
        .sheet(item: $viewModel.fileToRename) { file in
            RenameFileView(
                file: file,
                onRename: { newName in
                    viewModel.renameFile(file: file, newName: newName)
                },
                onCancel: {
                    viewModel.fileToRename = nil
                }
            )
        }
        .alert(item: $viewModel.confirmationAlert) { alert in
            Alert(
                title: Text(alert.title),
                message: Text(alert.message),
                primaryButton: .destructive(Text(alert.confirmButtonTitle)) {
                    alert.action()
                },
                secondaryButton: .cancel()
            )
        }
        .alert(item: $viewModel.error) { error in
            Alert(
                title: Text("Error"),
                message: Text(error.localizedDescription),
                dismissButton: .default(Text("OK"))
            )
        }
    }
}

// New folder view
struct NewFolderView: View {
    let currentPath: String
    let onCreateFolder: (String) -> Void
    let onCancel: () -> Void
    
    @State private var folderName = ""
    @Environment(\.presentationMode) var presentationMode
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Create New Folder")
                .font(.headline)
            
            TextField("Folder name", text: $folderName)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .padding(.horizontal)
            
            HStack {
                Button("Cancel") {
                    onCancel()
                    presentationMode.wrappedValue.dismiss()
                }
                
                Button("Create") {
                    if !folderName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                        onCreateFolder(folderName)
                        presentationMode.wrappedValue.dismiss()
                    }
                }
                .disabled(folderName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
            }
            .padding()
        }
        .padding()
        .frame(width: 300)
    }
}

// Rename file view
struct RenameFileView: View {
    let file: FileItem
    let onRename: (String) -> Void
    let onCancel: () -> Void
    
    @State private var fileName: String
    @Environment(\.presentationMode) var presentationMode
    
    init(file: FileItem, onRename: @escaping (String) -> Void, onCancel: @escaping () -> Void) {
        self.file = file
        self.onRename = onRename
        self.onCancel = onCancel
        _fileName = State(initialValue: file.name)
    }
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Rename \(file.isDirectory ? "Folder" : "File")")
                .font(.headline)
            
            TextField("Name", text: $fileName)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .padding(.horizontal)
            
            HStack {
                Button("Cancel") {
                    onCancel()
                    presentationMode.wrappedValue.dismiss()
                }
                
                Button("Rename") {
                    if !fileName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                        onRename(fileName)
                        presentationMode.wrappedValue.dismiss()
                    }
                }
                .disabled(fileName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
            }
            .padding()
        }
        .padding()
        .frame(width: 300)
    }
}

// File detail view
struct FileDetailView: View {
    let filePath: String
    @StateObject private var viewModel: FileDetailViewModel
    
    init(filePath: String) {
        self.filePath = filePath
        _viewModel = StateObject(wrappedValue: FileDetailViewModel(filePath: filePath))
    }
    
    var body: some View {
        VStack(spacing: 0) {
            if viewModel.isLoading {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle())
                    .scaleEffect(1.5)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if let file = viewModel.file {
                OHFilePreviewView(
                    file: file,
                    content: viewModel.fileContent,
                    isLoading: viewModel.isLoadingContent
                )
            } else {
                OHEmptyStateView(
                    title: "File Not Found",
                    message: "The file you're looking for doesn't exist or couldn't be loaded.",
                    icon: "exclamationmark.triangle"
                )
            }
        }
        .alert(item: $viewModel.error) { error in
            Alert(
                title: Text("Error"),
                message: Text(error.localizedDescription),
                dismissButton: .default(Text("OK"))
            )
        }
    }
}
```

### 2.4 Settings Flow

```swift
// MARK: - Settings Flow

// Settings view
struct SettingsView: View {
    @StateObject private var viewModel = SettingsViewModel()
    
    var body: some View {
        ScrollView {
            VStack(spacing: 24) {
                // General settings
                OHCard {
                    VStack(alignment: .leading, spacing: 16) {
                        OHSectionHeader(title: "General")
                        
                        Picker("Theme", selection: $viewModel.theme) {
                            Text("System").tag(AppTheme.system)
                            Text("Light").tag(AppTheme.light)
                            Text("Dark").tag(AppTheme.dark)
                        }
                        .pickerStyle(SegmentedPickerStyle())
                        
                        Stepper("Font Size: \(viewModel.fontSize)", value: $viewModel.fontSize, in: 10...24)
                        
                        Toggle("Enable Notifications", isOn: $viewModel.enableNotifications)
                    }
                }
                
                // Account settings
                OHCard {
                    VStack(alignment: .leading, spacing: 16) {
                        OHSectionHeader(title: "Account")
                        
                        if viewModel.isSignedIn {
                            HStack {
                                VStack(alignment: .leading, spacing: 4) {
                                    Text(viewModel.userEmail)
                                        .font(.headline)
                                    
                                    Text("Signed in")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                }
                                
                                Spacer()
                                
                                Button("Sign Out") {
                                    viewModel.signOut()
                                }
                                .buttonStyle(.bordered)
                            }
                        } else {
                            OHPrimaryButton(
                                title: "Sign In",
                                action: {
                                    viewModel.showSignInDialog()
                                }
                            )
                        }
                    }
                }
                
                // Storage settings
                OHCard {
                    VStack(alignment: .leading, spacing: 16) {
                        OHSectionHeader(title: "Storage")
                        
                        HStack {
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Cache Size")
                                    .font(.headline)
                                
                                Text(viewModel.cacheSize)
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            Button("Clear Cache") {
                                viewModel.clearCache()
                            }
                            .buttonStyle(.bordered)
                        }
                    }
                }
                
                // About
                OHCard {
                    VStack(alignment: .leading, spacing: 16) {
                        OHSectionHeader(title: "About")
                        
                        HStack {
                            VStack(alignment: .leading, spacing: 4) {
                                Text("OpenHands Mac Client")
                                    .font(.headline)
                                
                                Text("Version \(viewModel.appVersion)")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            Button("Check for Updates") {
                                viewModel.checkForUpdates()
                            }
                            .buttonStyle(.bordered)
                        }
                    }
                }
            }
            .padding()
        }
        .sheet(isPresented: $viewModel.showingSignInDialog) {
            SignInView(
                onSignIn: { email, password in
                    viewModel.signIn(email: email, password: password)
                },
                onCancel: {
                    viewModel.showingSignInDialog = false
                }
            )
        }
        .alert(item: $viewModel.alert) { alert in
            Alert(
                title: Text(alert.title),
                message: Text(alert.message),
                dismissButton: .default(Text("OK"))
            )
        }
    }
}

// Sign in view
struct SignInView: View {
    let onSignIn: (String, String) -> Void
    let onCancel: () -> Void
    
    @State private var email = ""
    @State private var password = ""
    @State private var isLoading = false
    @State private var error: String?
    
    @Environment(\.presentationMode) var presentationMode
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Sign In")
                .font(.headline)
            
            OHTextField(
                title: "Email",
                text: $email,
                placeholder: "Enter your email",
                keyboardType: .emailAddress
            )
            
            OHTextField(
                title: "Password",
                text: $password,
                placeholder: "Enter your password",
                isSecure: true
            )
            
            if let error = error {
                Text(error)
                    .foregroundColor(.red)
                    .font(.caption)
            }
            
            HStack {
                OHSecondaryButton(
                    title: "Cancel",
                    action: {
                        onCancel()
                        presentationMode.wrappedValue.dismiss()
                    }
                )
                
                OHPrimaryButton(
                    title: "Sign In",
                    action: {
                        isLoading = true
                        error = nil
                        
                        // Simulate sign in
                        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                            isLoading = false
                            
                            if email.isEmpty || password.isEmpty {
                                error = "Please enter both email and password"
                            } else {
                                onSignIn(email, password)
                                presentationMode.wrappedValue.dismiss()
                            }
                        }
                    },
                    isLoading: isLoading,
                    isDisabled: email.isEmpty || password.isEmpty
                )
            }
            .padding(.top)
        }
        .padding()
        .frame(width: 350)
    }
}
```

## 3. MVVM Implementation for Features

### 3.1 Conversation Feature MVVM

```swift
// MARK: - Conversation List MVVM

// Conversation list view model
class ConversationListViewModel: ObservableObject {
    @Published var conversations: [Conversation] = []
    @Published var isLoading = false
    @Published var error: NSError?
    @Published var conversationToRename: Conversation?
    
    private let conversationService: ConversationService
    private var cancellables = Set<AnyCancellable>()
    
    init(conversationService: ConversationService = ConversationService()) {
        self.conversationService = conversationService
        
        loadConversations()
        setupEventHandling()
    }
    
    // Load conversations
    func loadConversations() {
        isLoading = true
        error = nil
        
        conversationService.getConversations()
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] conversations in
                    self?.conversations = conversations
                }
            )
            .store(in: &cancellables)
    }
    
    // Create new conversation
    func createNewConversation() {
        isLoading = true
        error = nil
        
        conversationService.createConversation(title: "New Conversation")
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] conversation in
                    self?.conversations.insert(conversation, at: 0)
                }
            )
            .store(in: &cancellables)
    }
    
    // Start renaming conversation
    func startRenaming(_ conversation: Conversation) {
        conversationToRename = conversation
    }
    
    // Rename conversation
    func renameConversation(_ conversation: Conversation, newTitle: String) {
        isLoading = true
        error = nil
        
        conversationService.updateConversation(id: conversation.id, title: newTitle)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    self.conversationToRename = nil
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] updatedConversation in
                    guard let self = self else { return }
                    
                    if let index = self.conversations.firstIndex(where: { $0.id == updatedConversation.id }) {
                        self.conversations[index] = updatedConversation
                    }
                }
            )
            .store(in: &cancellables)
    }
    
    // Delete conversation
    func deleteConversation(_ conversation: Conversation) {
        isLoading = true
        error = nil
        
        conversationService.deleteConversation(id: conversation.id)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] success in
                    guard let self = self, success else { return }
                    
                    self.conversations.removeAll { $0.id == conversation.id }
                }
            )
            .store(in: &cancellables)
    }
    
    // Set up event handling
    private func setupEventHandling() {
        // Listen for conversation created events
        NotificationCenter.default.publisher(for: .conversationCreated)
            .compactMap { $0.object as? Conversation }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] conversation in
                guard let self = self else { return }
                
                if !self.conversations.contains(where: { $0.id == conversation.id }) {
                    self.conversations.insert(conversation, at: 0)
                }
            }
            .store(in: &cancellables)
        
        // Listen for conversation updated events
        NotificationCenter.default.publisher(for: .conversationUpdated)
            .compactMap { $0.object as? Conversation }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] conversation in
                guard let self = self else { return }
                
                if let index = self.conversations.firstIndex(where: { $0.id == conversation.id }) {
                    self.conversations[index] = conversation
                }
            }
            .store(in: &cancellables)
        
        // Listen for conversation deleted events
        NotificationCenter.default.publisher(for: .conversationDeleted)
            .compactMap { $0.object as? String }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] conversationId in
                guard let self = self else { return }
                
                self.conversations.removeAll { $0.id == conversationId }
            }
            .store(in: &cancellables)
    }
}

// MARK: - Conversation Detail MVVM

// Conversation view model
class ConversationViewModel: ObservableObject {
    @Published var conversation: Conversation?
    @Published var messageText = ""
    @Published var isLoading = false
    @Published var isAgentResponding = false
    @Published var error: NSError?
    @Published var codeBlockToShow: CodeBlock?
    
    private let conversationId: String
    private let conversationService: ConversationService
    private let messageService: MessageService
    private var cancellables = Set<AnyCancellable>()
    
    init(conversationId: String, conversationService: ConversationService = ConversationService(), messageService: MessageService = MessageService()) {
        self.conversationId = conversationId
        self.conversationService = conversationService
        self.messageService = messageService
        
        loadConversation()
        setupEventHandling()
    }
    
    // Load conversation
    func loadConversation() {
        isLoading = true
        error = nil
        
        conversationService.getConversation(id: conversationId)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] conversation in
                    self?.conversation = conversation
                }
            )
            .store(in: &cancellables)
    }
    
    // Send message
    func sendMessage() {
        guard let conversation = conversation, !messageText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            return
        }
        
        let messageContent = messageText
        messageText = ""
        isAgentResponding = true
        
        messageService.sendMessage(conversationId: conversationId, content: messageContent)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    if case .failure(let error) = completion {
                        self?.error = error as NSError
                        self?.isAgentResponding = false
                    }
                },
                receiveValue: { [weak self] message in
                    guard let self = self else { return }
                    
                    // Add user message to conversation
                    var updatedConversation = conversation
                    updatedConversation.messages.append(message)
                    self.conversation = updatedConversation
                    
                    // Agent will respond via events
                }
            )
            .store(in: &cancellables)
    }
    
    // Update conversation title
    func updateTitle(_ newTitle: String) {
        guard let conversation = conversation else { return }
        
        conversationService.updateConversation(id: conversationId, title: newTitle)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    if case .failure(let error) = completion {
                        self?.error = error as NSError
                    }
                },
                receiveValue: { [weak self] updatedConversation in
                    self?.conversation = updatedConversation
                }
            )
            .store(in: &cancellables)
    }
    
    // Handle code block tap
    func handleCodeBlockTap(code: String, language: String) {
        codeBlockToShow = CodeBlock(code: code, language: language)
    }
    
    // Set up event handling
    private func setupEventHandling() {
        // Listen for message received events
        NotificationCenter.default.publisher(for: .messageReceived)
            .compactMap { $0.object as? MessageEvent }
            .filter { $0.conversationId == self.conversationId }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] event in
                guard let self = self, var conversation = self.conversation else { return }
                
                // Add message to conversation
                conversation.messages.append(event.message)
                self.conversation = conversation
            }
            .store(in: &cancellables)
        
        // Listen for agent thinking events
        NotificationCenter.default.publisher(for: .agentThinking)
            .compactMap { $0.object as? AgentEvent }
            .filter { $0.conversationId == self.conversationId }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.isAgentResponding = true
            }
            .store(in: &cancellables)
        
        // Listen for agent response events
        NotificationCenter.default.publisher(for: .agentResponse)
            .compactMap { $0.object as? AgentResponseEvent }
            .filter { $0.conversationId == self.conversationId }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] event in
                guard let self = self, var conversation = self.conversation else { return }
                
                // Check if message already exists
                if let index = conversation.messages.firstIndex(where: { $0.id == event.messageId }) {
                    // Update existing message
                    conversation.messages[index].content = event.content
                } else {
                    // Add new message
                    let message = Message(
                        id: event.messageId,
                        source: .agent,
                        content: event.content,
                        timestamp: event.timestamp,
                        metadata: event.metadata?.mapValues { $0.value },
                        sequence: conversation.messages.count,
                        isAcknowledged: true
                    )
                    
                    conversation.messages.append(message)
                }
                
                self.conversation = conversation
                self.isAgentResponding = !event.isComplete
            }
            .store(in: &cancellables)
        
        // Listen for agent complete events
        NotificationCenter.default.publisher(for: .agentComplete)
            .compactMap { $0.object as? AgentEvent }
            .filter { $0.conversationId == self.conversationId }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.isAgentResponding = false
            }
            .store(in: &cancellables)
    }
}

// Code block model
struct CodeBlock: Identifiable {
    let id = UUID()
    let code: String
    let language: String
}

// Message event model
struct MessageEvent {
    let conversationId: String
    let message: Message
}

// Agent event model
struct AgentEvent {
    let conversationId: String
}

// Agent response event model
struct AgentResponseEvent {
    let conversationId: String
    let messageId: String
    let content: String
    let isComplete: Bool
    let timestamp: Date
    let metadata: [String: AnyCodable]?
}

// Notification names
extension Notification.Name {
    static let conversationCreated = Notification.Name("com.openhands.mac.conversationCreated")
    static let conversationUpdated = Notification.Name("com.openhands.mac.conversationUpdated")
    static let conversationDeleted = Notification.Name("com.openhands.mac.conversationDeleted")
    static let messageReceived = Notification.Name("com.openhands.mac.messageReceived")
    static let agentThinking = Notification.Name("com.openhands.mac.agentThinking")
    static let agentResponse = Notification.Name("com.openhands.mac.agentResponse")
    static let agentComplete = Notification.Name("com.openhands.mac.agentComplete")
}
```

### 3.2 File Explorer Feature MVVM

```swift
// MARK: - File Explorer MVVM

// File explorer view model
class FileExplorerViewModel: ObservableObject {
    @Published var files: [FileItem] = []
    @Published var currentPath = "/"
    @Published var isLoading = false
    @Published var error: NSError?
    @Published var showingNewFolderDialog = false
    @Published var showingUploadDialog = false
    @Published var fileToRename: FileItem?
    @Published var confirmationAlert: ConfirmationAlert?
    
    private let fileService: FileService
    private var cancellables = Set<AnyCancellable>()
    
    init(fileService: FileService = FileService()) {
        self.fileService = fileService
        
        loadFiles()
        setupEventHandling()
    }
    
    // Load files for current path
    func loadFiles() {
        isLoading = true
        error = nil
        
        fileService.getFiles(path: currentPath)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] files in
                    self?.files = files
                }
            )
            .store(in: &cancellables)
    }
    
    // Navigate to path
    func navigateToPath(_ path: String) {
        currentPath = path
        loadFiles()
    }
    
    // Refresh current directory
    func refreshCurrentDirectory() {
        loadFiles()
    }
    
    // Show new folder dialog
    func showNewFolderDialog() {
        showingNewFolderDialog = true
    }
    
    // Create folder
    func createFolder(name: String) {
        isLoading = true
        error = nil
        
        let folderPath = currentPath.hasSuffix("/") ? "\(currentPath)\(name)" : "\(currentPath)/\(name)"
        
        fileService.createFolder(path: folderPath)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] success in
                    if success {
                        self?.loadFiles()
                    }
                }
            )
            .store(in: &cancellables)
    }
    
    // Show upload dialog
    func showUploadDialog() {
        showingUploadDialog = true
    }
    
    // Upload file
    func uploadFile(url: URL) {
        isLoading = true
        error = nil
        
        fileService.uploadFile(sourceURL: url, destinationPath: currentPath)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] success in
                    if success {
                        self?.loadFiles()
                    }
                }
            )
            .store(in: &cancellables)
    }
    
    // Show rename dialog
    func showRenameDialog(file: FileItem) {
        fileToRename = file
    }
    
    // Rename file
    func renameFile(file: FileItem, newName: String) {
        isLoading = true
        error = nil
        
        let directory = (file.path as NSString).deletingLastPathComponent
        let newPath = "\(directory)/\(newName)"
        
        fileService.renameFile(oldPath: file.path, newPath: newPath)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] success in
                    if success {
                        self?.loadFiles()
                    }
                }
            )
            .store(in: &cancellables)
    }
    
    // Show delete confirmation
    func showDeleteConfirmation(file: FileItem) {
        confirmationAlert = ConfirmationAlert(
            title: "Delete \(file.isDirectory ? "Folder" : "File")",
            message: "Are you sure you want to delete \(file.name)? This action cannot be undone.",
            confirmButtonTitle: "Delete",
            action: { [weak self] in
                self?.deleteFile(file: file)
            }
        )
    }
    
    // Delete file
    func deleteFile(file: FileItem) {
        isLoading = true
        error = nil
        
        fileService.deleteFile(path: file.path)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] success in
                    if success {
                        self?.loadFiles()
                    }
                }
            )
            .store(in: &cancellables)
    }
    
    // Search files
    func searchFiles(query: String) {
        if query.isEmpty {
            loadFiles()
            return
        }
        
        isLoading = true
        error = nil
        
        fileService.searchFiles(path: currentPath, query: query)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] files in
                    self?.files = files
                }
            )
            .store(in: &cancellables)
    }
    
    // Set up event handling
    private func setupEventHandling() {
        // Listen for file created events
        NotificationCenter.default.publisher(for: .fileCreated)
            .compactMap { $0.object as? FileEvent }
            .filter { [weak self] event in
                guard let self = self else { return false }
                let directory = (event.path as NSString).deletingLastPathComponent
                return directory == self.currentPath
            }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.loadFiles()
            }
            .store(in: &cancellables)
        
        // Listen for file updated events
        NotificationCenter.default.publisher(for: .fileUpdated)
            .compactMap { $0.object as? FileEvent }
            .filter { [weak self] event in
                guard let self = self else { return false }
                let directory = (event.path as NSString).deletingLastPathComponent
                return directory == self.currentPath
            }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.loadFiles()
            }
            .store(in: &cancellables)
        
        // Listen for file deleted events
        NotificationCenter.default.publisher(for: .fileDeleted)
            .compactMap { $0.object as? FileEvent }
            .filter { [weak self] event in
                guard let self = self else { return false }
                let directory = (event.path as NSString).deletingLastPathComponent
                return directory == self.currentPath
            }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.loadFiles()
            }
            .store(in: &cancellables)
    }
}

// File detail view model
class FileDetailViewModel: ObservableObject {
    @Published var file: FileItem?
    @Published var fileContent: String?
    @Published var isLoading = false
    @Published var isLoadingContent = false
    @Published var error: NSError?
    
    private let filePath: String
    private let fileService: FileService
    private var cancellables = Set<AnyCancellable>()
    
    init(filePath: String, fileService: FileService = FileService()) {
        self.filePath = filePath
        self.fileService = fileService
        
        loadFile()
    }
    
    // Load file metadata
    func loadFile() {
        isLoading = true
        error = nil
        
        fileService.getFileInfo(path: filePath)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoading = false
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] file in
                    guard let self = self else { return }
                    
                    self.file = file
                    
                    // Load content for text files
                    if !file.isDirectory && self.isTextFile(file) {
                        self.loadFileContent()
                    }
                }
            )
            .store(in: &cancellables)
    }
    
    // Load file content
    func loadFileContent() {
        isLoadingContent = true
        
        fileService.getFileContent(path: filePath)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    guard let self = self else { return }
                    
                    self.isLoadingContent = false
                    
                    if case .failure(let error) = completion {
                        self.error = error as NSError
                    }
                },
                receiveValue: { [weak self] content in
                    self?.fileContent = content
                }
            )
            .store(in: &cancellables)
    }
    
    // Check if file is a text file
    private func isTextFile(_ file: FileItem) -> Bool {
        let textExtensions = [
            "txt", "md", "markdown", "swift", "java", "cpp", "c", "h", "py", "js", "html", "css",
            "json", "xml", "yaml", "yml", "sh", "bash", "zsh", "properties", "config", "ini",
            "log", "csv", "tsv"
        ]
        
        return textExtensions.contains(file.extension?.lowercased() ?? "")
    }
}

// Confirmation alert model
struct ConfirmationAlert: Identifiable {
    let id = UUID()
    let title: String
    let message: String
    let confirmButtonTitle: String
    let action: () -> Void
}

// File event model
struct FileEvent {
    let path: String
}

// Notification names
extension Notification.Name {
    static let fileCreated = Notification.Name("com.openhands.mac.fileCreated")
    static let fileUpdated = Notification.Name("com.openhands.mac.fileUpdated")
    static let fileDeleted = Notification.Name("com.openhands.mac.fileDeleted")
}
```

### 3.3 Settings Feature MVVM

```swift
// MARK: - Settings MVVM

// Settings view model
class SettingsViewModel: ObservableObject {
    @Published var theme: AppTheme {
        didSet {
            settingsService.updateSettings(key: "theme", value: theme.rawValue)
        }
    }
    
    @Published var fontSize: Int {
        didSet {
            settingsService.updateSettings(key: "fontSize", value: fontSize)
        }
    }
    
    @Published var enableNotifications: Bool {
        didSet {
            settingsService.updateSettings(key: "enableNotifications", value: enableNotifications)
        }
    }
    
    @Published var isSignedIn = false
    @Published var userEmail = ""
    @Published var cacheSize = "0 KB"
    @Published var appVersion = "1.0.0"
    
    @Published var showingSignInDialog = false
    @Published var alert: AlertItem?
    
    private let settingsService: SettingsService
    private let authService: AuthService
    private let cacheService: CacheService
    private var cancellables = Set<AnyCancellable>()
    
    init(settingsService: SettingsService = SettingsService(), authService: AuthService = AuthService(), cacheService: CacheService = CacheService()) {
        self.settingsService = settingsService
        self.authService = authService
        self.cacheService = cacheService
        
        // Initialize with default values
        self.theme = .system
        self.fontSize = 14
        self.enableNotifications = true
        
        loadSettings()
        loadAuthStatus()
        loadCacheSize()
        loadAppVersion()
    }
    
    // Load settings
    func loadSettings() {
        settingsService.getSettings()
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { [weak self] settings in
                    guard let self = self else { return }
                    
                    if let themeString = settings["theme"] as? String, let theme = AppTheme(rawValue: themeString) {
                        self.theme = theme
                    }
                    
                    if let fontSize = settings["fontSize"] as? Int {
                        self.fontSize = fontSize
                    }
                    
                    if let enableNotifications = settings["enableNotifications"] as? Bool {
                        self.enableNotifications = enableNotifications
                    }
                }
            )
            .store(in: &cancellables)
    }
    
    // Load authentication status
    func loadAuthStatus() {
        authService.getCurrentUser()
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { [weak self] user in
                    guard let self = self else { return }
                    
                    self.isSignedIn = user != nil
                    self.userEmail = user?.email ?? ""
                }
            )
            .store(in: &cancellables)
    }
    
    // Load cache size
    func loadCacheSize() {
        cacheService.getCacheSize()
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { [weak self] size in
                    self?.cacheSize = size
                }
            )
            .store(in: &cancellables)
    }
    
    // Load app version
    func loadAppVersion() {
        if let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String {
            appVersion = version
        }
    }
    
    // Show sign in dialog
    func showSignInDialog() {
        showingSignInDialog = true
    }
    
    // Sign in
    func signIn(email: String, password: String) {
        authService.signIn(email: email, password: password)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    if case .failure(let error) = completion {
                        self?.alert = AlertItem(
                            title: "Sign In Failed",
                            message: error.localizedDescription
                        )
                    }
                },
                receiveValue: { [weak self] user in
                    guard let self = self else { return }
                    
                    self.isSignedIn = true
                    self.userEmail = user.email
                    self.showingSignInDialog = false
                }
            )
            .store(in: &cancellables)
    }
    
    // Sign out
    func signOut() {
        authService.signOut()
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    if case .failure(let error) = completion {
                        self?.alert = AlertItem(
                            title: "Sign Out Failed",
                            message: error.localizedDescription
                        )
                    }
                },
                receiveValue: { [weak self] success in
                    guard let self = self, success else { return }
                    
                    self.isSignedIn = false
                    self.userEmail = ""
                }
            )
            .store(in: &cancellables)
    }
    
    // Clear cache
    func clearCache() {
        cacheService.clearCache()
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    if case .failure(let error) = completion {
                        self?.alert = AlertItem(
                            title: "Clear Cache Failed",
                            message: error.localizedDescription
                        )
                    }
                },
                receiveValue: { [weak self] success in
                    guard let self = self, success else { return }
                    
                    self.loadCacheSize()
                    
                    self.alert = AlertItem(
                        title: "Cache Cleared",
                        message: "Application cache has been cleared successfully."
                    )
                }
            )
            .store(in: &cancellables)
    }
    
    // Check for updates
    func checkForUpdates() {
        // Simulate update check
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) { [weak self] in
            self?.alert = AlertItem(
                title: "No Updates Available",
                message: "You are running the latest version of the application."
            )
        }
    }
}

// Alert item model
struct AlertItem: Identifiable {
    let id = UUID()
    let title: String
    let message: String
}
```

### 3.4 Service Layer

```swift
// MARK: - Service Layer

// Conversation service
class ConversationService {
    private let apiClient: APIClient
    
    init(apiClient: APIClient = APIClient.shared) {
        self.apiClient = apiClient
    }
    
    // Get all conversations
    func getConversations() -> AnyPublisher<[Conversation], Error> {
        return apiClient.request(endpoint: "conversations")
    }
    
    // Get conversation by ID
    func getConversation(id: String) -> AnyPublisher<Conversation, Error> {
        return apiClient.request(endpoint: "conversations/\(id)")
    }
    
    // Create new conversation
    func createConversation(title: String) -> AnyPublisher<Conversation, Error> {
        return apiClient.request(
            endpoint: "conversations",
            method: .post,
            parameters: ["title": title]
        )
    }
    
    // Update conversation
    func updateConversation(id: String, title: String) -> AnyPublisher<Conversation, Error> {
        return apiClient.request(
            endpoint: "conversations/\(id)",
            method: .put,
            parameters: ["title": title]
        )
    }
    
    // Delete conversation
    func deleteConversation(id: String) -> AnyPublisher<Bool, Error> {
        return apiClient.request(
            endpoint: "conversations/\(id)",
            method: .delete
        )
    }
}

// Message service
class MessageService {
    private let apiClient: APIClient
    
    init(apiClient: APIClient = APIClient.shared) {
        self.apiClient = apiClient
    }
    
    // Send message
    func sendMessage(conversationId: String, content: String) -> AnyPublisher<Message, Error> {
        return apiClient.request(
            endpoint: "conversations/\(conversationId)/messages",
            method: .post,
            parameters: ["content": content]
        )
    }
}

// File service
class FileService {
    private let apiClient: APIClient
    
    init(apiClient: APIClient = APIClient.shared) {
        self.apiClient = apiClient
    }
    
    // Get files in directory
    func getFiles(path: String) -> AnyPublisher<[FileItem], Error> {
        return apiClient.request(
            endpoint: "files",
            parameters: ["path": path]
        )
    }
    
    // Get file info
    func getFileInfo(path: String) -> AnyPublisher<FileItem, Error> {
        return apiClient.request(
            endpoint: "files/info",
            parameters: ["path": path]
        )
    }
    
    // Get file content
    func getFileContent(path: String) -> AnyPublisher<String, Error> {
        return apiClient.request(
            endpoint: "files/content",
            parameters: ["path": path]
        )
    }
    
    // Create folder
    func createFolder(path: String) -> AnyPublisher<Bool, Error> {
        return apiClient.request(
            endpoint: "files/folder",
            method: .post,
            parameters: ["path": path]
        )
    }
    
    // Upload file
    func uploadFile(sourceURL: URL, destinationPath: String) -> AnyPublisher<Bool, Error> {
        return apiClient.uploadFile(
            endpoint: "files/upload",
            fileURL: sourceURL,
            parameters: ["path": destinationPath]
        )
    }
    
    // Rename file
    func renameFile(oldPath: String, newPath: String) -> AnyPublisher<Bool, Error> {
        return apiClient.request(
            endpoint: "files/rename",
            method: .post,
            parameters: [
                "oldPath": oldPath,
                "newPath": newPath
            ]
        )
    }
    
    // Delete file
    func deleteFile(path: String) -> AnyPublisher<Bool, Error> {
        return apiClient.request(
            endpoint: "files/delete",
            method: .delete,
            parameters: ["path": path]
        )
    }
    
    // Search files
    func searchFiles(path: String, query: String) -> AnyPublisher<[FileItem], Error> {
        return apiClient.request(
            endpoint: "files/search",
            parameters: [
                "path": path,
                "query": query
            ]
        )
    }
}

// Settings service
class SettingsService {
    private let userDefaults: UserDefaults
    
    init(userDefaults: UserDefaults = .standard) {
        self.userDefaults = userDefaults
    }
    
    // Get all settings
    func getSettings() -> AnyPublisher<[String: Any], Error> {
        return Future<[String: Any], Error> { promise in
            let settings: [String: Any] = [
                "theme": self.userDefaults.string(forKey: "theme") ?? AppTheme.system.rawValue,
                "fontSize": self.userDefaults.integer(forKey: "fontSize") != 0 ? self.userDefaults.integer(forKey: "fontSize") : 14,
                "enableNotifications": self.userDefaults.bool(forKey: "enableNotifications")
            ]
            
            promise(.success(settings))
        }
        .eraseToAnyPublisher()
    }
    
    // Update setting
    func updateSettings(key: String, value: Any) {
        if let stringValue = value as? String {
            userDefaults.set(stringValue, forKey: key)
        } else if let intValue = value as? Int {
            userDefaults.set(intValue, forKey: key)
        } else if let boolValue = value as? Bool {
            userDefaults.set(boolValue, forKey: key)
        }
    }
}

// Auth service
class AuthService {
    private let apiClient: APIClient
    private let userDefaults: UserDefaults
    
    init(apiClient: APIClient = APIClient.shared, userDefaults: UserDefaults = .standard) {
        self.apiClient = apiClient
        self.userDefaults = userDefaults
    }
    
    // Get current user
    func getCurrentUser() -> AnyPublisher<User?, Error> {
        return Future<User?, Error> { promise in
            if let userData = self.userDefaults.data(forKey: "currentUser"),
               let user = try? JSONDecoder().decode(User.self, from: userData) {
                promise(.success(user))
            } else {
                promise(.success(nil))
            }
        }
        .eraseToAnyPublisher()
    }
    
    // Sign in
    func signIn(email: String, password: String) -> AnyPublisher<User, Error> {
        // In a real app, this would call the API
        return Future<User, Error> { promise in
            // Simulate API call
            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                let user = User(id: UUID().uuidString, email: email, name: "Test User")
                
                // Save user to UserDefaults
                if let userData = try? JSONEncoder().encode(user) {
                    self.userDefaults.set(userData, forKey: "currentUser")
                }
                
                promise(.success(user))
            }
        }
        .eraseToAnyPublisher()
    }
    
    // Sign out
    func signOut() -> AnyPublisher<Bool, Error> {
        return Future<Bool, Error> { promise in
            // Clear user from UserDefaults
            self.userDefaults.removeObject(forKey: "currentUser")
            promise(.success(true))
        }
        .eraseToAnyPublisher()
    }
}

// Cache service
class CacheService {
    private let fileManager = FileManager.default
    
    // Get cache size
    func getCacheSize() -> AnyPublisher<String, Error> {
        return Future<String, Error> { promise in
            do {
                let cacheDirectory = try self.getCacheDirectory()
                let size = try self.directorySize(url: cacheDirectory)
                
                let formatter = ByteCountFormatter()
                formatter.allowedUnits = [.useAll]
                formatter.countStyle = .file
                let sizeString = formatter.string(fromByteCount: Int64(size))
                
                promise(.success(sizeString))
            } catch {
                promise(.failure(error))
            }
        }
        .eraseToAnyPublisher()
    }
    
    // Clear cache
    func clearCache() -> AnyPublisher<Bool, Error> {
        return Future<Bool, Error> { promise in
            do {
                let cacheDirectory = try self.getCacheDirectory()
                let contents = try self.fileManager.contentsOfDirectory(at: cacheDirectory, includingPropertiesForKeys: nil)
                
                for fileURL in contents {
                    try self.fileManager.removeItem(at: fileURL)
                }
                
                promise(.success(true))
            } catch {
                promise(.failure(error))
            }
        }
        .eraseToAnyPublisher()
    }
    
    // Get cache directory
    private func getCacheDirectory() throws -> URL {
        return try fileManager.url(
            for: .cachesDirectory,
            in: .userDomainMask,
            appropriateFor: nil,
            create: true
        )
    }
    
    // Calculate directory size
    private func directorySize(url: URL) throws -> UInt64 {
        let contents = try fileManager.contentsOfDirectory(at: url, includingPropertiesForKeys: nil)
        var size: UInt64 = 0
        
        for fileURL in contents {
            let attributes = try fileManager.attributesOfItem(atPath: fileURL.path)
            if fileURL.hasDirectoryPath {
                size += try directorySize(url: fileURL)
            } else {
                size += attributes[.size] as? UInt64 ?? 0
            }
        }
        
        return size
    }
}

// User model
struct User: Codable {
    let id: String
    let email: String
    let name: String
}

// API client
class APIClient {
    static let shared = APIClient()
    
    private let baseURL: URL
    
    private init() {
        // In a real app, this would be configured from settings
        self.baseURL = URL(string: "https://api.openhands.dev")!
    }
    
    // Generic request method
    func request<T: Decodable>(
        endpoint: String,
        method: HTTPMethod = .get,
        parameters: [String: Any]? = nil
    ) -> AnyPublisher<T, Error> {
        // In a real app, this would make actual API requests
        return Future<T, Error> { promise in
            // Simulate API call
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                // This is just a mock implementation
                // In a real app, this would make actual network requests
                
                // For demonstration purposes, return mock data based on endpoint
                if endpoint.contains("conversations") {
                    if let mockData = self.mockConversationData(endpoint: endpoint, method: method, parameters: parameters) as? T {
                        promise(.success(mockData))
                    } else {
                        promise(.failure(NSError(domain: "APIClient", code: 1, userInfo: [NSLocalizedDescriptionKey: "Invalid mock data"])))
                    }
                } else if endpoint.contains("files") {
                    if let mockData = self.mockFileData(endpoint: endpoint, method: method, parameters: parameters) as? T {
                        promise(.success(mockData))
                    } else {
                        promise(.failure(NSError(domain: "APIClient", code: 1, userInfo: [NSLocalizedDescriptionKey: "Invalid mock data"])))
                    }
                } else {
                    promise(.failure(NSError(domain: "APIClient", code: 1, userInfo: [NSLocalizedDescriptionKey: "Unknown endpoint"])))
                }
            }
        }
        .eraseToAnyPublisher()
    }
    
    // Upload file
    func uploadFile(
        endpoint: String,
        fileURL: URL,
        parameters: [String: String]? = nil
    ) -> AnyPublisher<Bool, Error> {
        // In a real app, this would make actual API requests
        return Future<Bool, Error> { promise in
            // Simulate API call
            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                promise(.success(true))
            }
        }
        .eraseToAnyPublisher()
    }
    
    // Mock conversation data
    private func mockConversationData(endpoint: String, method: HTTPMethod, parameters: [String: Any]?) -> Any? {
        if endpoint == "conversations" {
            if method == .get {
                // Get all conversations
                return [
                    Conversation(
                        id: "1",
                        title: "First Conversation",
                        messages: [
                            Message(
                                id: "1",
                                source: .user,
                                content: "Hello, how can you help me?",
                                timestamp: Date().addingTimeInterval(-3600),
                                metadata: nil,
                                sequence: 0,
                                isAcknowledged: true
                            ),
                            Message(
                                id: "2",
                                source: .agent,
                                content: "I'm here to help you with any questions or tasks you have. What would you like assistance with today?",
                                timestamp: Date().addingTimeInterval(-3500),
                                metadata: nil,
                                sequence: 1,
                                isAcknowledged: true
                            )
                        ],
                        status: .active,
                        lastUpdated: Date().addingTimeInterval(-3500),
                        isArchived: false,
                        localDraft: nil,
                        unreadCount: 0,
                        version: 1
                    ),
                    Conversation(
                        id: "2",
                        title: "Second Conversation",
                        messages: [
                            Message(
                                id: "3",
                                source: .user,
                                content: "Can you help me with a coding problem?",
                                timestamp: Date().addingTimeInterval(-7200),
                                metadata: nil,
                                sequence: 0,
                                isAcknowledged: true
                            ),
                            Message(
                                id: "4",
                                source: .agent,
                                content: "Of course! Please describe the problem you're facing, and I'll do my best to help.",
                                timestamp: Date().addingTimeInterval(-7100),
                                metadata: nil,
                                sequence: 1,
                                isAcknowledged: true
                            )
                        ],
                        status: .active,
                        lastUpdated: Date().addingTimeInterval(-7100),
                        isArchived: false,
                        localDraft: nil,
                        unreadCount: 0,
                        version: 1
                    )
                ]
            } else if method == .post {
                // Create new conversation
                return Conversation(
                    id: UUID().uuidString,
                    title: parameters?["title"] as? String ?? "New Conversation",
                    messages: [],
                    status: .active,
                    lastUpdated: Date(),
                    isArchived: false,
                    localDraft: nil,
                    unreadCount: 0,
                    version: 1
                )
            }
        } else if endpoint.contains("conversations/") {
            let components = endpoint.split(separator: "/")
            if components.count >= 2 {
                let conversationId = String(components[1])
                
                if method == .get {
                    // Get conversation by ID
                    if conversationId == "1" {
                        return Conversation(
                            id: "1",
                            title: "First Conversation",
                            messages: [
                                Message(
                                    id: "1",
                                    source: .user,
                                    content: "Hello, how can you help me?",
                                    timestamp: Date().addingTimeInterval(-3600),
                                    metadata: nil,
                                    sequence: 0,
                                    isAcknowledged: true
                                ),
                                Message(
                                    id: "2",
                                    source: .agent,
                                    content: "I'm here to help you with any questions or tasks you have. What would you like assistance with today?",
                                    timestamp: Date().addingTimeInterval(-3500),
                                    metadata: nil,
                                    sequence: 1,
                                    isAcknowledged: true
                                )
                            ],
                            status: .active,
                            lastUpdated: Date().addingTimeInterval(-3500),
                            isArchived: false,
                            localDraft: nil,
                            unreadCount: 0,
                            version: 1
                        )
                    } else if conversationId == "2" {
                        return Conversation(
                            id: "2",
                            title: "Second Conversation",
                            messages: [
                                Message(
                                    id: "3",
                                    source: .user,
                                    content: "Can you help me with a coding problem?",
                                    timestamp: Date().addingTimeInterval(-7200),
                                    metadata: nil,
                                    sequence: 0,
                                    isAcknowledged: true
                                ),
                                Message(
                                    id: "4",
                                    source: .agent,
                                    content: "Of course! Please describe the problem you're facing, and I'll do my best to help.",
                                    timestamp: Date().addingTimeInterval(-7100),
                                    metadata: nil,
                                    sequence: 1,
                                    isAcknowledged: true
                                )
                            ],
                            status: .active,
                            lastUpdated: Date().addingTimeInterval(-7100),
                            isArchived: false,
                            localDraft: nil,
                            unreadCount: 0,
                            version: 1
                        )
                    }
                } else if method == .put {
                    // Update conversation
                    return Conversation(
                        id: conversationId,
                        title: parameters?["title"] as? String ?? "Updated Conversation",
                        messages: [],
                        status: .active,
                        lastUpdated: Date(),
                        isArchived: false,
                        localDraft: nil,
                        unreadCount: 0,
                        version: 2
                    )
                } else if method == .delete {
                    // Delete conversation
                    return true
                }
                
                // Handle messages
                if components.count >= 4 && components[2] == "messages" {
                    if method == .post {
                        // Send message
                        return Message(
                            id: UUID().uuidString,
                            source: .user,
                            content: parameters?["content"] as? String ?? "",
                            timestamp: Date(),
                            metadata: nil,
                            sequence: 2,
                            isAcknowledged: true
                        )
                    }
                }
            }
        }
        
        return nil
    }
    
    // Mock file data
    private func mockFileData(endpoint: String, method: HTTPMethod, parameters: [String: Any]?) -> Any? {
        if endpoint == "files" {
            // Get files in directory
            let path = parameters?["path"] as? String ?? "/"
            
            if path == "/" {
                return [
                    FileItem(
                        name: "Documents",
                        path: "/Documents",
                        isDirectory: true,
                        size: nil,
                        extension: nil,
                        itemCount: 5
                    ),
                    FileItem(
                        name: "Projects",
                        path: "/Projects",
                        isDirectory: true,
                        size: nil,
                        extension: nil,
                        itemCount: 3
                    ),
                    FileItem(
                        name: "README.md",
                        path: "/README.md",
                        isDirectory: false,
                        size: 1024,
                        extension: "md",
                        itemCount: nil
                    ),
                    FileItem(
                        name: "example.swift",
                        path: "/example.swift",
                        isDirectory: false,
                        size: 2048,
                        extension: "swift",
                        itemCount: nil
                    )
                ]
            } else if path == "/Documents" {
                return [
                    FileItem(
                        name: "Notes",
                        path: "/Documents/Notes",
                        isDirectory: true,
                        size: nil,
                        extension: nil,
                        itemCount: 2
                    ),
                    FileItem(
                        name: "report.pdf",
                        path: "/Documents/report.pdf",
                        isDirectory: false,
                        size: 5120,
                        extension: "pdf",
                        itemCount: nil
                    ),
                    FileItem(
                        name: "presentation.pptx",
                        path: "/Documents/presentation.pptx",
                        isDirectory: false,
                        size: 10240,
                        extension: "pptx",
                        itemCount: nil
                    )
                ]
            }
        } else if endpoint == "files/info" {
            // Get file info
            let path = parameters?["path"] as? String ?? "/"
            
            if path == "/README.md" {
                return FileItem(
                    name: "README.md",
                    path: "/README.md",
                    isDirectory: false,
                    size: 1024,
                    extension: "md",
                    itemCount: nil
                )
            } else if path == "/example.swift" {
                return FileItem(
                    name: "example.swift",
                    path: "/example.swift",
                    isDirectory: false,
                    size: 2048,
                    extension: "swift",
                    itemCount: nil
                )
            }
        } else if endpoint == "files/content" {
            // Get file content
            let path = parameters?["path"] as? String ?? "/"
            
            if path == "/README.md" {
                return "# OpenHands Project\n\nThis is a sample README file for the OpenHands project.\n\n## Features\n\n- Feature 1\n- Feature 2\n- Feature 3"
            } else if path == "/example.swift" {
                return "import Foundation\n\nclass Example {\n    func sayHello() {\n        print(\"Hello, world!\")\n    }\n}"
            }
        } else if endpoint == "files/folder" && method == .post {
            // Create folder
            return true
        } else if endpoint == "files/rename" && method == .post {
            // Rename file
            return true
        } else if endpoint == "files/delete" && method == .delete {
            // Delete file
            return true
        } else if endpoint == "files/search" {
            // Search files
            let query = parameters?["query"] as? String ?? ""
            
            if query.contains("swift") {
                return [
                    FileItem(
                        name: "example.swift",
                        path: "/example.swift",
                        isDirectory: false,
                        size: 2048,
                        extension: "swift",
                        itemCount: nil
                    ),
                    FileItem(
                        name: "main.swift",
                        path: "/Projects/SwiftProject/main.swift",
                        isDirectory: false,
                        size: 1536,
                        extension: "swift",
                        itemCount: nil
                    )
                ]
            }
        }
        
        return nil
    }
}

// HTTP method enum
enum HTTPMethod: String {
    case get = "GET"
    case post = "POST"
    case put = "PUT"
    case delete = "DELETE"
}
```

This implementation guide provides a comprehensive approach to UI component architecture for the Mac client, covering component breakdown, view hierarchy, navigation flow, and MVVM implementation for each feature.

---

# tasks/implementation_guide.md

# OpenHands Mac Client Implementation Guide

This document provides a comprehensive guide for implementing the OpenHands Mac client, summarizing the key components, architecture, and implementation approach.

## 1. Project Overview

The OpenHands Mac client is a native macOS application built with SwiftUI that provides an alternative to the web UI for interacting with the OpenHands backend. The client connects to the same backend service as the web UI, providing a native desktop experience while maintaining full compatibility with the backend API.

### 1.1 Key Features

1. **Task Input Area**: Text input for submitting tasks to the agent
2. **Agent Output Display**: Real-time display of agent actions and outputs
3. **File Explorer**: Browse and view files in the workspace
4. **Control Buttons**: Start, pause, and stop agent execution
5. **Conversation Management**: Create, switch between, and manage multiple conversations
6. **Comprehensive Settings Panel**: Tabbed interface for all client and backend settings

### 1.2 Architecture

The Mac client follows the MVVM (Model-View-ViewModel) architecture pattern:

- **Models**: Data structures representing backend entities (conversations, files, etc.)
- **Views**: SwiftUI components for the user interface
- **ViewModels**: Business logic and state management for views
- **Services**: Communication with the backend API

## 2. Implementation Roadmap

### 2.1 Phase 1: Foundation

1. **Project Setup**
   - Create a new SwiftUI macOS application
   - Set up project structure (Models, Views, ViewModels, Services)
   - Configure build settings and dependencies

2. **Backend Communication**
   - Implement Socket.IO client for real-time communication
   - Implement REST API client for backend operations
   - Create models for API requests and responses

3. **Core Services**
   - Implement `SocketIOManager` for WebSocket communication
   - Implement `APIClient` for REST API calls
   - Implement `SettingsService` for managing application settings

### 2.2 Phase 2: Core UI Components

1. **Main Window Layout**
   - Implement split view layout with resizable panels
   - Set up navigation and toolbar

2. **File Explorer**
   - Implement file tree view with expandable folders
   - Implement file selection and content display
   - Connect to backend file operations

3. **Agent Output Display**
   - Implement scrollable output display
   - Support different content types (text, code, terminal)
   - Implement auto-scrolling with manual override

4. **Task Input Area**
   - Implement multi-line text input
   - Connect to message sending functionality
   - Implement submit button and keyboard shortcuts

5. **Control Buttons**
   - Implement start/pause/stop buttons
   - Connect to agent state management
   - Implement visual state indicators

### 2.3 Phase 3: Integration and Polish

1. **Comprehensive Settings Panel**
   - Implement tabbed settings UI matching all backend config.template.toml options
   - Create separate tabs for different setting categories:
     * **General**: Application preferences, UI settings, theme options
     * **Backend**: Connection URL, authentication, proxy settings
     * **Model**: LLM selection, parameters, context window settings
     * **API Keys**: Secure storage for OpenAI, Anthropic, and other API keys
     * **Execution**: Runtime settings, timeout values, execution preferences
     * **File System**: Workspace paths, file handling preferences
     * **Advanced**: Debug options, experimental features, logging settings
   - Implement validation and persistence for all settings
   - Support backend connection configuration and authentication
   - Add search functionality for quickly finding specific settings
   - Implement secure storage for sensitive information (API keys)
   - Add import/export functionality for settings backup
   - Include inline documentation and tooltips for each setting

2. **Error Handling**
   - Implement error notification system
   - Add recovery options for common errors
   - Improve error reporting and logging

3. **State Synchronization**
   - Ensure consistent state between client and server
   - Handle reconnection and state recovery
   - Implement conflict resolution

4. **Performance Optimization**
   - Optimize large output handling
   - Implement efficient caching strategies
   - Improve UI responsiveness

5. **Accessibility and Localization**
   - Add VoiceOver support
   - Implement keyboard navigation
   - Add localization support (optional for MVP)

## 3. Technical Implementation Details

### 3.1 Backend Communication

The Mac client communicates with the backend through two primary channels:

1. **Socket.IO**: For real-time events and actions
   - Connect to the backend WebSocket server
   - Send `oh_action` events for user actions
   - Receive `oh_event` events for agent outputs
   - Handle reconnection and authentication

2. **REST API**: For configuration and setup
   - Create and manage conversations
   - List and retrieve files
   - Manage settings
   - Handle authentication (if needed)

### 3.1.1 Component-Specific Implementation Details

For detailed implementation guidance on specific components, refer to the dedicated implementation files:

1. **File Explorer**: See [impl_file_explorer.md](impl_file_explorer.md) for comprehensive implementation details of the file tree view, file content display, and backend integration.

2. **Socket.IO Communication**: See [impl_socket_io.md](impl_socket_io.md) for details on real-time communication with the backend.

3. **Backend Connection**: See [impl_backend_connection.md](impl_backend_connection.md) for implementation of the connection management.

4. **State Synchronization**: See [impl_state_sync.md](impl_state_sync.md) for details on maintaining consistent state.

5. **Error Handling**: See [impl_error_handling.md](impl_error_handling.md) for comprehensive error management.

Each component-specific implementation file contains detailed code examples, architecture decisions, and integration guidance.

### 3.2 Data Flow

The data flow in the application follows this pattern:

1. User interacts with the UI (inputs task, clicks button)
2. View calls ViewModel method
3. ViewModel processes the action and calls appropriate service
4. Service sends request to backend (via Socket.IO or REST)
5. Backend processes the request and sends response
6. Service receives response and notifies ViewModel
7. ViewModel updates its state
8. UI automatically updates due to SwiftUI's reactive nature

### 3.3 State Management

The application state is managed through:

1. **ObservableObject ViewModels**: Each major component has a ViewModel that manages its state
2. **Published Properties**: State changes trigger UI updates
3. **Centralized MainViewModel**: Coordinates between components
4. **Persistent Settings**: Stored using UserDefaults or similar mechanism

### 3.4 Error Handling

The error handling strategy includes:

1. **Typed Error Hierarchy**: Structured error types with severity levels
2. **User-Visible Notifications**: Non-intrusive notifications for minor errors
3. **Recovery Options**: Actionable recovery for critical errors
4. **Graceful Degradation**: Maintain functionality when possible

## 4. Key Components and Classes

### 4.1 Services

- **SocketIOManager**: Manages Socket.IO connection and events
- **APIClient**: Handles REST API requests
- **FileService**: Manages file operations
- **ConversationService**: Manages multiple conversations, history, and metadata
- **SettingsService**: Manages comprehensive application settings with tabbed interface
- **ErrorManager**: Handles error reporting and recovery

### 4.2 ViewModels

- **MainViewModel**: Coordinates between components
- **FileExplorerViewModel**: Manages file explorer state
- **AgentOutputViewModel**: Manages agent output display
- **TaskInputViewModel**: Manages task input area
- **AgentControlViewModel**: Manages agent control buttons
- **ConversationViewModel**: Manages multiple conversations and switching
- **SettingsViewModel**: Manages comprehensive tabbed settings panel

### 4.3 Views

- **MainView**: Main application window
- **FileExplorerView**: File tree view
- **AgentOutputView**: Agent output display
- **TaskInputView**: Task input area
- **AgentControlButtons**: Control buttons
- **ConversationListView**: Multiple conversation management interface
- **ConversationTabView**: Tabbed interface for switching conversations
- **SettingsView**: Comprehensive tabbed settings panel
- **ErrorNotificationView**: Error notifications

### 4.4 Models

- **ConversationInfo**: Conversation metadata and status
- **ConversationGroup**: Group of related conversations
- **FileNode**: File or directory in workspace
- **AgentOutput**: Agent output message
- **Settings**: Comprehensive application settings
- **SettingsCategory**: Category of related settings
- **AppError**: Error information

## 5. Implementation Approach

### 5.1 Technology Stack

- **Language**: Swift 5.5+
- **UI Framework**: SwiftUI
- **Concurrency**: Swift async/await
- **Networking**: URLSession, Socket.IO client
- **Persistence**: UserDefaults, Keychain

### 5.2 Development Practices

- **MVVM Architecture**: Clear separation of concerns
- **Protocol-Oriented Design**: Interfaces for testability
- **Dependency Injection**: Services injected into ViewModels
- **Reactive Programming**: SwiftUI's reactive nature
- **Error Handling**: Structured error handling with recovery

### 5.3 Testing Strategy

- **Unit Tests**: Test individual components in isolation
- **Integration Tests**: Test communication with backend
- **UI Tests**: Test user interactions
- **Mock Services**: Use mock services for testing

## 6. MVP Scope and Priorities

### 6.1 Must-Have Features (MVP)

1. **Basic Task Input**: Text input for submitting tasks
2. **Agent Output Display**: Display agent outputs with basic formatting
3. **Read-Only File Explorer**: Browse and view files
4. **Basic Control Buttons**: Start, pause, stop agent
5. **Comprehensive Settings Panel**: Tabbed interface matching all backend config.template.toml options
6. **Backend Connection Settings**: Configure backend connection
7. **Multiple Conversation Management**: Create, switch between, and manage multiple conversations
8. **Conversation History**: View and search conversation history

### 6.2 Nice-to-Have Features (Post-MVP)

1. **Rich Text Input**: Support for formatting and images
2. **Advanced Output Formatting**: Better syntax highlighting and rendering
3. **File Editing**: Edit files directly in the client
4. **Command History**: Browse and reuse previous commands
5. **Offline Support**: Queue actions when offline
6. **Advanced Keyboard Shortcuts**: Comprehensive keyboard navigation and shortcuts
7. **Settings Import/Export**: Export and import settings configurations
8. **Conversation Grouping**: Group conversations by project or topic
9. **Conversation Export**: Export conversation logs for sharing

## 7. Resources and References

### 7.1 Backend API Documentation

- Socket.IO Events: `oh_event` and `oh_action`
- REST API Endpoints for conversations, files, and settings
- Authentication mechanisms

### 7.2 SwiftUI Resources

- Apple's SwiftUI Documentation
- WWDC Sessions on SwiftUI
- SwiftUI Layout and Navigation

### 7.3 Socket.IO Resources

- Socket.IO Swift Client
- Socket.IO Event Handling
- Reconnection Strategies

## 8. Getting Started

1. **Clone the Repository**: Set up the development environment
2. **Install Dependencies**: Socket.IO client, other libraries
3. **Run the Backend**: Start the OpenHands backend locally
4. **Build the Foundation**: Implement core services
5. **Implement UI Components**: Build the user interface
6. **Connect to Backend**: Integrate with backend services
7. **Test and Refine**: Iterate on the implementation

By following this implementation guide, developers can build a functional OpenHands Mac client that provides a native alternative to the web UI while maintaining full compatibility with the backend API.

---

# tasks/spec_api_integration.md

---
name  :  mac_client_api_integration
type  :  task
agent  :  CodeActAgent
---

# OpenHands Mac Client API Integration Specification

This document provides detailed specifications for integrating the Mac client with the OpenHands backend API, including both Socket.IO real-time communication and REST API endpoints.

## 1. Socket.IO Integration

### 1.1 Connection Setup

```swift
// Example Socket.IO connection setup
class SocketIOManager {
    private var socket: SocketIOClient?
    private let manager: SocketManager
    
    init(serverURL: URL, conversationId: String, authToken: String? = nil) {
        var config: SocketIOClientConfiguration = [
            .log(true),
            .compress,
            .forceWebsockets(true),
            .reconnects(true),
            .reconnectAttempts(10),
            .reconnectWait(5),
            .path("/socket.io")
        ]
        
        if let authToken = authToken {
            config.insert(.extraHeaders(["Authorization": "Bearer \(authToken)"]))
        }
        
        manager = SocketManager(socketURL: serverURL, config: config)
        socket = manager.defaultSocket
        
        setupEventHandlers()
    }
    
    private func setupEventHandlers() {
        socket?.on(clientEvent: .connect) { [weak self] _, _ in
            self?.handleConnect()
        }
        
        socket?.on(clientEvent: .disconnect) { [weak self] _, _ in
            self?.handleDisconnect()
        }
        
        socket?.on("oh_event") { [weak self] data, ack in
            self?.handleEvent(data: data, ack: ack)
        }
    }
    
    func connect() {
        socket?.connect()
    }
    
    func disconnect() {
        socket?.disconnect()
    }
    
    func sendAction(action: String, args: [String: Any], timeout: Int? = nil) {
        var payload: [String: Any] = [
            "action": action,
            "args": args
        ]
        
        if let timeout = timeout {
            payload["timeout"] = timeout
        }
        
        socket?.emit("oh_action", payload)
    }
}
```

### 1.2 Event Types and Handling

The Mac client must handle the following event types from the `oh_event` Socket.IO event:

#### Agent State Events

```swift
// Example handling of agent state events
func handleAgentStateEvent(data: [String: Any]) {
    guard let state = data["agent_state"] as? String else { return }
    
    let agentState: AgentState
    switch state {
        case "RUNNING": agentState = .running
        case "PAUSED": agentState = .paused
        case "STOPPED": agentState = .stopped
        case "AWAITING_USER_INPUT": agentState = .awaitingUserInput
        case "FINISHED": agentState = .finished
        case "ERROR": agentState = .error
        default: agentState = .unknown
    }
    
    // Update UI with new agent state
    DispatchQueue.main.async {
        self.updateAgentStateUI(agentState)
    }
}
```

#### Command Execution Events

```swift
// Example handling of command execution events
func handleCommandEvent(data: [String: Any]) {
    guard let observation = data["observation"] as? [String: Any],
          observation["observation"] as? String == "CmdOutputObservation",
          let content = data["content"] as? String,
          let extras = data["extras"] as? [String: Any],
          let command = extras["command"] as? String,
          let exitCode = extras["exit_code"] as? Int else {
        return
    }
    
    let commandOutput = CommandOutput(
        command: command,
        output: content,
        exitCode: exitCode,
        timestamp: Date()
    )
    
    // Update UI with command output
    DispatchQueue.main.async {
        self.appendCommandOutput(commandOutput)
    }
}
```

#### File Operation Events

```swift
// Example handling of file operation events
func handleFileEvent(data: [String: Any]) {
    guard let observation = data["observation"] as? [String: Any],
          let observationType = observation["observation"] as? String,
          observationType == "FileObservation",
          let path = data["path"] as? String else {
        return
    }
    
    // Handle different file operations
    if let content = data["content"] as? String {
        // File read operation
        let fileContent = FileContent(
            path: path,
            content: content,
            timestamp: Date()
        )
        
        DispatchQueue.main.async {
            self.updateFileContent(fileContent)
        }
    } else if let success = data["success"] as? Bool {
        // File write/edit operation
        DispatchQueue.main.async {
            if success {
                self.refreshFileExplorer(path: path)
            } else {
                self.showFileOperationError(path: path)
            }
        }
    }
}
```

#### Message Events

```swift
// Example handling of message events
func handleMessageEvent(data: [String: Any]) {
    guard let content = data["content"] as? String else { return }
    
    let message = Message(
        content: content,
        source: data["source"] as? String ?? "AGENT",
        timestamp: Date()
    )
    
    // Update UI with new message
    DispatchQueue.main.async {
        self.appendMessage(message)
    }
}
```

#### Error Events

```swift
// Example handling of error events
func handleErrorEvent(data: [String: Any]) {
    guard let message = data["message"] as? String else { return }
    
    let errorEvent = ErrorEvent(
        message: message,
        code: data["code"] as? Int,
        details: data["details"] as? [String: Any],
        timestamp: Date()
    )
    
    // Update UI with error
    DispatchQueue.main.async {
        self.showError(errorEvent)
    }
}
```

### 1.3 Sending Actions

The Mac client must be able to send the following actions via the `oh_action` Socket.IO event:

#### Send Message Action

```swift
// Example of sending a message action
func sendMessage(content: String, imageURLs: [URL]? = nil) {
    var args: [String: Any] = [
        "content": content
    ]
    
    if let imageURLs = imageURLs, !imageURLs.isEmpty {
        args["image_urls"] = imageURLs.map { $0.absoluteString }
    }
    
    socketManager.sendAction(
        action: "message",
        args: args
    )
}
```

#### Run Command Action

```swift
// Example of sending a run command action
func runCommand(command: String, hidden: Bool = false) {
    let args: [String: Any] = [
        "command": command,
        "hidden": hidden
    ]
    
    socketManager.sendAction(
        action: "run",
        args: args
    )
}
```

#### Change Agent State Action

```swift
// Example of sending a change agent state action
func changeAgentState(state: AgentState) {
    let stateString: String
    switch state {
        case .running: stateString = "RUNNING"
        case .paused: stateString = "PAUSED"
        case .stopped: stateString = "STOPPED"
        default: return // Invalid state transition
    }
    
    let args: [String: Any] = [
        "agent_state": stateString
    ]
    
    socketManager.sendAction(
        action: "change_agent_state",
        args: args
    )
}
```

#### Read File Action

```swift
// Example of sending a read file action
func readFile(path: String, startLine: Int = 0, endLine: Int = -1) {
    let args: [String: Any] = [
        "path": path,
        "start": startLine,
        "end": endLine
    ]
    
    socketManager.sendAction(
        action: "read",
        args: args
    )
}
```

#### Write File Action (Optional for MVP)

```swift
// Example of sending a write file action
func writeFile(path: String, content: String) {
    let args: [String: Any] = [
        "path": path,
        "content": content
    ]
    
    socketManager.sendAction(
        action: "write",
        args: args
    )
}
```

## 2. REST API Integration

### 2.1 API Client Setup

```swift
// Example API client setup
class APIClient {
    private let baseURL: URL
    private let session: URLSession
    private var authToken: String?
    
    init(baseURL: URL, authToken: String? = nil) {
        self.baseURL = baseURL
        self.authToken = authToken
        
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 30.0
        self.session = URLSession(configuration: config)
    }
    
    func setAuthToken(_ token: String?) {
        self.authToken = token
    }
    
    func get<T: Decodable>(endpoint: String, queryItems: [URLQueryItem]? = nil) async throws -> T {
        let request = try createRequest(
            method: "GET",
            endpoint: endpoint,
            queryItems: queryItems
        )
        
        return try await performRequest(request)
    }
    
    func post<T: Decodable, U: Encodable>(endpoint: String, body: U) async throws -> T {
        let request = try createRequest(
            method: "POST",
            endpoint: endpoint,
            body: body
        )
        
        return try await performRequest(request)
    }
    
    // Additional methods for PUT, PATCH, DELETE...
    
    private func createRequest(
        method: String,
        endpoint: String,
        queryItems: [URLQueryItem]? = nil,
        body: Encodable? = nil
    ) throws -> URLRequest {
        var urlComponents = URLComponents(url: baseURL.appendingPathComponent(endpoint), resolvingAgainstBaseURL: true)
        urlComponents?.queryItems = queryItems
        
        guard let url = urlComponents?.url else {
            throw APIError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = method
        
        if let authToken = authToken {
            request.setValue("Bearer \(authToken)", forHTTPHeaderField: "Authorization")
        }
        
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        if let body = body {
            let encoder = JSONEncoder()
            request.httpBody = try encoder.encode(body)
        }
        
        return request
    }
    
    private func performRequest<T: Decodable>(_ request: URLRequest) async throws -> T {
        let (data, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIError.invalidResponse
        }
        
        guard 200...299 ~= httpResponse.statusCode else {
            throw APIError.httpError(statusCode: httpResponse.statusCode, data: data)
        }
        
        let decoder = JSONDecoder()
        return try decoder.decode(T.self, from: data)
    }
}

enum APIError: Error {
    case invalidURL
    case invalidResponse
    case httpError(statusCode: Int, data: Data)
    case decodingError(Error)
}
```

### 2.2 Conversation Management

```swift
// Example conversation management API calls
class ConversationService {
    private let apiClient: APIClient
    
    init(apiClient: APIClient) {
        self.apiClient = apiClient
    }
    
    func createConversation(
        selectedRepository: String? = nil,
        initialUserMessage: String,
        imageURLs: [URL]? = nil
    ) async throws -> String {
        struct CreateConversationRequest: Codable {
            let selected_repository: String?
            let initial_user_msg: String
            let image_urls: [String]?
        }
        
        struct CreateConversationResponse: Codable {
            let conversation_id: String
        }
        
        let request = CreateConversationRequest(
            selected_repository: selectedRepository,
            initial_user_msg: initialUserMessage,
            image_urls: imageURLs?.map { $0.absoluteString }
        )
        
        let response: CreateConversationResponse = try await apiClient.post(
            endpoint: "api/conversations",
            body: request
        )
        
        return response.conversation_id
    }
    
    func listConversations(page: Int = 0, limit: Int = 20) async throws -> [ConversationInfo] {
        struct ConversationResultSet: Codable {
            let conversations: [ConversationInfo]
            let total: Int
            let page: Int
        }
        
        let queryItems = [
            URLQueryItem(name: "page_id", value: String(page)),
            URLQueryItem(name: "limit", value: String(limit))
        ]
        
        let resultSet: ConversationResultSet = try await apiClient.get(
            endpoint: "api/conversations",
            queryItems: queryItems
        )
        
        return resultSet.conversations
    }
    
    func getConversation(id: String) async throws -> ConversationInfo? {
        try await apiClient.get(endpoint: "api/conversations/\(id)")
    }
    
    func updateConversationTitle(id: String, title: String) async throws -> Bool {
        struct UpdateTitleRequest: Codable {
            let title: String
        }
        
        let request = UpdateTitleRequest(title: title)
        
        return try await apiClient.post(
            endpoint: "api/conversations/\(id)",
            body: request
        )
    }
    
    func deleteConversation(id: String) async throws -> Bool {
        try await apiClient.delete(endpoint: "api/conversations/\(id)")
    }
}
```

### 2.3 File Operations

```swift
// Example file operations API calls
class FileService {
    private let apiClient: APIClient
    
    init(apiClient: APIClient) {
        self.apiClient = apiClient
    }
    
    func listFiles(conversationId: String, path: String? = nil) async throws -> [FileNode] {
        var queryItems: [URLQueryItem] = []
        if let path = path {
            queryItems.append(URLQueryItem(name: "path", value: path))
        }
        
        return try await apiClient.get(
            endpoint: "api/conversations/\(conversationId)/list-files",
            queryItems: queryItems
        )
    }
    
    func getFileContent(conversationId: String, path: String) async throws -> String {
        struct FileContentResponse: Codable {
            let code: String
        }
        
        let queryItems = [URLQueryItem(name: "file", value: path)]
        
        let response: FileContentResponse = try await apiClient.get(
            endpoint: "api/conversations/\(conversationId)/select-file",
            queryItems: queryItems
        )
        
        return response.code
    }
    
    func saveFile(conversationId: String, path: String, content: String) async throws -> Bool {
        struct SaveFileRequest: Codable {
            let filePath: String
            let content: String
        }
        
        struct SaveFileResponse: Codable {
            let message: String
        }
        
        let request = SaveFileRequest(
            filePath: path,
            content: content
        )
        
        let _: SaveFileResponse = try await apiClient.post(
            endpoint: "api/conversations/\(conversationId)/save-file",
            body: request
        )
        
        return true
    }
    
    func downloadWorkspace(conversationId: String) async throws -> URL {
        // Implementation for downloading workspace as zip
        // This would use URLSession.downloadTask instead of the APIClient
        // and return a local file URL
        fatalError("Not implemented")
    }
}
```

### 2.4 Settings Management

```swift
// Example settings management API calls
class SettingsService {
    private let apiClient: APIClient
    
    init(apiClient: APIClient) {
        self.apiClient = apiClient
    }
    
    func getSettings() async throws -> Settings? {
        try await apiClient.get(endpoint: "api/settings")
    }
    
    func saveSettings(settings: Settings) async throws -> Bool {
        struct SaveSettingsResponse: Codable {
            let message: String
        }
        
        let _: SaveSettingsResponse = try await apiClient.post(
            endpoint: "api/settings",
            body: settings
        )
        
        return true
    }
    
    func getAvailableModels() async throws -> [String] {
        try await apiClient.get(endpoint: "api/options/models")
    }
    
    func getAvailableAgents() async throws -> [String] {
        try await apiClient.get(endpoint: "api/options/agents")
    }
    
    func getServerConfig() async throws -> ServerConfig {
        try await apiClient.get(endpoint: "api/options/config")
    }
}
```

## 3. Data Models

### 3.1 Conversation Models

```swift
struct ConversationInfo: Codable, Identifiable {
    let id: String
    let title: String
    let created: Date
    let updated: Date
    let repository: String?
    let isArchived: Bool
    
    enum CodingKeys: String, CodingKey {
        case id = "conversation_id"
        case title
        case created = "created_at"
        case updated = "updated_at"
        case repository = "repository"
        case isArchived = "is_archived"
    }
}

struct Message: Codable, Identifiable {
    var id: UUID = UUID()
    let content: String
    let source: String
    let timestamp: Date
    let imageURLs: [URL]?
    
    enum CodingKeys: String, CodingKey {
        case content
        case source
        case timestamp
        case imageURLs = "image_urls"
    }
}
```

### 3.2 File Models

```swift
struct FileNode: Codable, Identifiable {
    var id: String { path }
    let name: String
    let path: String
    let isDirectory: Bool
    let size: Int?
    let lastModified: Date?
    var children: [FileNode]?
    
    enum CodingKeys: String, CodingKey {
        case name
        case path
        case isDirectory = "is_directory"
        case size
        case lastModified = "last_modified"
        case children
    }
}

struct FileContent: Codable {
    let path: String
    let content: String
    let timestamp: Date
}
```

### 3.3 Settings Models

```swift
struct Settings: Codable {
    var backendURL: URL
    var apiKeys: [String: String]
    var uiPreferences: UIPreferences
    
    struct UIPreferences: Codable {
        var theme: String
        var fontSize: Int
        var showLineNumbers: Bool
    }
}

struct ServerConfig: Codable {
    let version: String
    let features: [String]
    let maxFileSize: Int
    
    enum CodingKeys: String, CodingKey {
        case version
        case features
        case maxFileSize = "max_file_size"
    }
}
```

### 3.4 Event and Action Models

```swift
enum AgentState {
    case unknown
    case loading
    case running
    case paused
    case stopped
    case awaitingUserInput
    case finished
    case error
}

struct CommandOutput {
    let command: String
    let output: String
    let exitCode: Int
    let timestamp: Date
}

struct ErrorEvent {
    let message: String
    let code: Int?
    let details: [String: Any]?
    let timestamp: Date
}
```

## 4. Integration Testing

### 4.1 Socket.IO Connection Testing

```swift
func testSocketIOConnection() async throws {
    // Create a test connection
    let socketManager = SocketIOManager(
        serverURL: URL(string: "http://localhost:8000")!,
        conversationId: "test-conversation"
    )
    
    // Set up expectations
    let connectExpectation = XCTestExpectation(description: "Socket connected")
    let eventExpectation = XCTestExpectation(description: "Received event")
    
    // Override handlers for testing
    socketManager.onConnect = {
        connectExpectation.fulfill()
    }
    
    socketManager.onEvent = { data in
        eventExpectation.fulfill()
    }
    
    // Connect and wait for connection
    socketManager.connect()
    
    // Wait for expectations with timeout
    await fulfillment(of: [connectExpectation], timeout: 5.0)
    
    // Send a test action
    socketManager.sendAction(
        action: "message",
        args: ["content": "Test message"]
    )
    
    // Wait for response event
    await fulfillment(of: [eventExpectation], timeout: 5.0)
    
    // Disconnect
    socketManager.disconnect()
}
```

### 4.2 REST API Testing

```swift
func testConversationCreation() async throws {
    // Create API client
    let apiClient = APIClient(baseURL: URL(string: "http://localhost:8000")!)
    let conversationService = ConversationService(apiClient: apiClient)
    
    // Create a test conversation
    let conversationId = try await conversationService.createConversation(
        initialUserMessage: "Test conversation"
    )
    
    // Verify conversation exists
    let conversation = try await conversationService.getConversation(id: conversationId)
    XCTAssertNotNil(conversation)
    XCTAssertEqual(conversation?.id, conversationId)
    
    // Clean up
    let deleted = try await conversationService.deleteConversation(id: conversationId)
    XCTAssertTrue(deleted)
}
```

## 5. Error Handling

### 5.1 Socket.IO Error Handling

```swift
// Example Socket.IO error handling
func handleSocketError(error: Error) {
    switch error {
    case let socketError as SocketIOError:
        switch socketError {
        case .connectionError:
            // Handle connection error
            showConnectionErrorAlert()
        case .disconnected:
            // Handle disconnection
            attemptReconnection()
        default:
            // Handle other socket errors
            logError(error)
        }
    default:
        // Handle unknown errors
        logError(error)
    }
}
```

### 5.2 API Error Handling

```swift
// Example API error handling
func handleAPIError(_ error: Error) {
    switch error {
    case let apiError as APIError:
        switch apiError {
        case .httpError(let statusCode, let data):
            // Handle HTTP errors
            switch statusCode {
            case 401:
                // Unauthorized - refresh token or prompt for login
                handleUnauthorized()
            case 404:
                // Not found
                showNotFoundError()
            case 429:
                // Rate limited
                showRateLimitError()
            case 500...599:
                // Server error
                showServerError()
            default:
                // Other HTTP errors
                showGenericError("HTTP Error \(statusCode)")
            }
        case .invalidURL:
            showGenericError("Invalid URL")
        case .invalidResponse:
            showGenericError("Invalid Response")
        case .decodingError(let decodingError):
            logError(decodingError)
            showGenericError("Data Parsing Error")
        }
    default:
        // Handle unknown errors
        logError(error)
        showGenericError("Unknown Error")
    }
}
```

## 6. Security Considerations

### 6.1 Token Storage

```swift
// Example secure token storage using Keychain
class TokenManager {
    private let keychainService = "com.openhands.macclient"
    private let tokenKey = "auth_token"
    
    func saveToken(_ token: String) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: tokenKey,
            kSecValueData as String: token.data(using: .utf8)!
        ]
        
        // Delete any existing item
        SecItemDelete(query as CFDictionary)
        
        // Add the new item
        let status = SecItemAdd(query as CFDictionary, nil)
        guard status == errSecSuccess else {
            throw KeychainError.saveFailure(status: status)
        }
    }
    
    func getToken() throws -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: tokenKey,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var item: CFTypeRef?
        let status = SecItemCopyMatching(query as CFDictionary, &item)
        
        guard status != errSecItemNotFound else {
            return nil
        }
        
        guard status == errSecSuccess else {
            throw KeychainError.readFailure(status: status)
        }
        
        guard let data = item as? Data,
              let token = String(data: data, encoding: .utf8) else {
            return nil
        }
        
        return token
    }
    
    func deleteToken() throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: tokenKey
        ]
        
        let status = SecItemDelete(query as CFDictionary)
        guard status == errSecSuccess || status == errSecItemNotFound else {
            throw KeychainError.deleteFailure(status: status)
        }
    }
}

enum KeychainError: Error {
    case saveFailure(status: OSStatus)
    case readFailure(status: OSStatus)
    case deleteFailure(status: OSStatus)
}
```

### 6.2 Secure Communication

```swift
// Example secure URL session configuration
func configureSecureURLSession() -> URLSession {
    let configuration = URLSessionConfiguration.default
    
    // Set TLS minimum version
    configuration.tlsMinimumSupportedProtocolVersion = .TLSv12
    
    // Add security headers
    configuration.httpAdditionalHeaders = [
        "X-Content-Type-Options": "nosniff"
    ]
    
    // Configure cache policy
    configuration.requestCachePolicy = .reloadIgnoringLocalCacheData
    
    return URLSession(configuration: configuration)
}
```

## 7. Performance Optimization

### 7.1 Efficient Socket.IO Usage

```swift
// Example efficient Socket.IO event handling
func optimizeSocketIOUsage() {
    // 1. Use binary transport for efficiency
    let config: SocketIOClientConfiguration = [
        .compress,
        .forceWebsockets(true),
        .extraHeaders(["Accept": "application/msgpack"]),
        .connectParams(["transport": "websocket"])
    ]
    
    // 2. Implement selective event handling
    socket.on("oh_event") { [weak self] data, ack in
        guard let self = self,
              let eventData = data[0] as? [String: Any],
              let source = eventData["source"] as? String else {
            return
        }
        
        // Only process events we're interested in
        switch source {
        case "AGENT":
            self.handleAgentEvent(eventData)
        case "SYSTEM":
            self.handleSystemEvent(eventData)
        default:
            break
        }
    }
    
    // 3. Implement event batching for sending multiple actions
    func sendBatchedActions(_ actions: [[String: Any]]) {
        socket.emit("oh_action_batch", actions)
    }
}
```

### 7.2 Efficient API Usage

```swift
// Example efficient API usage
func optimizeAPIUsage() {
    // 1. Implement request throttling
    let requestThrottler = RequestThrottler(maxRequestsPerSecond: 10)
    
    // 2. Implement response caching
    let cache = NSCache<NSString, CachedResponse>()
    
    // 3. Implement conditional requests
    func conditionalFetch<T: Decodable>(endpoint: String, etag: String?) async throws -> T {
        var request = URLRequest(url: baseURL.appendingPathComponent(endpoint))
        
        if let etag = etag {
            request.addValue(etag, forHTTPHeaderField: "If-None-Match")
        }
        
        let (data, response) = try await session.data(for: request)
        
        if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 304 {
            // Use cached data
            guard let cachedResponse = cache.object(forKey: endpoint as NSString) else {
                throw APIError.cacheError
            }
            
            return try JSONDecoder().decode(T.self, from: cachedResponse.data)
        } else {
            // Use new data
            let newEtag = (response as? HTTPURLResponse)?.value(forHTTPHeaderField: "ETag")
            
            if let newEtag = newEtag {
                cache.setObject(CachedResponse(data: data, etag: newEtag), forKey: endpoint as NSString)
            }
            
            return try JSONDecoder().decode(T.self, from: data)
        }
    }
}

class CachedResponse {
    let data: Data
    let etag: String
    let timestamp: Date
    
    init(data: Data, etag: String, timestamp: Date = Date()) {
        self.data = data
        self.etag = etag
        self.timestamp = timestamp
    }
}

class RequestThrottler {
    private let maxRequestsPerSecond: Int
    private var requestTimestamps: [Date] = []
    private let queue = DispatchQueue(label: "com.openhands.requestThrottler")
    
    init(maxRequestsPerSecond: Int) {
        self.maxRequestsPerSecond = maxRequestsPerSecond
    }
    
    func waitForSlot() async {
        await withCheckedContinuation { continuation in
            queue.async { [weak self] in
                guard let self = self else {
                    continuation.resume()
                    return
                }
                
                let now = Date()
                
                // Remove timestamps older than 1 second
                self.requestTimestamps = self.requestTimestamps.filter {
                    now.timeIntervalSince($0) < 1.0
                }
                
                // If we have capacity, add timestamp and continue
                if self.requestTimestamps.count < self.maxRequestsPerSecond {
                    self.requestTimestamps.append(now)
                    continuation.resume()
                    return
                }
                
                // Otherwise, wait until we have capacity
                let oldestTimestamp = self.requestTimestamps[0]
                let timeToWait = 1.0 - now.timeIntervalSince(oldestTimestamp)
                
                if timeToWait > 0 {
                    DispatchQueue.global().asyncAfter(deadline: .now() + timeToWait) {
                        self.queue.async {
                            self.requestTimestamps.removeFirst()
                            self.requestTimestamps.append(Date())
                            continuation.resume()
                        }
                    }
                } else {
                    self.requestTimestamps.removeFirst()
                    self.requestTimestamps.append(now)
                    continuation.resume()
                }
            }
        }
    }
}
```

## 8. Compatibility Considerations

### 8.1 API Version Handling

```swift
// Example API version handling
class VersionedAPIClient {
    private let baseURL: URL
    private let apiVersion: String
    
    init(baseURL: URL, apiVersion: String = "v1") {
        self.baseURL = baseURL
        self.apiVersion = apiVersion
    }
    
    func createRequest(endpoint: String) -> URLRequest {
        var request = URLRequest(url: baseURL.appendingPathComponent("\(apiVersion)/\(endpoint)"))
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        return request
    }
    
    // Check API compatibility
    func checkAPICompatibility() async throws -> Bool {
        struct VersionInfo: Codable {
            let version: String
            let minClientVersion: String?
            
            enum CodingKeys: String, CodingKey {
                case version
                case minClientVersion = "min_client_version"
            }
        }
        
        let versionInfo: VersionInfo = try await get(endpoint: "version")
        
        // Compare versions to ensure compatibility
        let clientVersion = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "0.0.0"
        
        if let minClientVersion = versionInfo.minClientVersion {
            return compareVersions(clientVersion, minClientVersion) >= 0
        }
        
        return true
    }
    
    private func compareVersions(_ version1: String, _ version2: String) -> Int {
        let components1 = version1.split(separator: ".").compactMap { Int($0) }
        let components2 = version2.split(separator: ".").compactMap { Int($0) }
        
        let maxLength = max(components1.count, components2.count)
        
        for i in 0..<maxLength {
            let v1 = i < components1.count ? components1[i] : 0
            let v2 = i < components2.count ? components2[i] : 0
            
            if v1 > v2 {
                return 1
            } else if v1 < v2 {
                return -1
            }
        }
        
        return 0
    }
}
```

### 8.2 Feature Detection

```swift
// Example feature detection
class FeatureDetector {
    private let apiClient: APIClient
    private var supportedFeatures: [String] = []
    
    init(apiClient: APIClient) {
        self.apiClient = apiClient
    }
    
    func detectFeatures() async throws {
        struct ServerConfig: Codable {
            let features: [String]
        }
        
        let config: ServerConfig = try await apiClient.get(endpoint: "api/options/config")
        self.supportedFeatures = config.features
    }
    
    func isFeatureSupported(_ feature: String) -> Bool {
        return supportedFeatures.contains(feature)
    }
    
    // Example usage
    func configureUI() {
        if isFeatureSupported("file_editing") {
            enableFileEditingUI()
        } else {
            disableFileEditingUI()
        }
        
        if isFeatureSupported("image_upload") {
            enableImageUploadUI()
        } else {
            disableImageUploadUI()
        }
    }
}
```

This comprehensive API integration specification provides the detailed technical guidance needed to implement the OpenHands Mac client, ensuring compatibility with the existing backend and covering all the necessary communication patterns for a functional MVP.

---

# tasks/spec_client.md

---
name  :  mac_client_task
type  :  task
agent  :  CodeActAgent
---

# OpenHands Mac Client Comprehensive Specification

## 1. Core App Features

The Mac client will include the following core features:

1.  **Task Input Area:**
    *   Description: A text area where users can input instructions and tasks for OpenHands.
    *   Functionality: Accepts natural language task instructions.
    *   Implementation Requirements:
        *   Support for text formatting (optional)
        *   Image attachment capability (optional for MVP)
        *   Command history (optional for MVP)

2.  **Agent Output Display:**
    *   Description: A window or panel to display the step-by-step actions, logs, and outputs generated by the OpenHands agent.
    *   Functionality: Real-time display of agent's progress, including code changes and command executions.
    *   Implementation Requirements:
        *   Support for multiple output types (text, markdown, code, terminal, images)
        *   Syntax highlighting for code blocks
        *   Auto-scrolling with manual override
        *   Chunked processing for large outputs

3.  **File Explorer:**
    *   Description: A file tree view to browse and manage files within the workspace.
    *   Functionality: File system navigation, file opening, basic file management.
    *   Implementation Requirements:
        *   Read-only view for MVP (create, delete, rename optional)
        *   Lazy loading of directory contents
        *   File content caching for performance
        *   Support for viewing different file types

4.  **Control Buttons:**
    *   Description: Buttons to control the agent's execution state.
    *   Functionality: Start, stop, and pause agent execution.
    *   Implementation Requirements:
        *   Visual indication of current agent state
        *   Confirmation for potentially destructive actions
        *   Keyboard shortcuts (optional for MVP)

5.  **Conversation Management:**
    *   Description: Interface to create, switch between, and manage multiple conversations.
    *   Functionality:
        *   Create new conversations with different agent types
        *   Switch between existing conversations via tabs or sidebar
        *   Rename conversations for better organization
        *   Delete conversations with confirmation dialog
        *   View and search conversation history
        *   Export conversation logs for sharing or archiving
        *   Group conversations by project or topic
        *   Filter conversations by status, date, or agent type
        *   Pin important conversations for quick access
    *   Implementation Requirements:
        *   Intuitive UI for conversation switching (tabs or sidebar)
        *   Visual indicators for conversation status (active, paused, completed)
        *   Confirmation dialogs for destructive actions
        *   Search functionality within conversation history
        *   Keyboard shortcuts for quick conversation switching
        *   Persistent storage of conversation list and metadata
        *   Ability to restore previous conversation state
        *   Conversation tagging and categorization
        *   Bulk operations for managing multiple conversations
        *   Conversation statistics and usage metrics

6.  **Settings Panel:**
    *   Description: A comprehensive tabbed panel to configure all settings for the Mac client and the OpenHands backend, matching all options in backend config.template.toml.
    *   Functionality:
        *   General Settings:
            *   UI theme (light/dark/system)
            *   Font size and family
            *   Display preferences
            *   Keyboard shortcuts
            *   Notification preferences
            *   Startup behavior
        *   Backend Connection:
            *   Local or remote backend URL
            *   Authentication settings
            *   Connection timeout and retry settings
            *   Proxy configuration
            *   WebSocket parameters
            *   Health check settings
        *   Model Settings:
            *   LLM provider selection
            *   Model selection (GPT-4, Claude, etc.)
            *   Context length configuration
            *   Temperature and other sampling parameters
            *   System prompt customization
            *   Model fallback options
            *   Caching parameters
        *   API Keys:
            *   Secure storage for provider API keys
            *   Key validation and status indicators
            *   Usage tracking and quotas
            *   Rotation policies
            *   Environment variable integration
        *   Execution Settings:
            *   Timeout configurations
            *   Rate limiting settings
            *   Parallel execution options
            *   Error handling preferences
            *   Tool execution parameters
            *   Memory management
        *   File System:
            *   Default workspace location
            *   File browser preferences
            *   File type associations
            *   Ignored files and patterns
            *   File watching settings
            *   Version control integration
        *   Advanced:
            *   Logging level and location
            *   Debug options
            *   Performance tuning
            *   Experimental features
            *   Developer tools
            *   Diagnostic information
    *   Implementation Requirements:
        *   Tabbed interface with logical grouping of settings
        *   Search functionality to quickly find specific settings
        *   Import/export functionality for settings backup
        *   Real-time validation of setting values
        *   Clear documentation for each setting with tooltips
        *   Persistent storage of settings
        *   Secure storage of sensitive information
        *   Default value indicators
        *   Reset to defaults option
        *   Settings change history
        *   Profile-based settings management

## 2. Backend Integration

### 2.1 Socket.IO Communication

*   **Connection Management:**
    *   Establish and maintain WebSocket connection to backend
    *   Handle reconnection with exponential backoff
    *   Support authentication via tokens
    *   Monitor connection health

*   **Event Handling:**
    *   Process `oh_event` messages from backend
    *   Send `oh_action` messages to backend
    *   Handle different event types (system, agent, file, etc.)
    *   Implement event queueing for offline scenarios (optional for MVP)

*   **Specific Events to Support:**
    *   Agent state changes (running, paused, stopped)
    *   Command execution and results
    *   File operations and updates
    *   Error notifications
    *   Authentication events

### 2.2 REST API Integration

*   **Conversation Management:**
    *   Create new conversations
    *   List existing conversations
    *   Update conversation details
    *   Delete conversations

*   **File Operations:**
    *   List files in workspace
    *   Get file content
    *   Save file content (optional for MVP)
    *   Upload files (optional for MVP)

*   **Settings Management:**
    *   Load application settings
    *   Store application settings

*   **Configuration:**
    *   Get available models
    *   Get available agents
    *   Get server configuration

## 3. User Interface Flow

### 3.1 Main Application Flow

1.  **Startup:**
    *   Load saved settings
    *   Connect to backend
    *   Show conversation list or create new conversation

2.  **Conversation Creation:**
    *   Select agent type
    *   Provide initial task description
    *   Initialize conversation with backend

3.  **Conversation Interaction:**
    *   Display agent outputs in real-time
    *   Allow user to input additional instructions
    *   Control agent execution (start, stop, pause)
    *   Browse workspace files

4.  **Settings Access:**
    *   Access settings from main interface
    *   Apply settings changes immediately where possible

### 3.2 UI Components and Layout

*   **Main Window:**
    *   Split view with resizable panels
    *   File explorer on left side
    *   Chat/output display in center
    *   Task input at bottom
    *   Control buttons in toolbar

*   **Settings Window:**
    *   Modal dialog or separate window
    *   Categorized settings
    *   Save/cancel buttons

*   **Error Notifications:**
    *   Non-intrusive notifications for minor errors
    *   Modal dialogs for critical errors
    *   Recovery options where applicable

## 4. Data Management

### 4.1 Local Storage

*   **Persistent Data:**
    *   Connection settings
    *   UI preferences
    *   Authentication tokens
    *   Recent conversations list

*   **Cache:**
    *   File content cache
    *   Conversation history cache
    *   Command history

### 4.2 State Synchronization

*   **Client-Server State:**
    *   Track conversation state version
    *   Handle conflicts in concurrent edits
    *   Recover from divergent states

*   **Offline Support (Future):**
    *   Queue actions when offline
    *   Sync when connection restored

## 5. Error Handling

### 5.1 Error Categories

*   **Connection Errors:**
    *   Failed initial connection
    *   Connection lost during session
    *   Authentication failures

*   **API Errors:**
    *   Invalid requests
    *   Server-side errors
    *   Rate limiting

*   **Runtime Errors:**
    *   Invalid state transitions
    *   Resource limitations
    *   Unexpected responses

### 5.2 Recovery Strategies

*   **Automatic Recovery:**
    *   Reconnection attempts
    *   Request retries with backoff
    *   State resynchronization

*   **User-Guided Recovery:**
    *   Clear error messages
    *   Actionable recovery options
    *   Graceful degradation

## 6. Performance Considerations

*   **Large Output Handling:**
    *   Chunked processing
    *   Virtualized list views
    *   Efficient rendering of complex outputs

*   **Memory Management:**
    *   Cache size limitations
    *   Resource cleanup
    *   Background processing for intensive operations

*   **Responsiveness:**
    *   Non-blocking UI during network operations
    *   Progress indicators for long-running tasks
    *   Cancelable operations where possible

## 7. Compatibility Requirements

*   **Backend Compatibility:**
    *   Support for current OpenHands backend API
    *   Graceful handling of unknown event types
    *   Feature detection for optional capabilities

*   **macOS Compatibility:**
    *   Target current stable macOS release
    *   SwiftUI compatibility considerations
    *   System integration (notifications, etc.)

## 8. MVP Scope and Priorities

### 8.1 Must-Have Features (MVP)

1.  Basic task input and submission
2.  Agent output display with formatting
3.  Read-only file explorer
4.  Start/stop agent controls
5.  Comprehensive settings panel with tabbed interface matching all backend config.template.toml options
6.  Basic error handling and recovery
7.  Multiple conversation management with search and filtering
8.  Backend connection configuration
9.  Conversation history and state persistence

### 8.2 Nice-to-Have Features (Post-MVP)

1.  Image attachment in task input
2.  File editing capabilities
3.  Advanced output formatting
4.  Advanced keyboard shortcuts
5.  Offline support
6.  Settings import/export
7.  Advanced customization options
8.  Conversation grouping and tagging
9.  Conversation export functionality
10. Settings profiles management

## 9. Implementation Approach

*   **Architecture:** MVVM with SwiftUI
*   **State Management:** Observable objects with property wrappers
*   **Concurrency:** Swift async/await for asynchronous operations
*   **Networking:** Combine framework for reactive programming
*   **Persistence:** UserDefaults for basic settings, Core Data for more complex data (if needed)
*   **UI Framework:** SwiftUI with minimal UIKit integration where necessary

5.  **Control Buttons:**
    *   Description: Buttons to control the execution of the agent.
    *   Functionality:
        *   Start: Initiate agent execution for the given task.
        *   Stop: Terminate agent execution.
        *   Pause/Resume: (Optional for initial version) Pause and resume agent execution.
        *   Step: (Optional for initial version) Step through agent actions one by one for debugging/inspection.

6.  **Prompt Configuration Area:**
    *   Description: A section to manage and configure prompts, including system prompts and MicroAgents.
    *   Functionality:
        *   **MicroAgent Source Tabs/Sections:**
            *   **Public MicroAgents:** (View-only) - Browse and view descriptions of public MicroAgents.
            *   **Repo-Specific MicroAgents:** (Editable) - Browse, view, and edit repo-specific MicroAgents.
        *   **MicroAgent List:** Display lists of MicroAgents within each source section.
        *   **MicroAgent Content Editor:**
            *   View and edit (for repo-specific) the content of selected MicroAgents (Markdown/YAML editor with syntax highlighting).
            *   View (for public MicroAgents) the content of selected MicroAgents (view-only editor).
        *   **(Optional) Version Control/Undo-Redo for Repo-Specific MicroAgents:** Basic undo/redo functionality in the editor.

7.  **Memory Area:**
    *   Description: A section to visualize and potentially manage the agent's memory (short-term and long-term).
    *   Functionality:
        *   **Memory Display:** Visualize agent's memory content (format to be determined - e.g., text, graph).
        *   **(Optional) Memory Management:** Features to clear or edit memory (for advanced users).

## 2. Interface Structure

The UI structure is conceptually divided into two main columns: a left column for the Chat Area and a right column for context and tools.

```
+-----------------------------------------------------+-----------------------------------------------------------------------+
|                      Left Column                      |                             Right Column                              |
| +-------------------------------------------------+ | +-------------------------------------------------------------------+ |
| |                  Chat Area                      | | |                      Top Right Section                            | |
| | +---------------------------------------------+ | | | | +---------------------------------------+-----------------------+ |
| | |          Agent Output Display             | | | | | |    Workspace (File Explorer)       | Variable Context Area   | |
| | | (Conversation History, Agent Actions, Logs) | | | | | |                                       | (Settings,         | |
| | +---------------------------------------------+ | | | | |                                       |  Prompts,    | |
| | |              User Input Area                | | | | |                                       |  Memory - switchable)  | |
| | |         (User Input Area)              | | | | +---------------------------------------+-----------------------+ |
| | +---------------------------------------------+ | | +-------------------------------------------------------------------+ |
| +-------------------------------------------------+ | | |             Bottom Right Section: Terminal/Command Output         | |
|                                                     | | | +-------------------------------------------------------------------+ |
|                                                     | | | |                                                                   | |
|                                                     | | | | (Smaller height than Top Right Section)                           | |
|                                                     | | +-------------------------------------------------------------------+ |
+-----------------------------------------------------+-----------------------------------------------------------------------+
```

*   **Left Column (Chat Area):** Focuses on user interaction and agent communication.
    *   **Agent Output Display:** Shows the conversation history, agent actions, and logs.
    *   **User Input Area:**  Provides a text area for user instructions.

*   **Right Column (Context and Tools):**  Provides supporting information and tools, split horizontally.
    *   **Top Right Section:** Split vertically into two areas.
        *   **Workspace (File Explorer):** Displays a file tree for workspace navigation.
        *   **Variable Context Area:** Switchable tabbed panel for different context views. The views available in this area are:
            *   **Settings Panel:**  For configuring application settings.
            *   **Prompt Configuration Area:** For managing system prompts and MicroAgents.
            *   **Memory Area:** To visualize and manage the agent's memory.
    *   **Bottom Right Section: Terminal/Command Output:** Displays the output of commands executed by the agent.  This section has a smaller height than the Top Right Section.



---

# tasks/spec_mvp.md

---
name  :  mac_client_mvp
type  :  task
agent  :  CodeActAgent
---

# OpenHands Mac Client MVP Definition

This document defines the MVP features for the OpenHands Mac Client, which serves as a native macOS alternative to the existing web UI. Both the Mac Client and web UI connect to the same OpenHands backend service, with this client providing a native desktop experience while maintaining full compatibility with the backend API.

## MVP Configuration Defaults

- **Backend Connection**: Local by default (localhost)
- **Target macOS Version**: Current stable release (no backward compatibility required for MVP)
- **Architecture Role**: The Mac Client functions purely as a frontend client connecting to the existing OpenHands backend, which handles all data persistence, file operations, and business logic.

## Core MVP Features

For the initial MVP release of the OpenHands Mac client application, we will focus on the following core features:

1. **Task Input Area:**
   - Description: A text area for users to input tasks.
   - Functionality: Accepts natural language task instructions.

2. **Agent Output Display:**
   - Description: Display area for agent's step-by-step actions and outputs.
   - Functionality: Real-time display of agent's progress, including command executions and code changes.

3. **Basic File Explorer:**
   - Description: A simplified file tree view.
   - Functionality: Enables file system navigation and file viewing (no creation, deletion, or renaming in MVP).

4. **Start/Stop Control Buttons:**
   - Description: Buttons to control agent execution.
   - Functionality: Start the agent and stop it when needed.

5. **Comprehensive Settings Panel:**
   - Description: Tabbed interface for configuring all client and backend settings.
   - Functionality: Complete settings management matching all backend config.template.toml options, organized in logical tabs.

6. **Backend Connection Settings:**
   - Description: Settings to connect to the OpenHands backend.
   - Functionality: Options to specify the backend host, port, authentication, and connection parameters.

7. **Multiple Conversation Management:**
   - Description: Interface to create, switch between, and manage multiple conversations.
   - Functionality: Create new conversations, switch between existing ones, view conversation history.

## MVP Technical Architecture

- **UI Framework**: SwiftUI
- **Architecture Pattern**: MVVM (Model-View-ViewModel)
- **State Management**: Observable state objects with SwiftUI's property wrappers
- **Communication**: Centralized SocketIO manager class for backend integration

## Excluded from MVP

The following features will be excluded from the MVP to expedite the initial release:

- Advanced File Management (create, delete, rename)
- Prompt Configuration Area (MicroAgent management)
- Memory Area visualization
- Pause/Resume and Step control buttons
- Dedicated Terminal/Command Output section (agent output display suffices)
- Advanced conversation grouping and tagging
- Settings import/export functionality
- Offline support

## MVP Focus

The primary focus of the MVP is to enable the following functionalities:

- Input tasks for the OpenHands agent.
- View the agent's execution and outputs in real-time.
- Navigate and view files within the workspace.
- Start and stop agent execution.
- Connect to a local or remote OpenHands backend.
- Configure all client and backend settings through a comprehensive tabbed interface.
- Create, switch between, and manage multiple conversations.
- View and search conversation history.

## Technical Architecture

### Data Models

The Mac client will implement Swift models that directly map to the JSON structures defined in the backend communication protocol. These include:

- Communication models (Events, UserActions)
- Agent state model
- File system representations
- Configuration models

All models will implement Swift's `Codable` protocol for JSON serialization/deserialization.



---

# tasks/spec_ui.md

---
name  :  mac_client_ui_design_details
type  :  task
agent  :  CodeActAgent
---

# OpenHands Mac Client UI Design Details

This document contains detailed design specifications for the OpenHands Mac client application UI.

## UI Views and Elements Outline

### Main UI Views/Panels Outline

- **Left Column (Main Interaction Area):**
  - **Agent Output Display:**
    - Details about Agent Output Display elements.
  - **User Input Area:**
    - Details about User Input Area elements.

- **Right Column (Context and Tools):**
  - **Top Right Section:**
  - **Workspace (File Explorer):**
    - Details about File Explorer elements.
  - **Variable Context Area:**
  - **Settings Panel:**
    - Details about Settings Panel elements.
  - **Prompt Configuration Area:**
    - Details about Prompt Configuration Area elements.
  - **Memory Area:**
    - Details about Memory Area elements.
  - **Bottom Right Section:**
    - Command Output (Terminal) elements.

- **Status Bar:**
  - Description: A status bar indicating system status and connection state.
  - Functionality: Displays backend connection status, error states, and system notifications.


---

# tasks/spec_ui_components.md

---
name  :  mac_client_ui_components
type  :  task
agent  :  CodeActAgent
---

# OpenHands Mac Client UI Components Specification

This document provides detailed specifications for the UI components of the OpenHands Mac client, including layout, behavior, and implementation details.

## 1. Main Window Layout

The main window of the OpenHands Mac client will use a split view layout with resizable panels:

```
+-----------------------------------------------+
| Toolbar (Control Buttons, Settings)           |
+-----------------------------------------------+
| +----------+                                  |
| |          |                                  |
| |  File    |                                  |
| |  Explorer|     Agent Output Display         |
| |          |                                  |
| |          |                                  |
| |          |                                  |
| +----------+                                  |
|                                               |
+-----------------------------------------------+
|                                               |
|           Task Input Area                     |
|                                               |
+-----------------------------------------------+
```

### 1.1 SwiftUI Implementation

```swift
struct MainView: View {
    @StateObject private var viewModel = MainViewModel()
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Main content area with split view
                HSplitView {
                    // File Explorer
                    FileExplorerView(viewModel: viewModel.fileExplorerViewModel)
                        .frame(minWidth: 200, idealWidth: 250, maxWidth: 400)
                    
                    // Agent Output Display
                    AgentOutputView(viewModel: viewModel.outputViewModel)
                        .frame(minWidth: 400)
                }
                
                Divider()
                
                // Task Input Area
                TaskInputView(viewModel: viewModel.inputViewModel)
                    .frame(height: 100)
            }
            .toolbar {
                ToolbarItemGroup(placement: .primaryAction) {
                    // Control Buttons
                    AgentControlButtons(viewModel: viewModel.controlViewModel)
                    
                    Spacer()
                    
                    // Settings Button
                    Button(action: { viewModel.showSettings() }) {
                        Image(systemName: "gear")
                    }
                }
            }
            .sheet(isPresented: $viewModel.isSettingsPresented) {
                SettingsView(viewModel: viewModel.settingsViewModel)
            }
        }
    }
}
```

## 2. File Explorer Component

The File Explorer provides a hierarchical view of files and directories in the workspace.

### 2.1 Design and Behavior

- Tree view with expandable/collapsible folders
- Icons to indicate file types
- Selection highlighting for the current file
- Context menu for file operations (optional for MVP)
- Double-click to open files

### 2.2 SwiftUI Implementation

```swift
struct FileExplorerView: View {
    @ObservedObject var viewModel: FileExplorerViewModel
    
    var body: some View {
        VStack {
            // Header
            HStack {
                Text("Files")
                    .font(.headline)
                
                Spacer()
                
                Button(action: { viewModel.refreshFiles() }) {
                    Image(systemName: "arrow.clockwise")
                        .imageScale(.small)
                }
                .buttonStyle(.borderless)
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            
            Divider()
            
            // File tree
            if viewModel.isLoading && viewModel.rootNodes.isEmpty {
                ProgressView("Loading files...")
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if let error = viewModel.error, viewModel.rootNodes.isEmpty {
                VStack {
                    Text("Error loading files")
                        .foregroundColor(.red)
                    Text(error)
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Button("Retry") {
                        viewModel.refreshFiles()
                    }
                    .padding(.top)
                }
                .padding()
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                List(viewModel.rootNodes, children: \.children) { node in
                    FileNodeView(node: node, selectedPath: viewModel.selectedPath) { path in
                        viewModel.selectFile(path: path)
                    }
                }
                .listStyle(SidebarListStyle())
            }
        }
    }
}

struct FileNodeView: View {
    let node: FileNode
    let selectedPath: String?
    let onSelect: (String) -> Void
    
    var body: some View {
        HStack {
            // Icon based on file type
            if node.isDirectory {
                Image(systemName: "folder")
                    .foregroundColor(.blue)
            } else {
                Image(systemName: fileTypeIcon(for: node.name))
                    .foregroundColor(.gray)
            }
            
            // File name
            Text(node.name)
                .lineLimit(1)
        }
        .contentShape(Rectangle())
        .onTapGesture {
            onSelect(node.path)
        }
        .background(
            selectedPath == node.path ? Color.accentColor.opacity(0.2) : Color.clear
        )
    }
    
    private func fileTypeIcon(for fileName: String) -> String {
        let fileExtension = fileName.components(separatedBy: ".").last?.lowercased() ?? ""
        
        switch fileExtension {
        case "swift", "java", "kt", "cpp", "c", "h", "cs", "js", "ts", "py", "rb":
            return "doc.plaintext"
        case "json", "xml", "yaml", "yml":
            return "curlybraces"
        case "md", "txt", "rtf":
            return "doc.text"
        case "pdf":
            return "doc.fill"
        case "jpg", "jpeg", "png", "gif", "bmp", "tiff":
            return "photo"
        case "mp4", "mov", "avi", "wmv":
            return "film"
        case "mp3", "wav", "aac", "flac":
            return "music.note"
        case "zip", "tar", "gz", "7z", "rar":
            return "archivebox"
        default:
            return "doc"
        }
    }
}
```

### 2.3 View Model

```swift
class FileExplorerViewModel: ObservableObject {
    @Published var rootNodes: [FileNode] = []
    @Published var selectedPath: String?
    @Published var isLoading: Bool = false
    @Published var error: String?
    
    private let fileService: FileService
    private let conversationId: String
    
    init(fileService: FileService, conversationId: String) {
        self.fileService = fileService
        self.conversationId = conversationId
    }
    
    func refreshFiles() {
        isLoading = true
        error = nil
        
        Task {
            do {
                let files = try await fileService.listFiles(
                    conversationId: conversationId
                )
                
                await MainActor.run {
                    self.rootNodes = files
                    self.isLoading = false
                }
            } catch {
                await MainActor.run {
                    self.error = error.localizedDescription
                    self.isLoading = false
                }
            }
        }
    }
    
    func selectFile(path: String) {
        selectedPath = path
        
        // Notify parent view model or handle file selection
        // This could trigger a file content fetch if needed
    }
}
```

## 3. Agent Output Display Component

The Agent Output Display shows the step-by-step actions and outputs from the agent in real-time.

### 3.1 Design and Behavior

- Scrollable list of messages and outputs
- Support for different content types:
  - Text messages
  - Markdown content
  - Code blocks with syntax highlighting
  - Terminal command outputs
  - File changes
  - Error messages
- Auto-scrolling to latest content with manual override
- Chunked processing for large outputs

### 3.2 SwiftUI Implementation

```swift
struct AgentOutputView: View {
    @ObservedObject var viewModel: AgentOutputViewModel
    @State private var scrollViewProxy: ScrollViewProxy?
    @State private var autoScroll: Bool = true
    
    var body: some View {
        VStack {
            // Header
            HStack {
                Text("Agent Output")
                    .font(.headline)
                
                Spacer()
                
                Toggle("Auto-scroll", isOn: $autoScroll)
                    .toggleStyle(.switch)
                    .controlSize(.small)
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            
            Divider()
            
            // Output content
            ScrollViewReader { proxy in
                ScrollView {
                    LazyVStack(alignment: .leading, spacing: 12) {
                        ForEach(viewModel.outputs) { output in
                            OutputItemView(output: output)
                                .id(output.id)
                        }
                        
                        // Bottom anchor for auto-scrolling
                        Color.clear
                            .frame(height: 1)
                            .id("bottom")
                    }
                    .padding()
                }
                .onChange(of: viewModel.outputs) { _ in
                    if autoScroll {
                        withAnimation {
                            proxy.scrollTo("bottom", anchor: .bottom)
                        }
                    }
                }
                .onAppear {
                    scrollViewProxy = proxy
                    if autoScroll {
                        proxy.scrollTo("bottom", anchor: .bottom)
                    }
                }
            }
        }
    }
}

struct OutputItemView: View {
    let output: AgentOutput
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            // Output header
            HStack {
                Text(output.timestamp, style: .time)
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                if let source = output.source {
                    Text(source)
                        .font(.caption)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(sourceColor(source).opacity(0.2))
                        .cornerRadius(4)
                }
                
                Spacer()
            }
            
            // Output content based on type
            switch output.type {
            case .text:
                Text(output.content)
                    .textSelection(.enabled)
            
            case .markdown:
                MarkdownView(markdown: output.content)
                    .textSelection(.enabled)
            
            case .code:
                CodeBlockView(
                    code: output.content,
                    language: output.metadata?["language"] as? String ?? ""
                )
            
            case .terminal:
                TerminalOutputView(
                    command: output.metadata?["command"] as? String,
                    output: output.content,
                    exitCode: output.metadata?["exitCode"] as? Int ?? 0
                )
            
            case .error:
                ErrorOutputView(
                    message: output.content,
                    details: output.metadata?["details"] as? String
                )
            
            case .fileChange:
                FileChangeView(
                    path: output.metadata?["path"] as? String ?? "",
                    changeType: output.metadata?["changeType"] as? String ?? ""
                )
            }
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .cornerRadius(8)
    }
    
    private func sourceColor(_ source: String) -> Color {
        switch source.uppercased() {
        case "AGENT":
            return .blue
        case "SYSTEM":
            return .gray
        case "USER":
            return .green
        default:
            return .gray
        }
    }
}

// Specialized views for different output types

struct MarkdownView: View {
    let markdown: String
    
    var body: some View {
        // Use a markdown rendering library or WebKit
        Text(markdown)
    }
}

struct CodeBlockView: View {
    let code: String
    let language: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            if !language.isEmpty {
                Text(language)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.horizontal, 8)
            }
            
            ScrollView(.horizontal, showsIndicators: true) {
                Text(code)
                    .font(.system(.body, design: .monospaced))
                    .padding(8)
                    .textSelection(.enabled)
            }
            .background(Color(.tertiarySystemBackground))
            .cornerRadius(4)
        }
    }
}

struct TerminalOutputView: View {
    let command: String?
    let output: String
    let exitCode: Int
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            if let command = command {
                HStack {
                    Text("$")
                        .foregroundColor(.secondary)
                    Text(command)
                        .bold()
                        .textSelection(.enabled)
                }
                .font(.system(.body, design: .monospaced))
                .padding(.bottom, 2)
            }
            
            Text(output)
                .font(.system(.body, design: .monospaced))
                .textSelection(.enabled)
            
            if exitCode != 0 {
                Text("Exit code: \(exitCode)")
                    .font(.caption)
                    .foregroundColor(.red)
                    .padding(.top, 2)
            }
        }
        .padding(8)
        .background(Color.black.opacity(0.8))
        .foregroundColor(.white)
        .cornerRadius(4)
    }
}

struct ErrorOutputView: View {
    let message: String
    let details: String?
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(message)
                .foregroundColor(.red)
                .bold()
                .textSelection(.enabled)
            
            if let details = details {
                Text(details)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .textSelection(.enabled)
                    .padding(.top, 2)
            }
        }
        .padding(8)
        .background(Color.red.opacity(0.1))
        .cornerRadius(4)
    }
}

struct FileChangeView: View {
    let path: String
    let changeType: String
    
    var body: some View {
        HStack {
            Image(systemName: iconForChangeType(changeType))
                .foregroundColor(colorForChangeType(changeType))
            
            VStack(alignment: .leading) {
                Text(changeTypeDescription(changeType))
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Text(path)
                    .font(.system(.body, design: .monospaced))
                    .textSelection(.enabled)
            }
        }
        .padding(8)
        .background(colorForChangeType(changeType).opacity(0.1))
        .cornerRadius(4)
    }
    
    private func iconForChangeType(_ type: String) -> String {
        switch type.lowercased() {
        case "create":
            return "plus.circle"
        case "modify", "edit":
            return "pencil.circle"
        case "delete":
            return "minus.circle"
        case "read":
            return "eye.circle"
        default:
            return "doc.circle"
        }
    }
    
    private func colorForChangeType(_ type: String) -> Color {
        switch type.lowercased() {
        case "create":
            return .green
        case "modify", "edit":
            return .blue
        case "delete":
            return .red
        case "read":
            return .gray
        default:
            return .gray
        }
    }
    
    private func changeTypeDescription(_ type: String) -> String {
        switch type.lowercased() {
        case "create":
            return "Created file"
        case "modify", "edit":
            return "Modified file"
        case "delete":
            return "Deleted file"
        case "read":
            return "Read file"
        default:
            return "File operation"
        }
    }
}
```

### 3.3 View Model

```swift
class AgentOutputViewModel: ObservableObject {
    @Published var outputs: [AgentOutput] = []
    
    private let socketManager: SocketIOManager
    
    init(socketManager: SocketIOManager) {
        self.socketManager = socketManager
        setupEventHandlers()
    }
    
    private func setupEventHandlers() {
        socketManager.onEvent = { [weak self] eventData in
            self?.processEvent(eventData)
        }
    }
    
    private func processEvent(_ eventData: [String: Any]) {
        // Extract common fields
        let timestamp = Date()
        let source = eventData["source"] as? String
        let message = eventData["message"] as? String ?? ""
        
        // Determine output type and content
        if let observation = eventData["observation"] as? [String: Any],
           let observationType = observation["observation"] as? String {
            
            switch observationType {
            case "CmdOutputObservation":
                if let content = eventData["content"] as? String,
                   let extras = eventData["extras"] as? [String: Any],
                   let command = extras["command"] as? String,
                   let exitCode = extras["exit_code"] as? Int {
                    
                    addOutput(
                        content: content,
                        type: .terminal,
                        source: source,
                        metadata: [
                            "command": command,
                            "exitCode": exitCode
                        ]
                    )
                }
                
            case "FileObservation":
                if let content = eventData["content"] as? String,
                   let path = eventData["path"] as? String {
                    
                    addOutput(
                        content: content,
                        type: .code,
                        source: source,
                        metadata: [
                            "path": path,
                            "language": pathToLanguage(path)
                        ]
                    )
                } else if let path = eventData["path"] as? String,
                          let success = eventData["success"] as? Bool {
                    
                    let operation = eventData["operation"] as? String ?? "file_operation"
                    
                    addOutput(
                        content: "\(operation.capitalized) \(success ? "succeeded" : "failed"): \(path)",
                        type: .fileChange,
                        source: source,
                        metadata: [
                            "path": path,
                            "changeType": operation,
                            "success": success
                        ]
                    )
                }
                
            default:
                // Handle other observation types or generic messages
                addOutput(
                    content: message,
                    type: .text,
                    source: source
                )
            }
        } else if let error = eventData["error"] as? [String: Any],
                  let errorMessage = error["message"] as? String {
            
            addOutput(
                content: errorMessage,
                type: .error,
                source: source,
                metadata: [
                    "details": error["details"] as? String ?? ""
                ]
            )
        } else {
            // Generic message
            addOutput(
                content: message,
                type: .text,
                source: source
            )
        }
    }
    
    private func addOutput(
        content: String,
        type: AgentOutputType,
        source: String?,
        metadata: [String: Any]? = nil
    ) {
        let output = AgentOutput(
            id: UUID(),
            content: content,
            type: type,
            source: source,
            timestamp: Date(),
            metadata: metadata
        )
        
        DispatchQueue.main.async {
            self.outputs.append(output)
            
            // Limit the number of outputs to prevent memory issues
            if self.outputs.count > 1000 {
                self.outputs.removeFirst(100)
            }
        }
    }
    
    private func pathToLanguage(_ path: String) -> String {
        let fileExtension = path.components(separatedBy: ".").last?.lowercased() ?? ""
        
        switch fileExtension {
        case "swift": return "Swift"
        case "java": return "Java"
        case "kt": return "Kotlin"
        case "js": return "JavaScript"
        case "ts": return "TypeScript"
        case "py": return "Python"
        case "rb": return "Ruby"
        case "go": return "Go"
        case "rs": return "Rust"
        case "c", "cpp", "h", "hpp": return "C/C++"
        case "cs": return "C#"
        case "php": return "PHP"
        case "html": return "HTML"
        case "css": return "CSS"
        case "json": return "JSON"
        case "xml": return "XML"
        case "yaml", "yml": return "YAML"
        case "md": return "Markdown"
        case "sh", "bash": return "Shell"
        default: return ""
        }
    }
}

struct AgentOutput: Identifiable {
    let id: UUID
    let content: String
    let type: AgentOutputType
    let source: String?
    let timestamp: Date
    let metadata: [String: Any]?
}

enum AgentOutputType {
    case text
    case markdown
    case code
    case terminal
    case error
    case fileChange
}
```

## 4. Task Input Area Component

The Task Input Area allows users to input instructions and tasks for the agent.

### 4.1 Design and Behavior

- Multi-line text input field
- Submit button
- Optional support for text formatting
- Optional support for image attachments
- Command history (optional for MVP)

### 4.2 SwiftUI Implementation

```swift
struct TaskInputView: View {
    @ObservedObject var viewModel: TaskInputViewModel
    @FocusState private var isInputFocused: Bool
    
    var body: some View {
        VStack(spacing: 0) {
            Divider()
            
            HStack(alignment: .bottom, spacing: 8) {
                // Text input field
                ZStack(alignment: .topLeading) {
                    if viewModel.inputText.isEmpty {
                        Text("Type your instructions here...")
                            .foregroundColor(.secondary)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 8)
                            .allowsHitTesting(false)
                    }
                    
                    TextEditor(text: $viewModel.inputText)
                        .focused($isInputFocused)
                        .padding(4)
                        .background(Color(.textBackgroundColor))
                        .cornerRadius(8)
                        .frame(minHeight: 40, maxHeight: 200)
                }
                
                // Submit button
                Button(action: {
                    viewModel.submitInput()
                    isInputFocused = true
                }) {
                    Text("Submit")
                        .frame(minWidth: 80)
                }
                .keyboardShortcut(.return, modifiers: [.command])
                .disabled(viewModel.inputText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty || viewModel.isSubmitting)
            }
            .padding(8)
        }
        .background(Color(.systemBackground))
    }
}
```

### 4.3 View Model

```swift
class TaskInputViewModel: ObservableObject {
    @Published var inputText: String = ""
    @Published var isSubmitting: Bool = false
    
    private let socketManager: SocketIOManager
    
    init(socketManager: SocketIOManager) {
        self.socketManager = socketManager
    }
    
    func submitInput() {
        let text = inputText.trimmingCharacters(in: .whitespacesAndNewlines)
        
        guard !text.isEmpty else { return }
        
        isSubmitting = true
        
        // Send message to backend
        socketManager.sendAction(
            action: "message",
            args: [
                "content": text,
                "timestamp": ISO8601DateFormatter().string(from: Date())
            ]
        )
        
        // Clear input after sending
        inputText = ""
        isSubmitting = false
    }
}
```

## 5. Agent Control Buttons Component

The Agent Control Buttons allow users to control the agent's execution state.

### 5.1 Design and Behavior

- Start/Resume button
- Pause button
- Stop button
- Visual indication of current agent state
- Confirmation for potentially destructive actions

### 5.2 SwiftUI Implementation

```swift
struct AgentControlButtons: View {
    @ObservedObject var viewModel: AgentControlViewModel
    @State private var showStopConfirmation = false
    
    var body: some View {
        HStack {
            // Start/Resume button
            Button(action: {
                viewModel.startOrResumeAgent()
            }) {
                Label("Start", systemImage: "play.fill")
            }
            .disabled(!viewModel.canStartOrResume)
            
            // Pause button
            Button(action: {
                viewModel.pauseAgent()
            }) {
                Label("Pause", systemImage: "pause.fill")
            }
            .disabled(!viewModel.canPause)
            
            // Stop button
            Button(action: {
                if viewModel.requiresStopConfirmation {
                    showStopConfirmation = true
                } else {
                    viewModel.stopAgent()
                }
            }) {
                Label("Stop", systemImage: "stop.fill")
            }
            .disabled(!viewModel.canStop)
            .confirmationDialog(
                "Stop Agent",
                isPresented: $showStopConfirmation,
                actions: {
                    Button("Stop Agent", role: .destructive) {
                        viewModel.stopAgent()
                    }
                    Button("Cancel", role: .cancel) {}
                },
                message: {
                    Text("Are you sure you want to stop the agent? This will terminate the current task.")
                }
            )
            
            // Status indicator
            HStack(spacing: 4) {
                Circle()
                    .fill(statusColor(viewModel.agentState))
                    .frame(width: 8, height: 8)
                
                Text(statusText(viewModel.agentState))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            .padding(.horizontal, 8)
        }
    }
    
    private func statusColor(_ state: AgentState) -> Color {
        switch state {
        case .running:
            return .green
        case .paused:
            return .yellow
        case .stopped, .finished:
            return .gray
        case .error:
            return .red
        case .awaitingUserInput:
            return .blue
        default:
            return .gray
        }
    }
    
    private func statusText(_ state: AgentState) -> String {
        switch state {
        case .running:
            return "Running"
        case .paused:
            return "Paused"
        case .stopped:
            return "Stopped"
        case .finished:
            return "Finished"
        case .error:
            return "Error"
        case .awaitingUserInput:
            return "Waiting for input"
        default:
            return "Unknown"
        }
    }
}
```

### 5.3 View Model

```swift
class AgentControlViewModel: ObservableObject {
    @Published var agentState: AgentState = .stopped
    
    private let socketManager: SocketIOManager
    
    init(socketManager: SocketIOManager) {
        self.socketManager = socketManager
        setupEventHandlers()
    }
    
    private func setupEventHandlers() {
        socketManager.onEvent = { [weak self] eventData in
            if let stateString = eventData["agent_state"] as? String {
                self?.updateAgentState(stateString)
            }
        }
    }
    
    private func updateAgentState(_ stateString: String) {
        let newState: AgentState
        
        switch stateString.uppercased() {
        case "RUNNING":
            newState = .running
        case "PAUSED":
            newState = .paused
        case "STOPPED":
            newState = .stopped
        case "FINISHED":
            newState = .finished
        case "ERROR":
            newState = .error
        case "AWAITING_USER_INPUT":
            newState = .awaitingUserInput
        default:
            newState = .unknown
        }
        
        DispatchQueue.main.async {
            self.agentState = newState
        }
    }
    
    func startOrResumeAgent() {
        let newState: String
        
        if agentState == .stopped {
            newState = "RUNNING"
        } else if agentState == .paused {
            newState = "RUNNING"
        } else {
            return
        }
        
        socketManager.sendAction(
            action: "change_agent_state",
            args: ["agent_state": newState]
        )
    }
    
    func pauseAgent() {
        guard agentState == .running else { return }
        
        socketManager.sendAction(
            action: "change_agent_state",
            args: ["agent_state": "PAUSED"]
        )
    }
    
    func stopAgent() {
        guard agentState == .running || agentState == .paused else { return }
        
        socketManager.sendAction(
            action: "change_agent_state",
            args: ["agent_state": "STOPPED"]
        )
    }
    
    // Computed properties for button states
    
    var canStartOrResume: Bool {
        agentState == .stopped || agentState == .paused || agentState == .error
    }
    
    var canPause: Bool {
        agentState == .running
    }
    
    var canStop: Bool {
        agentState == .running || agentState == .paused
    }
    
    var requiresStopConfirmation: Bool {
        agentState == .running
    }
}

enum AgentState {
    case unknown
    case running
    case paused
    case stopped
    case finished
    case error
    case awaitingUserInput
}
```

## 6. Settings Panel Component

The Settings Panel allows users to configure the Mac client and backend connection.

### 6.1 Design and Behavior

- Modal dialog or separate window
- Categorized settings
- Save/cancel buttons
- Validation of inputs
- Persistent storage of settings

### 6.2 SwiftUI Implementation

```swift
struct SettingsView: View {
    @ObservedObject var viewModel: SettingsViewModel
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack {
            Form {
                Section(header: Text("Backend Connection")) {
                    TextField("Backend URL", text: $viewModel.backendURL)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                    
                    Toggle("Use TLS (HTTPS)", isOn: $viewModel.useTLS)
                }
                
                Section(header: Text("API Keys")) {
                    SecureField("OpenAI API Key", text: $viewModel.openAIKey)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                    
                    // Additional API keys as needed
                }
                
                Section(header: Text("UI Preferences")) {
                    Picker("Theme", selection: $viewModel.theme) {
                        Text("System").tag("system")
                        Text("Light").tag("light")
                        Text("Dark").tag("dark")
                    }
                    .pickerStyle(SegmentedPickerStyle())
                    
                    Stepper("Font Size: \(viewModel.fontSize)", value: $viewModel.fontSize, in: 10...24)
                    
                    Toggle("Show Line Numbers", isOn: $viewModel.showLineNumbers)
                }
            }
            .padding()
            
            Divider()
            
            HStack {
                Button("Cancel") {
                    dismiss()
                }
                
                Spacer()
                
                Button("Save") {
                    viewModel.saveSettings()
                    dismiss()
                }
                .keyboardShortcut(.return, modifiers: [.command])
                .disabled(!viewModel.isValid)
            }
            .padding()
        }
        .frame(width: 500, height: 400)
        .onAppear {
            viewModel.loadSettings()
        }
    }
}
```

### 6.3 View Model

```swift
class SettingsViewModel: ObservableObject {
    // Backend Connection
    @Published var backendURL: String = "http://localhost:8000"
    @Published var useTLS: Bool = false
    
    // API Keys
    @Published var openAIKey: String = ""
    
    // UI Preferences
    @Published var theme: String = "system"
    @Published var fontSize: Int = 14
    @Published var showLineNumbers: Bool = true
    
    // Validation state
    @Published var isValid: Bool = true
    
    private let settingsService: SettingsService
    
    init(settingsService: SettingsService) {
        self.settingsService = settingsService
    }
    
    func loadSettings() {
        Task {
            do {
                if let settings = try await settingsService.getSettings() {
                    await MainActor.run {
                        self.backendURL = settings.backendURL.absoluteString
                        self.useTLS = settings.backendURL.scheme == "https"
                        
                        if let openAIKey = settings.apiKeys["openai"] {
                            self.openAIKey = openAIKey
                        }
                        
                        self.theme = settings.uiPreferences.theme
                        self.fontSize = settings.uiPreferences.fontSize
                        self.showLineNumbers = settings.uiPreferences.showLineNumbers
                        
                        self.validateSettings()
                    }
                }
            } catch {
                print("Error loading settings: \(error)")
            }
        }
    }
    
    func saveSettings() {
        guard isValid else { return }
        
        // Construct URL with appropriate scheme
        var urlString = backendURL
        if !urlString.lowercased().hasPrefix("http") {
            urlString = (useTLS ? "https://" : "http://") + urlString
        }
        
        guard let url = URL(string: urlString) else {
            isValid = false
            return
        }
        
        let settings = Settings(
            backendURL: url,
            apiKeys: ["openai": openAIKey],
            uiPreferences: Settings.UIPreferences(
                theme: theme,
                fontSize: fontSize,
                showLineNumbers: showLineNumbers
            )
        )
        
        Task {
            do {
                let success = try await settingsService.saveSettings(settings: settings)
                if success {
                    print("Settings saved successfully")
                }
            } catch {
                print("Error saving settings: \(error)")
            }
        }
    }
    
    func validateSettings() {
        // Validate backend URL
        let urlString = backendURL
        if !urlString.isEmpty {
            var fullURL = urlString
            if !fullURL.lowercased().hasPrefix("http") {
                fullURL = (useTLS ? "https://" : "http://") + fullURL
            }
            
            isValid = URL(string: fullURL) != nil
        } else {
            isValid = false
        }
    }
}
```

## 7. Error Notification Component

The Error Notification component displays error messages and provides recovery options.

### 7.1 Design and Behavior

- Non-intrusive notifications for minor errors
- Modal dialogs for critical errors
- Recovery options where applicable

### 7.2 SwiftUI Implementation

```swift
struct ErrorNotificationView: View {
    let error: AppError
    let onDismiss: () -> Void
    let onRecovery: (ErrorRecoveryOption) -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: iconForSeverity(error.severity))
                    .foregroundColor(colorForSeverity(error.severity))
                    .font(.title)
                
                Text(error.title)
                    .font(.headline)
                
                Spacer()
                
                Button(action: onDismiss) {
                    Image(systemName: "xmark")
                        .font(.caption)
                }
                .buttonStyle(.borderless)
            }
            
            Text(error.message)
                .font(.body)
            
            if !error.recoveryOptions.isEmpty {
                HStack {
                    Spacer()
                    
                    ForEach(error.recoveryOptions, id: \.title) { option in
                        Button(option.title) {
                            onRecovery(option)
                        }
                        .buttonStyle(.bordered)
                    }
                }
            }
        }
        .padding()
        .background(backgroundForSeverity(error.severity))
        .cornerRadius(8)
        .shadow(radius: 2)
    }
    
    private func iconForSeverity(_ severity: ErrorSeverity) -> String {
        switch severity {
        case .info:
            return "info.circle"
        case .warning:
            return "exclamationmark.triangle"
        case .error:
            return "exclamationmark.circle"
        case .critical:
            return "xmark.octagon"
        }
    }
    
    private func colorForSeverity(_ severity: ErrorSeverity) -> Color {
        switch severity {
        case .info:
            return .blue
        case .warning:
            return .yellow
        case .error:
            return .red
        case .critical:
            return .red
        }
    }
    
    private func backgroundForSeverity(_ severity: ErrorSeverity) -> Color {
        switch severity {
        case .info:
            return Color.blue.opacity(0.1)
        case .warning:
            return Color.yellow.opacity(0.1)
        case .error:
            return Color.red.opacity(0.1)
        case .critical:
            return Color.red.opacity(0.2)
        }
    }
}
```

### 7.3 Error Manager

```swift
class ErrorManager: ObservableObject {
    @Published var currentErrors: [UUID: AppError] = [:]
    
    func showError(_ error: AppError) {
        let id = UUID()
        
        DispatchQueue.main.async {
            self.currentErrors[id] = error
            
            // Auto-dismiss non-critical errors after a delay
            if error.severity != .critical {
                DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                    self.dismissError(id: id)
                }
            }
        }
    }
    
    func dismissError(id: UUID) {
        DispatchQueue.main.async {
            self.currentErrors.removeValue(forKey: id)
        }
    }
    
    func handleRecovery(for error: AppError, option: ErrorRecoveryOption) {
        // Implement recovery actions based on the error and option
        switch (error.code, option.title) {
        case (1001, "Retry"):
            // Retry connection
            retryConnection()
        case (1002, "Reset"):
            // Reset settings
            resetSettings()
        default:
            // Default recovery action
            print("Unhandled recovery action: \(option.title) for error code \(error.code)")
        }
    }
    
    private func retryConnection() {
        // Implement connection retry logic
    }
    
    private func resetSettings() {
        // Implement settings reset logic
    }
}
```

## 8. Main View Model

The Main View Model coordinates between the different components and manages the overall application state.

### 8.1 Implementation

```swift
class MainViewModel: ObservableObject {
    // Child view models
    let fileExplorerViewModel: FileExplorerViewModel
    let outputViewModel: AgentOutputViewModel
    let inputViewModel: TaskInputViewModel
    let controlViewModel: AgentControlViewModel
    let settingsViewModel: SettingsViewModel
    
    // Settings sheet state
    @Published var isSettingsPresented: Bool = false
    
    // Services
    private let socketManager: SocketIOManager
    private let apiClient: APIClient
    private let fileService: FileService
    private let conversationService: ConversationService
    private let settingsService: SettingsService
    
    // Current conversation
    private var conversationId: String
    
    init() {
        // Initialize with default values, will be updated when settings are loaded
        let baseURL = URL(string: "http://localhost:8000")!
        
        // Initialize services
        apiClient = APIClient(baseURL: baseURL)
        fileService = FileService(apiClient: apiClient)
        conversationService = ConversationService(apiClient: apiClient)
        settingsService = SettingsService(apiClient: apiClient)
        
        // Default conversation ID (will be updated)
        conversationId = ""
        
        // Initialize socket manager
        socketManager = SocketIOManager(
            serverURL: baseURL,
            conversationId: conversationId
        )
        
        // Initialize child view models
        fileExplorerViewModel = FileExplorerViewModel(
            fileService: fileService,
            conversationId: conversationId
        )
        
        outputViewModel = AgentOutputViewModel(
            socketManager: socketManager
        )
        
        inputViewModel = TaskInputViewModel(
            socketManager: socketManager
        )
        
        controlViewModel = AgentControlViewModel(
            socketManager: socketManager
        )
        
        settingsViewModel = SettingsViewModel(
            settingsService: settingsService
        )
        
        // Load settings and initialize
        loadSettingsAndConnect()
    }
    
    private func loadSettingsAndConnect() {
        Task {
            do {
                if let settings = try await settingsService.getSettings() {
                    // Update services with new settings
                    updateBackendConnection(url: settings.backendURL)
                    
                    // Create or load conversation
                    await createOrLoadConversation()
                }
            } catch {
                print("Error loading settings: \(error)")
            }
        }
    }
    
    private func updateBackendConnection(url: URL) {
        apiClient.updateBaseURL(url)
        socketManager.updateServerURL(url)
    }
    
    private func createOrLoadConversation() async {
        do {
            // Get recent conversations
            let conversations = try await conversationService.listConversations(limit: 1)
            
            if let mostRecent = conversations.first {
                // Use most recent conversation
                conversationId = mostRecent.id
            } else {
                // Create new conversation
                conversationId = try await conversationService.createConversation(
                    initialUserMessage: "Hello, I'm using the Mac client."
                )
            }
            
            // Update child view models with new conversation ID
            await MainActor.run {
                fileExplorerViewModel.updateConversationId(conversationId)
                socketManager.updateConversationId(conversationId)
                
                // Connect to socket
                socketManager.connect()
                
                // Load initial data
                fileExplorerViewModel.refreshFiles()
            }
        } catch {
            print("Error creating/loading conversation: \(error)")
        }
    }
    
    func showSettings() {
        isSettingsPresented = true
    }
}
```

## 9. Accessibility Considerations

### 9.1 VoiceOver Support

```swift
// Example of enhancing VoiceOver accessibility
struct AccessibleFileNodeView: View {
    let node: FileNode
    let selectedPath: String?
    let onSelect: (String) -> Void
    
    var body: some View {
        HStack {
            if node.isDirectory {
                Image(systemName: "folder")
                    .foregroundColor(.blue)
                    .accessibilityHidden(true)
            } else {
                Image(systemName: fileTypeIcon(for: node.name))
                    .foregroundColor(.gray)
                    .accessibilityHidden(true)
            }
            
            Text(node.name)
                .lineLimit(1)
        }
        .contentShape(Rectangle())
        .onTapGesture {
            onSelect(node.path)
        }
        .background(
            selectedPath == node.path ? Color.accentColor.opacity(0.2) : Color.clear
        )
        .accessibilityLabel(accessibilityLabel)
        .accessibilityHint(accessibilityHint)
        .accessibilityAddTraits(selectedPath == node.path ? .isSelected : [])
        .accessibilityAddTraits(node.isDirectory ? .isButton : [])
    }
    
    private var accessibilityLabel: String {
        let type = node.isDirectory ? "Folder" : "File"
        return "\(type): \(node.name)"
    }
    
    private var accessibilityHint: String {
        if node.isDirectory {
            return "Double tap to expand or collapse folder"
        } else {
            return "Double tap to view file contents"
        }
    }
    
    private func fileTypeIcon(for fileName: String) -> String {
        // Implementation as before
        return "doc"
    }
}
```

### 9.2 Keyboard Navigation

```swift
// Example of enhancing keyboard navigation
struct KeyboardNavigableFileExplorer: View {
    @ObservedObject var viewModel: FileExplorerViewModel
    @FocusState private var isFocused: Bool
    @State private var selectedIndex: Int = 0
    
    var body: some View {
        VStack {
            // Header as before
            
            List(Array(viewModel.rootNodes.enumerated()), id: \.element.id) { index, node in
                FileNodeView(node: node, selectedPath: viewModel.selectedPath) { path in
                    viewModel.selectFile(path: path)
                }
                .background(index == selectedIndex ? Color.accentColor.opacity(0.2) : Color.clear)
                .onTapGesture {
                    selectedIndex = index
                }
            }
            .focused($isFocused)
            .onKeyPress(.upArrow) {
                if selectedIndex > 0 {
                    selectedIndex -= 1
                }
                return .handled
            }
            .onKeyPress(.downArrow) {
                if selectedIndex < viewModel.rootNodes.count - 1 {
                    selectedIndex += 1
                }
                return .handled
            }
            .onKeyPress(.return) {
                if selectedIndex >= 0 && selectedIndex < viewModel.rootNodes.count {
                    let node = viewModel.rootNodes[selectedIndex]
                    viewModel.selectFile(path: node.path)
                }
                return .handled
            }
        }
    }
}
```

## 10. Localization Support

### 10.1 Localized Strings

```swift
// Example of localization support
struct LocalizedFileExplorerView: View {
    @ObservedObject var viewModel: FileExplorerViewModel
    
    var body: some View {
        VStack {
            HStack {
                Text("files_header", bundle: .main, comment: "Header for file explorer")
                    .font(.headline)
                
                Spacer()
                
                Button(action: { viewModel.refreshFiles() }) {
                    Image(systemName: "arrow.clockwise")
                        .imageScale(.small)
                }
                .buttonStyle(.borderless)
                .accessibilityLabel(Text("refresh_files", bundle: .main, comment: "Refresh files button"))
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            
            Divider()
            
            if viewModel.isLoading && viewModel.rootNodes.isEmpty {
                ProgressView(Text("loading_files", bundle: .main, comment: "Loading files progress indicator"))
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if let error = viewModel.error, viewModel.rootNodes.isEmpty {
                VStack {
                    Text("error_loading_files", bundle: .main, comment: "Error loading files message")
                        .foregroundColor(.red)
                    Text(error)
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Button(Text("retry", bundle: .main, comment: "Retry button")) {
                        viewModel.refreshFiles()
                    }
                    .padding(.top)
                }
                .padding()
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                // List as before
            }
        }
    }
}
```

### 10.2 Localized Date and Number Formatting

```swift
// Example of localized date and number formatting
struct LocalizedOutputItemView: View {
    let output: AgentOutput
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(output.timestamp, style: .time)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .environment(\.locale, Locale.current)
                
                if let source = output.source {
                    Text(localizedSource(source))
                        .font(.caption)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(sourceColor(source).opacity(0.2))
                        .cornerRadius(4)
                }
                
                Spacer()
            }
            
            // Output content as before
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .cornerRadius(8)
    }
    
    private func localizedSource(_ source: String) -> String {
        switch source.uppercased() {
        case "AGENT":
            return NSLocalizedString("source_agent", comment: "Agent source label")
        case "SYSTEM":
            return NSLocalizedString("source_system", comment: "System source label")
        case "USER":
            return NSLocalizedString("source_user", comment: "User source label")
        default:
            return source
        }
    }
    
    private func sourceColor(_ source: String) -> Color {
        // Implementation as before
        return .gray
    }
}
```

This comprehensive UI components specification provides the detailed technical guidance needed to implement the OpenHands Mac client, covering all the necessary UI components for a functional MVP.

---

# todo.md

# Missing Elements in Mac Client MVP Specification

This document outlines specific technical gaps in the current Mac client MVP specification that need to be addressed for a complete implementation guide.

## Technical Implementation Details

- [x] **Socket.IO Implementation Details**:
  - [x] Specific implementation details for handling Socket.IO connections
  - [x] Reconnection strategy when connection is lost
  - [x] Error handling for Socket.IO events
  - [x] Event queuing during disconnections

- [x] **UI Component Architecture**:
  - [x] Detailed breakdown of UI components and their relationships
  - [x] View hierarchy and navigation flow
  - [x] Specification for how the MVVM pattern should be implemented for each feature

- [x] **File Explorer Implementation**:
  - [x] Details on how file system data will be fetched and cached
  - [x] Specification for file content display (syntax highlighting, encoding handling)
  - [x] Pagination or lazy loading strategy for large directories

- [x] **Agent Output Display Implementation**: (implemented in impl_chat_box.md)
  - [x] Specification for how to handle different types of agent outputs (text, code, images)
  - [x] Details on output formatting and styling
  - [x] Scrolling or history management specification

- [x] **Backend Connection Management**:
  - [x] Details on connection persistence across app launches
  - [x] Specification for connection status indicators
  - [x] Retry mechanism details

- [x] **State Synchronization**:
  - [x] Specification for how to handle state synchronization between the app and backend
  - [x] Details on conflict resolution when state diverges
  - [x] Specification for handling stale state

- [x] **Error States and Recovery**:
  - [x] Defined error states for the application
  - [x] User feedback mechanisms for errors
  - [x] Recovery procedures for common failure scenarios

- [x] **Performance Considerations**:
  - [x] Specifications for handling large outputs from the agent
  - [x] Details on UI responsiveness during heavy operations
  - [x] Memory management strategy for long-running sessions

- [x] **Specific Swift Implementation Details**:
  - [x] Guidance on Swift concurrency approach (async/await, Combine, etc.)
  - [x] Details on property wrapper usage for state management
  - [x] Specification for dependency injection approach

- [x] **Event Handling Architecture**:
  - [x] Detailed specification for how events from the backend will be processed and routed to appropriate components
  - [x] Details on event prioritization and queueing

- [ ] **Implementation Verification**:
  - [ ] impl_error_handling.md has code about events handling in general, is that correct?
  - [ ] Agent Output Display is implemented in impl_chat_box.md rather than a separate file