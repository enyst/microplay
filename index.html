<!DOCTYPE html>
<html>
<head>
  <title>Files to Prompt Selector</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.5;
    }
    
    h1, h2, h3 {
      color: #24292e;
    }
    
    .file-tree {
      list-style-type: none;
      padding-left: 20px;
      margin: 0;
    }
    
    .file-tree-root {
      padding-left: 0;
    }
    
    .directory-label {
      cursor: pointer;
      user-select: none;
      display: inline-block;
      padding: 3px;
      border-radius: 3px;
    }
    
    .directory-label:hover {
      background-color: #f0f0f0;
    }
    
    .file-label {
      display: inline-block;
      padding: 3px;
      border-radius: 3px;
    }
    
    .selected {
      background-color: #e6f7ff;
    }
    
    .options-panel {
      background-color: #f8f8f8;
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
    }
    
    .options-panel label {
      display: block;
      margin-bottom: 10px;
    }
    
    button {
      background-color: #2ea44f;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      margin-top: 10px;
    }
    
    button:hover {
      background-color: #2c974b;
    }
    
    button:disabled {
      background-color: #94d3a2;
      cursor: not-allowed;
    }
    
    .loading {
      color: #666;
      font-style: italic;
    }
    
    .breadcrumb {
      margin-bottom: 15px;
      padding: 8px;
      background-color: #f8f8f8;
      border-radius: 4px;
    }
    
    .breadcrumb a {
      color: #0366d6;
      text-decoration: none;
    }
    
    .breadcrumb a:hover {
      text-decoration: underline;
    }
    
    .path-display {
      margin-top: 20px;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .select-all {
      margin-bottom: 10px;
    }
    
    .error {
      color: #cb2431;
      background-color: #ffeef0;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }
    
    .success {
      color: #22863a;
      background-color: #f0fff4;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }
    
    .token-input {
      margin-top: 20px;
      padding: 15px;
      background-color: #f8f8f8;
      border-radius: 5px;
    }
    
    .token-input input {
      width: 100%;
      padding: 8px;
      margin-top: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    
    .output-container {
      margin-top: 20px;
      padding: 15px;
      background-color: #f8f8f8;
      border-radius: 5px;
      display: none;
    }
    
    .output-text {
      white-space: pre-wrap;
      background-color: #f6f8fa;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #ddd;
      max-height: 400px;
      overflow-y: auto;
    }
    
    .copy-button {
      background-color: #0366d6;
      margin-left: 10px;
    }
    
    .copy-button:hover {
      background-color: #0256b9;
    }
    
    .repo-selector {
      margin-bottom: 20px;
    }
    
    .repo-selector input, .repo-selector select {
      padding: 8px;
      margin-right: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>Files to Prompt Selector</h1>
  
  <div class="repo-selector">
    <h2>Repository Information</h2>
    <div>
      <label for="owner">Owner:</label>
      <input type="text" id="owner" placeholder="GitHub username or organization">
      
      <label for="repo">Repository:</label>
      <input type="text" id="repo" placeholder="Repository name">
      
      <label for="branch">Branch:</label>
      <input type="text" id="branch" placeholder="main" value="main">
      
      <button id="load-repo-btn">Load Repository</button>
    </div>
  </div>
  
  <div class="token-input">
    <h2>GitHub Authentication</h2>
    <p>A GitHub token is required to access repository contents. This token is stored only in your browser and is never sent to our servers.</p>
    <label for="github-token">GitHub Token (with repo scope):</label>
    <input type="password" id="github-token" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx">
  </div>
  
  <div class="options-panel">
    <h2>Options</h2>
    <label>
      <input type="checkbox" id="line-numbers"> Include line numbers
    </label>
    <label>
      <input type="checkbox" id="include-hidden"> Include hidden files
    </label>
    <label>
      Output format:
      <select id="output-format">
        <option value="markdown">Markdown</option>
        <option value="cxml">Claude XML</option>
        <option value="default">Default (plain text)</option>
      </select>
    </label>
    <label>
      <input type="checkbox" id="local-processing"> Process files locally (no GitHub workflow)
    </label>
  </div>
  
  <div id="repository-browser" style="display: none;">
    <div class="breadcrumb" id="breadcrumb">
      <span>Repository: </span><a href="#" data-path="">root</a>
    </div>
    
    <div class="select-all">
      <label>
        <input type="checkbox" id="select-all-checkbox"> Select all in current view
      </label>
    </div>
    
    <div id="file-tree-container">
      <p class="loading">Loading repository structure...</p>
    </div>
    
    <div class="path-display">
      <h3>Selected Paths:</h3>
      <div id="selected-paths"></div>
    </div>
    
    <button id="generate-btn" disabled>Generate Prompt</button>
  </div>
  
  <div id="output-container" class="output-container">
    <h2>Generated Prompt</h2>
    <div class="output-actions">
      <button id="copy-output-btn" class="copy-button">Copy to Clipboard</button>
      <button id="download-output-btn" class="copy-button">Download as File</button>
    </div>
    <pre id="output-text" class="output-text"></pre>
  </div>
  
  <script>
    // DOM Elements
    const ownerInput = document.getElementById('owner');
    const repoInput = document.getElementById('repo');
    const branchInput = document.getElementById('branch');
    const tokenInput = document.getElementById('github-token');
    const loadRepoBtn = document.getElementById('load-repo-btn');
    const repositoryBrowser = document.getElementById('repository-browser');
    const fileTreeContainer = document.getElementById('file-tree-container');
    const breadcrumbContainer = document.getElementById('breadcrumb');
    const selectedPathsDisplay = document.getElementById('selected-paths');
    const selectAllCheckbox = document.getElementById('select-all-checkbox');
    const generateBtn = document.getElementById('generate-btn');
    const localProcessingCheckbox = document.getElementById('local-processing');
    const outputContainer = document.getElementById('output-container');
    const outputText = document.getElementById('output-text');
    const copyOutputBtn = document.getElementById('copy-output-btn');
    const downloadOutputBtn = document.getElementById('download-output-btn');
    
    // State
    let currentPath = '';
    let selectedPaths = new Set();
    let fileCache = {};
    
    // Load repository
    loadRepoBtn.addEventListener('click', () => {
      const owner = ownerInput.value.trim();
      const repo = repoInput.value.trim();
      const branch = branchInput.value.trim() || 'main';
      const token = tokenInput.value.trim();
      
      if (!owner || !repo) {
        alert('Please enter both owner and repository name');
        return;
      }
      
      if (!token) {
        alert('Please enter a GitHub token');
        return;
      }
      
      // Reset state
      currentPath = '';
      selectedPaths.clear();
      fileCache = {};
      
      // Show repository browser
      repositoryBrowser.style.display = 'block';
      
      // Load repository contents
      fetchRepoContents(owner, repo, branch, token, '');
    });
    
    // Fetch repository contents for a specific path
    async function fetchRepoContents(owner, repo, branch, token, path = '') {
      fileTreeContainer.innerHTML = '<p class="loading">Loading repository structure...</p>';
      generateBtn.disabled = true;
      
      try {
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branch}`;
        const response = await fetch(url, {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (!response.ok) {
          throw new Error(`Failed to fetch repository contents: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Sort: directories first, then files, both alphabetically
        const sortedData = Array.isArray(data) ? 
          [...data].sort((a, b) => {
            if (a.type !== b.type) {
              return a.type === 'dir' ? -1 : 1;
            }
            return a.name.localeCompare(b.name);
          }) : data;
        
        renderFileTree(owner, repo, branch, token, sortedData, path);
        updateBreadcrumb(owner, repo, branch, token, path);
        generateBtn.disabled = selectedPaths.size === 0;
        return sortedData;
      } catch (error) {
        console.error('Error fetching repository contents:', error);
        fileTreeContainer.innerHTML = `<p class="error">Error loading repository structure: ${error.message}</p>`;
        return [];
      }
    }
    
    // Render the file tree
    function renderFileTree(owner, repo, branch, token, items, currentPath) {
      fileTreeContainer.innerHTML = '';
      
      if (!Array.isArray(items)) {
        fileTreeContainer.innerHTML = '<p>This is a file, not a directory.</p>';
        return;
      }
      
      if (items.length === 0) {
        fileTreeContainer.innerHTML = '<p>This directory is empty.</p>';
        return;
      }
      
      const ul = document.createElement('ul');
      ul.className = 'file-tree file-tree-root';
      
      items.forEach(item => {
        const li = document.createElement('li');
        
        const itemPath = currentPath ? `${currentPath}/${item.name}` : item.name;
        
        if (item.type === 'dir') {
          // Directory
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.dataset.path = itemPath;
          checkbox.checked = selectedPaths.has(itemPath);
          checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
              selectedPaths.add(itemPath);
            } else {
              selectedPaths.delete(itemPath);
            }
            updateSelectedPathsDisplay();
            generateBtn.disabled = selectedPaths.size === 0;
          });
          
          const dirSpan = document.createElement('span');
          dirSpan.className = 'directory-label';
          dirSpan.innerHTML = `📁 ${item.name}`;
          dirSpan.addEventListener('click', () => navigateTo(owner, repo, branch, token, itemPath));
          
          li.appendChild(checkbox);
          li.appendChild(dirSpan);
        } else {
          // File
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.dataset.path = itemPath;
          checkbox.checked = selectedPaths.has(itemPath);
          checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
              selectedPaths.add(itemPath);
            } else {
              selectedPaths.delete(itemPath);
            }
            updateSelectedPathsDisplay();
            generateBtn.disabled = selectedPaths.size === 0;
          });
          
          const fileSpan = document.createElement('span');
          fileSpan.className = 'file-label';
          fileSpan.innerHTML = `📄 ${item.name}`;
          
          li.appendChild(checkbox);
          li.appendChild(fileSpan);
        }
        
        ul.appendChild(li);
      });
      
      fileTreeContainer.appendChild(ul);
      
      // Update select all checkbox state
      updateSelectAllCheckbox();
    }
    
    // Navigate to a specific path
    function navigateTo(owner, repo, branch, token, path) {
      currentPath = path;
      fetchRepoContents(owner, repo, branch, token, path);
    }
    
    // Update breadcrumb navigation
    function updateBreadcrumb(owner, repo, branch, token, path) {
      const parts = path.split('/').filter(Boolean);
      
      // Clear existing breadcrumb except for the root link
      while (breadcrumbContainer.childNodes.length > 2) {
        breadcrumbContainer.removeChild(breadcrumbContainer.lastChild);
      }
      
      // Update root link
      const rootLink = breadcrumbContainer.querySelector('a');
      rootLink.dataset.path = '';
      rootLink.addEventListener('click', (e) => {
        e.preventDefault();
        navigateTo(owner, repo, branch, token, '');
      });
      
      // Add path parts
      let currentPathPart = '';
      parts.forEach((part, index) => {
        breadcrumbContainer.appendChild(document.createTextNode(' / '));
        
        currentPathPart = currentPathPart ? `${currentPathPart}/${part}` : part;
        
        const link = document.createElement('a');
        link.href = '#';
        link.textContent = part;
        link.dataset.path = currentPathPart;
        
        link.addEventListener('click', (e) => {
          e.preventDefault();
          navigateTo(owner, repo, branch, token, link.dataset.path);
        });
        
        breadcrumbContainer.appendChild(link);
      });
    }
    
    // Update the display of selected paths
    function updateSelectedPathsDisplay() {
      selectedPathsDisplay.innerHTML = '';
      
      if (selectedPaths.size === 0) {
        selectedPathsDisplay.textContent = 'No files or directories selected';
        return;
      }
      
      const ul = document.createElement('ul');
      
      Array.from(selectedPaths).sort().forEach(path => {
        const li = document.createElement('li');
        li.textContent = path;
        
        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove';
        removeBtn.style.marginLeft = '10px';
        removeBtn.style.padding = '2px 5px';
        removeBtn.style.fontSize = '12px';
        
        removeBtn.addEventListener('click', () => {
          selectedPaths.delete(path);
          updateSelectedPathsDisplay();
          
          // Update checkbox if it's visible in the current view
          const checkbox = document.querySelector(`input[data-path="${path}"]`);
          if (checkbox) {
            checkbox.checked = false;
          }
          
          updateSelectAllCheckbox();
          generateBtn.disabled = selectedPaths.size === 0;
        });
        
        li.appendChild(removeBtn);
        ul.appendChild(li);
      });
      
      selectedPathsDisplay.appendChild(ul);
    }
    
    // Update the "select all" checkbox state
    function updateSelectAllCheckbox() {
      const checkboxes = document.querySelectorAll('#file-tree-container input[type="checkbox"]');
      
      if (checkboxes.length === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.disabled = true;
        return;
      }
      
      selectAllCheckbox.disabled = false;
      
      const allChecked = Array.from(checkboxes).every(cb => cb.checked);
      const someChecked = Array.from(checkboxes).some(cb => cb.checked);
      
      selectAllCheckbox.checked = allChecked;
      selectAllCheckbox.indeterminate = someChecked && !allChecked;
    }
    
    // Select all checkbox handler
    selectAllCheckbox.addEventListener('change', (e) => {
      const checkboxes = document.querySelectorAll('#file-tree-container input[type="checkbox"]');
      
      checkboxes.forEach(checkbox => {
        checkbox.checked = e.target.checked;
        
        if (e.target.checked) {
          selectedPaths.add(checkbox.dataset.path);
        } else {
          selectedPaths.delete(checkbox.dataset.path);
        }
      });
      
      updateSelectedPathsDisplay();
      generateBtn.disabled = selectedPaths.size === 0;
    });
    
    // Fetch file content
    async function fetchFileContent(owner, repo, branch, token, path) {
      try {
        // Check if we have this file cached
        if (fileCache[path]) {
          return fileCache[path];
        }
        
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branch}`;
        const response = await fetch(url, {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (!response.ok) {
          throw new Error(`Failed to fetch file content: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // GitHub API returns content as base64
        const content = atob(data.content);
        
        // Cache the content
        fileCache[path] = content;
        
        return content;
      } catch (error) {
        console.error(`Error fetching content for ${path}:`, error);
        return `Error: Could not fetch content for ${path}: ${error.message}`;
      }
    }
    
    // Process files locally
    async function processFilesLocally(owner, repo, branch, token) {
      const options = {
        lineNumbers: document.getElementById('line-numbers').checked,
        includeHidden: document.getElementById('include-hidden').checked,
        outputFormat: document.getElementById('output-format').value
      };
      
      let output = '';
      
      // Process each selected path
      for (const path of selectedPaths) {
        try {
          // Check if this is a directory
          const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branch}`;
          const response = await fetch(url, {
            headers: {
              'Authorization': `token ${token}`,
              'Accept': 'application/vnd.github.v3+json'
            }
          });
          
          if (!response.ok) {
            throw new Error(`Failed to fetch ${path}: ${response.statusText}`);
          }
          
          const data = await response.json();
          
          if (Array.isArray(data)) {
            // This is a directory, process each file
            for (const item of data) {
              if (item.type === 'file') {
                const filePath = `${path}/${item.name}`;
                
                // Skip hidden files if not including them
                if (!options.includeHidden && item.name.startsWith('.')) {
                  continue;
                }
                
                const content = await fetchFileContent(owner, repo, branch, token, filePath);
                
                // Add to output based on format
                if (options.outputFormat === 'markdown') {
                  output += `${filePath}\n\`\`\`\n`;
                  if (options.lineNumbers) {
                    const lines = content.split('\n');
                    output += lines.map((line, i) => `${i + 1} ${line}`).join('\n');
                  } else {
                    output += content;
                  }
                  output += '\n\`\`\`\n\n';
                } else if (options.outputFormat === 'cxml') {
                  output += `<document>\n<source>${filePath}</source>\n<document_content>\n`;
                  if (options.lineNumbers) {
                    const lines = content.split('\n');
                    output += lines.map((line, i) => `${i + 1} ${line}`).join('\n');
                  } else {
                    output += content;
                  }
                  output += '\n</document_content>\n</document>\n\n';
                } else {
                  // Default format
                  output += `${filePath}\n---\n`;
                  if (options.lineNumbers) {
                    const lines = content.split('\n');
                    output += lines.map((line, i) => `${i + 1} ${line}`).join('\n');
                  } else {
                    output += content;
                  }
                  output += '\n\n';
                }
              }
            }
          } else {
            // This is a file
            const content = await fetchFileContent(owner, repo, branch, token, path);
            
            // Add to output based on format
            if (options.outputFormat === 'markdown') {
              output += `${path}\n\`\`\`\n`;
              if (options.lineNumbers) {
                const lines = content.split('\n');
                output += lines.map((line, i) => `${i + 1} ${line}`).join('\n');
              } else {
                output += content;
              }
              output += '\n\`\`\`\n\n';
            } else if (options.outputFormat === 'cxml') {
              output += `<document>\n<source>${path}</source>\n<document_content>\n`;
              if (options.lineNumbers) {
                const lines = content.split('\n');
                output += lines.map((line, i) => `${i + 1} ${line}`).join('\n');
              } else {
                output += content;
              }
              output += '\n</document_content>\n</document>\n\n';
            } else {
              // Default format
              output += `${path}\n---\n`;
              if (options.lineNumbers) {
                const lines = content.split('\n');
                output += lines.map((line, i) => `${i + 1} ${line}`).join('\n');
              } else {
                output += content;
              }
              output += '\n\n';
            }
          }
        } catch (error) {
          console.error(`Error processing ${path}:`, error);
          output += `Error processing ${path}: ${error.message}\n\n`;
        }
      }
      
      // Wrap CXML output in documents tags
      if (options.outputFormat === 'cxml') {
        output = `<documents>\n${output}</documents>`;
      }
      
      return output;
    }
    
    // Generate prompt
    generateBtn.addEventListener('click', async () => {
      const owner = ownerInput.value.trim();
      const repo = repoInput.value.trim();
      const branch = branchInput.value.trim() || 'main';
      const token = tokenInput.value.trim();
      
      if (selectedPaths.size === 0) {
        alert('Please select at least one file or directory');
        return;
      }
      
      generateBtn.disabled = true;
      generateBtn.textContent = 'Generating...';
      
      try {
        if (localProcessingCheckbox.checked) {
          // Process files locally
          const output = await processFilesLocally(owner, repo, branch, token);
          
          // Display output
          outputText.textContent = output;
          outputContainer.style.display = 'block';
        } else {
          // Use GitHub workflow (this is a placeholder - in a real implementation, you would trigger a GitHub workflow)
          alert('GitHub workflow integration is not implemented in this demo. Please use local processing instead.');
          
          // For demonstration purposes, we'll still process locally
          const output = await processFilesLocally(owner, repo, branch, token);
          
          // Display output
          outputText.textContent = output;
          outputContainer.style.display = 'block';
        }
      } catch (error) {
        console.error('Error generating prompt:', error);
        alert(`Error generating prompt: ${error.message}`);
      } finally {
        generateBtn.disabled = false;
        generateBtn.textContent = 'Generate Prompt';
      }
    });
    
    // Copy output to clipboard
    copyOutputBtn.addEventListener('click', () => {
      navigator.clipboard.writeText(outputText.textContent)
        .then(() => {
          copyOutputBtn.textContent = 'Copied!';
          setTimeout(() => {
            copyOutputBtn.textContent = 'Copy to Clipboard';
          }, 2000);
        })
        .catch(err => {
          console.error('Failed to copy text: ', err);
          alert('Failed to copy text to clipboard');
        });
    });
    
    // Download output as file
    downloadOutputBtn.addEventListener('click', () => {
      const blob = new Blob([outputText.textContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      
      const format = document.getElementById('output-format').value;
      let extension = 'txt';
      
      if (format === 'markdown') {
        extension = 'md';
      } else if (format === 'cxml') {
        extension = 'xml';
      }
      
      a.href = url;
      a.download = `files-to-prompt.${extension}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
    
    // Load values from URL parameters if present
    document.addEventListener('DOMContentLoaded', () => {
      const params = new URLSearchParams(window.location.search);
      
      if (params.has('owner')) {
        ownerInput.value = params.get('owner');
      }
      
      if (params.has('repo')) {
        repoInput.value = params.get('repo');
      }
      
      if (params.has('branch')) {
        branchInput.value = params.get('branch');
      }
    });
  </script>
</body>
</html>